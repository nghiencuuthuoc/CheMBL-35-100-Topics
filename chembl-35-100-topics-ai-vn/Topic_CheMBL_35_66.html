
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_66</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Tinh ch·ªânh si√™u tham s·ªë b·∫±ng Optuna cho m√¥ h√¨nh thu·ªëc</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n c√°c ph√¢n t√≠ch, h∆∞·ªõng d·∫´n, code m·∫´u (SQL v√† Python) v√† c√°c v√≠ d·ª• c·ª• th·ªÉ ƒë·ªÉ b·∫°n c√≥ th·ªÉ tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£ nh·∫•t.</p>
<p><strong>T·ªïng quan v·ªÅ d·ª± √°n:</strong></p>
<p>D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, k·∫øt h·ª£p v·ªõi th∆∞ vi·ªán RDKit ƒë·ªÉ h·ªó tr·ª£ c√°c nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. Vi·ªác s·ª≠ d·ª•ng c·∫•u tr√∫c th∆∞ m·ª•c theo chu·∫©n MLOps s·∫Ω gi√∫p b·∫°n t·ªï ch·ª©c v√† qu·∫£n l√Ω d·ª± √°n m·ªôt c√°ch chuy√™n nghi·ªáp.</p>
<p><strong>Ph√¢n t√≠ch m√¥ h√¨nh:</strong></p>
<p>M·ª•c ti√™u ch√≠nh c·ªßa b·∫°n c√≥ th·ªÉ l√†:</p>
<ol>
<li><strong>Kh√°m ph√° d·ªØ li·ªáu (Exploratory Data Analysis - EDA):</strong><ul>
<li>Hi·ªÉu r√µ c·∫•u tr√∫c v√† n·ªôi dung c·ªßa d·ªØ li·ªáu ChEMBL 35.</li>
<li>X√°c ƒë·ªãnh c√°c thu·ªôc t√≠nh quan tr·ªçng v√† m·ªëi quan h·ªá gi·ªØa ch√∫ng.</li>
<li>T√¨m ki·∫øm c√°c xu h∆∞·ªõng v√† m·∫´u ti·ªÅm nƒÉng c√≥ th·ªÉ gi√∫p √≠ch cho vi·ªác ph√°t tri·ªÉn thu·ªëc.</li>
</ul>
</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n (Predictive Modeling):</strong><ul>
<li>D·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c ph√¢n t·ª≠ d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng.</li>
<li>X√°c ƒë·ªãnh c√°c ƒë·∫∑c ƒëi·ªÉm c·∫•u tr√∫c quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh.</li>
<li>T·ªëi ∆∞u h√≥a c·∫•u tr√∫c ph√¢n t·ª≠ ƒë·ªÉ c·∫£i thi·ªán ho·∫°t t√≠nh.</li>
</ul>
</li>
<li><strong>Ph√¢n t√≠ch QSAR/QSPR (Quantitative Structure-Activity Relationship/Quantitative Structure-Property Relationship):</strong><ul>
<li>X√¢y d·ª±ng m√¥ h√¨nh li√™n h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc v√† ho·∫°t t√≠nh sinh h·ªçc/t√≠nh ch·∫•t v·∫≠t l√Ω c·ªßa ph√¢n t·ª≠.</li>
<li>S·ª≠ d·ª•ng m√¥ h√¨nh ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh/t√≠nh ch·∫•t c·ªßa c√°c ph√¢n t·ª≠ m·ªõi.</li>
<li>T√¨m ki·∫øm c√°c ph√¢n t·ª≠ c√≥ ti·ªÅm nƒÉng tr·ªü th√†nh thu·ªëc.</li>
</ul>
</li>
</ol>
<p><strong>H∆∞·ªõng d·∫´n song ng·ªØ:</strong></p>
<p><strong>1. K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 (Connecting to ChEMBL 35 Database):</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng th∆∞ vi·ªán <code>psycopg2</code> trong Python ƒë·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu PostgreSQL.</li>
<li><strong>English:</strong> Use the <code>psycopg2</code> library in Python to connect to the PostgreSQL database.</li>
</ul>
<p>```python
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Function to connect to the database</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Error connecting to the database: {e}")
        return None</p>
<h1>Establish connection</h1>
<p>conn = connect_to_db(db_params)
```</p>
<p><strong>2. Truy v·∫•n d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu (Querying Data from the Database):</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ c√°c b·∫£ng trong c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.</li>
<li><strong>English:</strong> Use SQL to query data from the tables in the ChEMBL 35 database.</li>
</ul>
<p><code>sql
-- SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables
-- Retrieving only 100 records for demonstration purposes
SELECT act.molregno, md.chembl_id, act.standard_type, act.standard_value, act.standard_units
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 0
LIMIT 100;</code></p>
<p><strong>3. Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing):</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng v√† t√≠nh nh·∫•t qu√°n. Lo·∫°i b·ªè c√°c gi√° tr·ªã thi·∫øu, x·ª≠ l√Ω c√°c gi√° tr·ªã ngo·∫°i l·ªá v√† chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu v·ªÅ ƒë·ªãnh d·∫°ng ph√π h·ª£p.</li>
<li><strong>English:</strong> Clean and normalize the data to ensure quality and consistency. Remove missing values, handle outliers, and convert data to the appropriate format.</li>
</ul>
<p>```python
import pandas as pd
import numpy as np</p>
<h1>Function to load data from a CSV file</h1>
<p>def load_data(file_path):
    try:
        data = pd.read_csv(file_path)
        print(f"Data loaded successfully from {file_path}")
        return data
    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
        return None</p>
<h1>Function to clean the data</h1>
<p>def clean_data(df):
    # Remove missing values
    df = df.dropna()
    # Remove duplicate rows
    df = df.drop_duplicates()
    # Convert 'standard_value' to numeric, handling errors
    df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')
    # Remove rows where 'standard_value' is NaN after conversion
    df = df.dropna(subset=['standard_value'])
    # Filter out non-positive values
    df = df[df['standard_value'] &gt; 0]
    print("Data cleaning complete.")
    return df</p>
<h1>Example usage:</h1>
<h1>Assuming base_path is defined and the CSV file is in the data directory</h1>
<p>base_path = '.'  # Replace with your actual base path
csv_file_path = os.path.join(base_path, 'data', 'your_data_file.csv')  # Replace with your actual file name
data = load_data(csv_file_path)</p>
<p>if data is not None:
    cleaned_data = clean_data(data)
    print(cleaned_data.head())
```</p>
<p><strong>4. T√≠nh to√°n ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ (Molecular Feature Calculation):</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc c·ªßa ph√¢n t·ª≠, nh∆∞ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠, ƒë·ªô tan, s·ªë l∆∞·ª£ng li√™n k·∫øt, v.v.</li>
<li><strong>English:</strong> Use RDKit to calculate molecular features such as molecular weight, solubility, number of bonds, etc.</li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<h1>Function to calculate molecular descriptors using RDKit</h1>
<p>def calculate_descriptors(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None  # Handle invalid SMILES strings</p>
<pre><code>    descriptors = {}
    descriptors['MolWt'] = Descriptors.MolWt(mol)
    descriptors['LogP'] = Descriptors.MolLogP(mol)
    descriptors['NumHAcceptors'] = Descriptors.NumHAcceptors(mol)
    descriptors['NumHDonors'] = Descriptors.NumHDonors(mol)
    return descriptors
except Exception as e:
    print(f"Error calculating descriptors for SMILES {smiles}: {e}")
    return None
</code></pre>
<h1>Example usage:</h1>
<h1>Assuming you have a DataFrame with a 'smiles' column</h1>
<p>def add_descriptors_to_df(df, smiles_column='smiles'):
    # Apply the descriptor calculation to each SMILES in the DataFrame
    df['descriptors'] = df[smiles_column].apply(calculate_descriptors)</p>
<pre><code># Expand the 'descriptors' column into separate columns
df = pd.concat([df, df['descriptors'].apply(pd.Series)], axis=1)

# Remove the original 'descriptors' column
df = df.drop(columns=['descriptors'])

return df
</code></pre>
<h1>Example of how to use this function (assuming 'cleaned_data' DataFrame is available)</h1>
<h1>Ensure that 'cleaned_data' DataFrame has a 'smiles' column</h1>
<h1>cleaned_data = add_descriptors_to_df(cleaned_data, smiles_column='smiles')</h1>
<h1>print(cleaned_data.head())</h1>
<p>```</p>
<p><strong>5. X√¢y d·ª±ng m√¥ h√¨nh h·ªçc m√°y (Machine Learning Model Building):</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng c√°c thu·∫≠t to√°n h·ªçc m√°y ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa ph√¢n t·ª≠.</li>
<li><strong>English:</strong> Use machine learning algorithms to build a model for predicting the biological activity of molecules.</li>
</ul>
<p>```python
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Function to train a machine learning model</h1>
<p>def train_model(df, features, target):
    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(df[features], df[target], test_size=0.2, random_state=42)</p>
<pre><code># Initialize the model
model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R^2 Score: {r2}")

return model, X_test, y_test, y_pred
</code></pre>
<h1>Example usage:</h1>
<h1>Assuming you have a DataFrame with calculated descriptors and activity values</h1>
<h1>Ensure that 'cleaned_data' DataFrame has the necessary columns for features and target</h1>
<h1>Define the features and target</h1>
<h1>features = ['MolWt', 'LogP', 'NumHAcceptors', 'NumHDonors']  # Replace with your feature columns</h1>
<h1>target = 'standard_value'  # Replace with your target column</h1>
<h1>Train the model</h1>
<h1>model, X_test, y_test, y_pred = train_model(cleaned_data, features, target)</h1>
<p>```</p>
<p><strong>S·ª≠a l·ªói:</strong></p>
<p><strong>a. ERROR: operator does not exist: numeric ~ unknown:</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> L·ªói n√†y x·∫£y ra do b·∫°n ƒëang c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ <code>~</code> (t∆∞∆°ng t·ª± nh∆∞ LIKE trong SQL) ƒë·ªÉ so s√°nh m·ªôt c·ªôt s·ªë (numeric) v·ªõi m·ªôt chu·ªói (unknown). ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c·∫ßn ƒë·∫£m b·∫£o r·∫±ng c·∫£ hai v·∫ø c·ªßa to√°n t·ª≠ <code>~</code> ƒë·ªÅu l√† chu·ªói, ho·∫∑c s·ª≠ d·ª•ng c√°c to√°n t·ª≠ so s√°nh s·ªë h·ªçc ph√π h·ª£p (v√≠ d·ª•: <code>=</code>, <code>&gt;</code>, <code>&lt;</code>). Trong tr∆∞·ªùng h·ª£p n√†y, b·∫°n c√≥ th·ªÉ lo·∫°i b·ªè ƒëi·ªÅu ki·ªán <code>act.standard_value ~ '^[0-9\.]+$'</code> v√¨ n√≥ kh√¥ng c·∫ßn thi·∫øt.</li>
<li><strong>English:</strong> This error occurs because you are trying to use the <code>~</code> operator (similar to LIKE in SQL) to compare a numeric column with a string. To fix this, ensure that both sides of the <code>~</code> operator are strings, or use appropriate numeric comparison operators (e.g., <code>=</code>, <code>&gt;</code>, <code>&lt;</code>). In this case, you can remove the condition <code>act.standard_value ~ '^[0-9\.]+$'</code> as it is not necessary.</li>
</ul>
<p><code>sql
-- Corrected SQL query
SELECT act.molregno, md.chembl_id, act.standard_type, act.standard_value, act.standard_units
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 0
LIMIT 100;</code></p>
<p><strong>b. Phi√™n b·∫£n scikit-learn c≈© kh√¥ng h·ªó tr·ª£ tham s·ªë squared=False trong h√†m mean_squared_error:</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, h√£y lo·∫°i b·ªè tham s·ªë <code>squared=False</code> kh·ªèi h√†m <code>mean_squared_error</code>. N·∫øu b·∫°n mu·ªën t√≠nh cƒÉn b·∫≠c hai c·ªßa MSE (RMSE), b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng h√†m <code>np.sqrt()</code> ƒë·ªÉ t√≠nh to√°n sau.</li>
<li><strong>English:</strong> If you are using an older version of scikit-learn, remove the <code>squared=False</code> parameter from the <code>mean_squared_error</code> function. If you want to calculate the square root of MSE (RMSE), you can use the <code>np.sqrt()</code> function to calculate it afterwards.</li>
</ul>
<p>```python
from sklearn.metrics import mean_squared_error
import numpy as np</p>
<h1>Calculate Mean Squared Error</h1>
<p>mse = mean_squared_error(y_test, y_pred)</p>
<h1>Calculate Root Mean Squared Error (RMSE)</h1>
<p>rmse = np.sqrt(mse)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
```</p>
<p><strong>5 V√≠ d·ª• code SQL v√† Python m·∫´u:</strong></p>
<p><strong>V√≠ d·ª• 1: L·ªçc c√°c ph√¢n t·ª≠ c√≥ ho·∫°t t√≠nh IC50 d∆∞·ªõi 100nM (Filtering molecules with IC50 activity below 100nM):</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
SELECT md.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value &lt;= 100
LIMIT 100;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import pandas as pd
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables</h1>
<p>sql_query = """
SELECT md.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value &lt;= 100
LIMIT 100;
"""</p>
<h1>Function to execute the SQL query and return the data as a DataFrame</h1>
<p>def execute_query(db_params, sql_query):
    try:
        # Establish a connection to the PostgreSQL database
        conn = psycopg2.connect(**db_params)</p>
<pre><code>    # Create a cursor object
    cur = conn.cursor()

    # Execute the SQL query
    cur.execute(sql_query)

    # Fetch all the results
    results = cur.fetchall()

    # Get column names from the cursor description
    column_names = [desc[0] for desc in cur.description]

    # Convert the results into a pandas DataFrame
    df = pd.DataFrame(results, columns=column_names)

    # Close the cursor and connection
    cur.close()
    conn.close()

    print("Query executed successfully!")
    return df
except psycopg2.Error as e:
    print(f"Error executing query: {e}")
    return None
</code></pre>
<h1>Execute the query and store the results in a DataFrame</h1>
<p>df = execute_query(db_params, sql_query)</p>
<h1>Print the DataFrame</h1>
<p>if df is not None:
    print(df.head())
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trung b√¨nh (Calculating average molecular weight):</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
SELECT AVG(md.molecular_weight) AS average_molecular_weight
FROM molecule_dictionary md
LIMIT 100;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import pandas as pd
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables</h1>
<p>sql_query = """
SELECT md.molecular_weight
FROM molecule_dictionary md
LIMIT 100;
"""</p>
<h1>Function to execute the SQL query and return the data as a DataFrame</h1>
<p>def execute_query(db_params, sql_query):
    try:
        # Establish a connection to the PostgreSQL database
        conn = psycopg2.connect(**db_params)</p>
<pre><code>    # Create a cursor object
    cur = conn.cursor()

    # Execute the SQL query
    cur.execute(sql_query)

    # Fetch all the results
    results = cur.fetchall()

    # Get column names from the cursor description
    column_names = [desc[0] for desc in cur.description]

    # Convert the results into a pandas DataFrame
    df = pd.DataFrame(results, columns=column_names)

    # Close the cursor and connection
    cur.close()
    conn.close()

    print("Query executed successfully!")
    return df
except psycopg2.Error as e:
    print(f"Error executing query: {e}")
    return None
</code></pre>
<h1>Execute the query and store the results in a DataFrame</h1>
<p>df = execute_query(db_params, sql_query)
if df is not None:
    average_molecular_weight = df['molecular_weight'].mean()
    print(f"Average Molecular Weight: {average_molecular_weight}")
```</p>
<p><strong>V√≠ d·ª• 3: T√¨m c√°c ph√¢n t·ª≠ c√≥ ch·ª©a v√≤ng benzen (Finding molecules containing a benzene ring):</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
-- This SQL query will not directly identify molecules with a benzene ring.
-- You would typically use substructure searching capabilities within ChEMBL's interface or RDKit.
-- This is a placeholder and might require a different approach using ChEMBL's API or RDKit integration.
SELECT md.chembl_id
FROM molecule_dictionary md
WHERE md.molecule_structures LIKE '%c1ccccc1%'  -- This is a simplistic approach and might not be accurate.
LIMIT 100;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import AllChem
import pandas as pd
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Function to execute the SQL query and return the data as a DataFrame</h1>
<p>def execute_query(db_params, sql_query):
    try:
        # Establish a connection to the PostgreSQL database
        conn = psycopg2.connect(**db_params)</p>
<pre><code>    # Create a cursor object
    cur = conn.cursor()

    # Execute the SQL query
    cur.execute(sql_query)

    # Fetch all the results
    results = cur.fetchall()

    # Get column names from the cursor description
    column_names = [desc[0] for desc in cur.description]

    # Convert the results into a pandas DataFrame
    df = pd.DataFrame(results, columns=column_names)

    # Close the cursor and connection
    cur.close()
    conn.close()

    print("Query executed successfully!")
    return df
except psycopg2.Error as e:
    print(f"Error executing query: {e}")
    return None
</code></pre>
<h1>SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables</h1>
<p>sql_query = """
SELECT md.chembl_id, md.molecule_structures
FROM molecule_dictionary md
LIMIT 100;
"""</p>
<h1>Define the SMILES pattern for a benzene ring</h1>
<p>benzene_smiles = 'c1ccccc1'
benzene_mol = Chem.MolFromSmiles(benzene_smiles)</p>
<h1>Function to check if a molecule contains a benzene ring</h1>
<p>def contains_benzene(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return False
    return mol.HasSubstructMatch(benzene_mol)</p>
<h1>Execute the query and store the results in a DataFrame</h1>
<p>df = execute_query(db_params, sql_query)</p>
<h1>Apply the function to check for benzene ring</h1>
<p>if df is not None:
    df['has_benzene'] = df['molecule_structures'].apply(contains_benzene)</p>
<pre><code># Filter the DataFrame to only include molecules with a benzene ring
benzene_molecules = df[df['has_benzene']]

# Print the DataFrame
print(benzene_molecules.head())
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 4: Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa LogP v√† ho·∫°t t√≠nh (Analyzing the correlation between LogP and activity):</strong></p>
<ul>
<li>
<p><strong>SQL:</strong> (Kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp trong SQL, c·∫ßn k·∫øt h·ª£p v·ªõi Python)</p>
</li>
<li>
<p><strong>Python:</strong></p>
</li>
</ul>
<p>```python
import pandas as pd
import psycopg2
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables</h1>
<p>sql_query = """
SELECT md.chembl_id, md.molecule_structures, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 0
LIMIT 100;
"""</p>
<h1>Function to execute the SQL query and return the data as a DataFrame</h1>
<p>def execute_query(db_params, sql_query):
    try:
        # Establish a connection to the PostgreSQL database
        conn = psycopg2.connect(**db_params)</p>
<pre><code>    # Create a cursor object
    cur = conn.cursor()

    # Execute the SQL query
    cur.execute(sql_query)

    # Fetch all the results
    results = cur.fetchall()

    # Get column names from the cursor description
    column_names = [desc[0] for desc in cur.description]

    # Convert the results into a pandas DataFrame
    df = pd.DataFrame(results, columns=column_names)

    # Close the cursor and connection
    cur.close()
    conn.close()

    print("Query executed successfully!")
    return df
except psycopg2.Error as e:
    print(f"Error executing query: {e}")
    return None
</code></pre>
<h1>Function to calculate LogP using RDKit</h1>
<p>def calculate_logp(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        return Descriptors.MolLogP(mol)
    except:
        return None</p>
<h1>Execute the query and store the results in a DataFrame</h1>
<p>df = execute_query(db_params, sql_query)</p>
<h1>Calculate LogP for each molecule</h1>
<p>if df is not None:
    df['logp'] = df['molecule_structures'].apply(calculate_logp)
    df = df.dropna(subset=['logp', 'standard_value'])</p>
<pre><code># Calculate the correlation between LogP and activity
correlation = df['logp'].corr(df['standard_value'])
print(f"Correlation between LogP and IC50: {correlation}")
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 5: T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n gi·ªØa tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ v√† LogP (Creating a scatter plot between molecular weight and LogP):</strong></p>
<ul>
<li>
<p><strong>SQL:</strong> (Kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp trong SQL, c·∫ßn k·∫øt h·ª£p v·ªõi Python)</p>
</li>
<li>
<p><strong>Python:</strong></p>
</li>
</ul>
<p>```python
import pandas as pd
import psycopg2
from rdkit import Chem
from rdkit.Chem import Descriptors
import matplotlib.pyplot as plt</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>SQL query to retrieve data from the 'activities' and 'molecule_dictionary' tables</h1>
<p>sql_query = """
SELECT md.chembl_id, md.molecule_structures
FROM molecule_dictionary md
LIMIT 100;
"""</p>
<h1>Function to execute the SQL query and return the data as a DataFrame</h1>
<p>def execute_query(db_params, sql_query):
    try:
        # Establish a connection to the PostgreSQL database
        conn = psycopg2.connect(**db_params)</p>
<pre><code>    # Create a cursor object
    cur = conn.cursor()

    # Execute the SQL query
    cur.execute(sql_query)

    # Fetch all the results
    results = cur.fetchall()

    # Get column names from the cursor description
    column_names = [desc[0] for desc in cur.description]

    # Convert the results into a pandas DataFrame
    df = pd.DataFrame(results, columns=column_names)

    # Close the cursor and connection
    cur.close()
    conn.close()

    print("Query executed successfully!")
    return df
except psycopg2.Error as e:
    print(f"Error executing query: {e}")
    return None
</code></pre>
<h1>Function to calculate molecular weight and LogP using RDKit</h1>
<p>def calculate_mw_logp(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None, None
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        return mw, logp
    except:
        return None, None</p>
<h1>Execute the query and store the results in a DataFrame</h1>
<p>df = execute_query(db_params, sql_query)</p>
<h1>Calculate molecular weight and LogP for each molecule</h1>
<p>if df is not None:
    df['mw'], df['logp'] = zip(*df['molecule_structures'].apply(calculate_mw_logp))
    df = df.dropna(subset=['mw', 'logp'])</p>
<pre><code># Create a scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(df['mw'], df['logp'], alpha=0.5)
plt.xlabel('Molecular Weight')
plt.ylabel('LogP')
plt.title('Scatter Plot of Molecular Weight vs LogP')
plt.grid(True)
plt.show()
</code></pre>
<p>```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li><strong>SMILES Strings:</strong> ƒê·∫£m b·∫£o r·∫±ng c·ªôt <code>molecule_structures</code> ch·ª©a chu·ªói SMILES h·ª£p l·ªá.</li>
<li><strong>Error Handling:</strong> X·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh t√≠nh to√°n ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠.</li>
<li><strong>Data Scaling:</strong> C√¢n nh·∫Øc vi·ªác chu·∫©n h√≥a ho·∫∑c –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ d·ªØ li·ªáu tr∆∞·ªõc khi x√¢y d·ª±ng m√¥ h√¨nh h·ªçc m√°y.</li>
<li><strong>Feature Selection:</strong> L·ª±a ch·ªçn c√°c ƒë·∫∑c tr∆∞ng quan tr·ªçng nh·∫•t ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh.</li>
<li><strong>Model Evaluation:</strong> ƒê√°nh gi√° m√¥ h√¨nh b·∫±ng c√°c m√©t ƒëo ph√π h·ª£p (v√≠ d·ª•: MSE, RMSE, R^2).</li>
</ul>
<p>T√¥i hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n tri·ªÉn khai d·ª± √°n c·ªßa m√¨nh m·ªôt c√°ch hi·ªáu qu·∫£. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi!</p>
        </body>
        </html>
        