
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_30</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: So s√°nh v·ªã tr√≠ g·∫Øn ligand gi·ªØa c√°c target</h1>
<hr />
<p>Tuy·ªát v·ªùi! V·ªõi vai tr√≤ l√† chuy√™n gia R&amp;D d∆∞·ª£c h·ªçc, t√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 k·∫øt h·ª£p RDKit. D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, ch√∫ng ta s·∫Ω c√πng nhau x√¢y d·ª±ng quy tr√¨nh l√†m vi·ªác hi·ªáu qu·∫£ v√† gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ ph√°t sinh.</p>
<p><strong>T·ªïng quan d·ª± √°n:</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> Ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc.</li>
<li><strong>D·ªØ li·ªáu:</strong> ChEMBL 35 (c∆° s·ªü d·ªØ li·ªáu l·ªõn ch·ª©a th√¥ng tin v·ªÅ c√°c ph√¢n t·ª≠ v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng).</li>
<li><strong>C√¥ng c·ª•:</strong><ul>
<li>PostgreSQL (psql) v·ªõi c∆° s·ªü d·ªØ li·ªáu <code>chembl_35</code> (IP: 192.168.206.136, user: rd, pass: rd)</li>
<li>RDKit (toolkit h√≥a h·ªçc tin h·ªçc)</li>
<li>Jupyter Notebook</li>
<li>Scikit-learn</li>
</ul>
</li>
<li><strong>Quy tr√¨nh:</strong><ol>
<li>Truy v·∫•n d·ªØ li·ªáu t·ª´ PostgreSQL, l∆∞u d∆∞·ªõi d·∫°ng file CSV.</li>
<li>S·ª≠ d·ª•ng Jupyter Notebook ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu v·ªõi RDKit v√† Scikit-learn.</li>
</ol>
</li>
<li><strong>C·∫•u tr√∫c th∆∞ m·ª•c:</strong> Tu√¢n theo chu·∫©n AIMLOps Template.</li>
<li><strong>Y√™u c·∫ßu:</strong><ul>
<li>Code SQL v√† Python (ti·∫øng Anh).</li>
<li>Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng b·∫£n ghi: 100 d√≤ng.</li>
<li>X·ª≠ l√Ω l·ªói:<ul>
<li><code>ERROR: operator does not exist: numeric ~ unknown</code></li>
<li><code>squared=False</code> kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ trong <code>mean_squared_error</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>M√£ ch·ªß ƒë·ªÅ:</strong> Topic_CheMBL_35_30</li>
</ul>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch</strong></p>
<p>D·ª±a tr√™n m√£ ch·ªß ƒë·ªÅ "Topic_CheMBL_35_30", t√¥i gi·∫£ ƒë·ªãnh r·∫±ng ch·ªß ƒë·ªÅ n√†y li√™n quan ƒë·∫øn vi·ªác ph√¢n t√≠ch m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c ph√¢n t·ª≠. M·ªôt s·ªë m√¥ h√¨nh ph√¢n t√≠ch ph√π h·ª£p c√≥ th·ªÉ bao g·ªìm:</p>
<ul>
<li><strong>SAR/QSAR (Structure-Activity Relationship/Quantitative Structure-Activity Relationship):</strong> M√¥ h√¨nh n√†y c·ªë g·∫Øng thi·∫øt l·∫≠p m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc c·ªßa m·ªôt ph√¢n t·ª≠ v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa n√≥. Ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c descriptor (thu·ªôc t√≠nh) h√≥a h·ªçc t√≠nh to√°n t·ª´ RDKit ƒë·ªÉ bi·ªÉu di·ªÖn c·∫•u tr√∫c v√† c√°c thu·∫≠t to√°n h·ªçc m√°y (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, SVM, Random Forest) ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh.</li>
<li><strong>Classification:</strong> N·∫øu ho·∫°t t√≠nh sinh h·ªçc ƒë∆∞·ª£c bi·ªÉu di·ªÖn d∆∞·ªõi d·∫°ng c√°c l·ªõp (v√≠ d·ª•: active/inactive), ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c thu·∫≠t to√°n ph√¢n lo·∫°i (v√≠ d·ª•: Logistic Regression, Naive Bayes, SVM) ƒë·ªÉ d·ª± ƒëo√°n l·ªõp ho·∫°t t√≠nh d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc.</li>
<li><strong>Clustering:</strong> S·ª≠ d·ª•ng c√°c thu·∫≠t to√°n clustering (v√≠ d·ª•: k-means, hierarchical clustering) ƒë·ªÉ nh√≥m c√°c ph√¢n t·ª≠ c√≥ c·∫•u tr√∫c v√† ho·∫°t t√≠nh t∆∞∆°ng t·ª± l·∫°i v·ªõi nhau. ƒêi·ªÅu n√†y c√≥ th·ªÉ gi√∫p ch√∫ng ta x√°c ƒë·ªãnh c√°c scaffold (khung) quan tr·ªçng cho ho·∫°t t√≠nh.</li>
</ul>
<p><strong>Analysis Model</strong></p>
<p>Based on the topic code "Topic_CheMBL_35_30," I assume that this topic relates to analyzing the relationship between the chemical structure and biological activity of molecules. Suitable analysis models may include:</p>
<ul>
<li><strong>SAR/QSAR (Structure-Activity Relationship/Quantitative Structure-Activity Relationship):</strong> This model attempts to establish a relationship between the chemical structure of a molecule and its biological activity. We can use chemical descriptors calculated from RDKit to represent the structure and machine learning algorithms (e.g., linear regression, SVM, Random Forest) to build a model to predict activity.</li>
<li><strong>Classification:</strong> If biological activity is represented as classes (e.g., active/inactive), we can use classification algorithms (e.g., Logistic Regression, Naive Bayes, SVM) to predict the activity class based on the chemical structure.</li>
<li><strong>Clustering:</strong> Use clustering algorithms (e.g., k-means, hierarchical clustering) to group molecules with similar structures and activities together. This can help us identify important scaffolds for activity.</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ v√† code m·∫´u</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n song ng·ªØ v√† c√°c v√≠ d·ª• code SQL v√† Python ƒë·ªÉ b·∫°n b·∫Øt ƒë·∫ßu.</p>
<p><strong>V√≠ d·ª• 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu v√† t√≠nh to√°n descriptor</strong></p>
<p><strong>SQL (l·∫•y 100 d√≤ng):</strong></p>
<p>```sql
-- English
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units,
    act.standard_type
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
LIMIT 100;</p>
<p>-- Vietnamese
-- L·∫•y th√¥ng tin v·ªÅ c√°c ph√¢n t·ª≠, c·∫•u tr√∫c SMILES, gi√° tr·ªã IC50 t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL
-- Gi·ªõi h·∫°n k·∫øt qu·∫£ tr·∫£ v·ªÅ 100 d√≤ng
SELECT
    md.molregno, -- M√£ ƒë·ªãnh danh ph√¢n t·ª≠
    cs.canonical_smiles, -- C·∫•u tr√∫c SMILES
    act.standard_value, -- Gi√° tr·ªã IC50
    act.standard_units, -- ƒê∆°n v·ªã c·ªßa gi√° tr·ªã IC50
    act.standard_type -- Lo·∫°i ho·∫°t t√≠nh (v√≠ d·ª•: IC50)
FROM
    molecule_dictionary md -- B·∫£ng th√¥ng tin ph√¢n t·ª≠
JOIN
    compound_structures cs ON md.molregno = cs.molregno -- B·∫£ng c·∫•u tr√∫c ph√¢n t·ª≠
JOIN
    activities act ON md.molregno = act.molregno -- B·∫£ng th√¥ng tin ho·∫°t t√≠nh
WHERE act.standard_type = 'IC50' -- L·ªçc theo lo·∫°i ho·∫°t t√≠nh IC50
  AND act.standard_units = 'nM' -- L·ªçc theo ƒë∆°n v·ªã nM
  AND act.standard_value IS NOT NULL -- L·ªçc c√°c gi√° tr·ªã IC50 kh√¥ng r·ªóng
LIMIT 100; -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ l√† 100
```</p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<h1>Database credentials</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>Define base path (replace with your actual base path)</h1>
<p>base_path = '.' # Assuming the notebook is in the root of your project</p>
<h1>CSV file path</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>Read the CSV file</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>Function to calculate molecular weight</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>Apply the function to the 'canonical_smiles' column</h1>
<p>df['mol_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>Print the first 5 rows with molecular weight</h1>
<p>print(df.head())</p>
<h1>Vietnamese</h1>
<p>import os  # Import th∆∞ vi·ªán os ƒë·ªÉ l√†m vi·ªác v·ªõi ƒë∆∞·ªùng d·∫´n file
import pandas as pd  # Import th∆∞ vi·ªán pandas ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Import th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # Import c√°c descriptor (thu·ªôc t√≠nh) h√≥a h·ªçc t·ª´ RDKit</p>
<h1>Th√¥ng tin ƒëƒÉng nh·∫≠p c∆° s·ªü d·ªØ li·ªáu</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n (thay th·∫ø b·∫±ng ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø c·ªßa b·∫°n)</h1>
<p>base_path = '.' # Gi·∫£ s·ª≠ notebook n·∫±m ·ªü th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n</p>
<h1>ƒê∆∞·ªùng d·∫´n ƒë·∫øn file CSV</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>ƒê·ªçc file CSV v√†o DataFrame</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>H√†m t√≠nh to√°n kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol:
        return Descriptors.MolWt(mol)  # T√≠nh to√°n kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠
    else:
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi SMILES</p>
<h1>√Åp d·ª•ng h√†m t√≠nh to√°n kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ cho c·ªôt 'canonical_smiles'</h1>
<p>df['mol_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>In 5 d√≤ng ƒë·∫ßu ti√™n c·ªßa DataFrame, bao g·ªìm c·∫£ kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>print(df.head())
```</p>
<p><strong>V√≠ d·ª• 2: X·ª≠ l√Ω l·ªói <code>operator does not exist: numeric ~ unknown</code></strong></p>
<p>L·ªói n√†y x·∫£y ra khi b·∫°n c·ªë g·∫Øng so s√°nh m·ªôt ki·ªÉu d·ªØ li·ªáu s·ªë (numeric) v·ªõi m·ªôt ki·ªÉu d·ªØ li·ªáu chu·ªói (unknown). Trong tr∆∞·ªùng h·ª£p n√†y, c·ªôt <code>act.standard_value</code> c√≥ th·ªÉ ch·ª©a d·ªØ li·ªáu kh√¥ng ph·∫£i s·ªë. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng h√†m <code>regexp_match</code> ƒë·ªÉ ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë hay kh√¥ng tr∆∞·ªõc khi so s√°nh.</p>
<p><strong>SQL:</strong></p>
<p>```sql
-- English
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value::text ~ '^[0-9.]+$' -- Check if the value is numeric
LIMIT 100;</p>
<p>-- Vietnamese
-- L·∫•y th√¥ng tin v·ªÅ c√°c ph√¢n t·ª≠, c·∫•u tr√∫c SMILES, gi√° tr·ªã IC50 t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL
-- Ch·ªâ l·∫•y c√°c gi√° tr·ªã IC50 l√† s·ªë
SELECT
    md.molregno, -- M√£ ƒë·ªãnh danh ph√¢n t·ª≠
    cs.canonical_smiles, -- C·∫•u tr√∫c SMILES
    act.standard_value, -- Gi√° tr·ªã IC50
    act.standard_units -- ƒê∆°n v·ªã c·ªßa gi√° tr·ªã IC50
FROM
    molecule_dictionary md -- B·∫£ng th√¥ng tin ph√¢n t·ª≠
JOIN
    compound_structures cs ON md.molregno = cs.molregno -- B·∫£ng c·∫•u tr√∫c ph√¢n t·ª≠
JOIN
    activities act ON md.molregno = act.molregno -- B·∫£ng th√¥ng tin ho·∫°t t√≠nh
WHERE act.standard_type = 'IC50' -- L·ªçc theo lo·∫°i ho·∫°t t√≠nh IC50
  AND act.standard_units = 'nM' -- L·ªçc theo ƒë∆°n v·ªã nM
  AND act.standard_value IS NOT NULL -- L·ªçc c√°c gi√° tr·ªã IC50 kh√¥ng r·ªóng
  AND act.standard_value::text ~ '^[0-9.]+$' -- Ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë hay kh√¥ng
LIMIT 100; -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ l√† 100
```</p>
<p><strong>V√≠ d·ª• 3: T√≠nh to√°n LogP v√† lo·∫°i b·ªè c√°c ph√¢n t·ª≠ kh√¥ng h·ª£p l·ªá</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<h1>Database credentials</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>Define base path (replace with your actual base path)</h1>
<p>base_path = '.' # Assuming the notebook is in the root of your project</p>
<h1>CSV file path</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>Read the CSV file</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>Function to calculate LogP</h1>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolLogP(mol)
    else:
        return None</p>
<h1>Apply the function to the 'canonical_smiles' column</h1>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)</p>
<h1>Remove rows where LogP is None (invalid molecules)</h1>
<p>df = df.dropna(subset=['logp'])</p>
<h1>Print the first 5 rows with LogP</h1>
<p>print(df.head())</p>
<h1>Vietnamese</h1>
<p>import os  # Import th∆∞ vi·ªán os ƒë·ªÉ l√†m vi·ªác v·ªõi ƒë∆∞·ªùng d·∫´n file
import pandas as pd  # Import th∆∞ vi·ªán pandas ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Import th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # Import c√°c descriptor (thu·ªôc t√≠nh) h√≥a h·ªçc t·ª´ RDKit</p>
<h1>Th√¥ng tin ƒëƒÉng nh·∫≠p c∆° s·ªü d·ªØ li·ªáu</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n (thay th·∫ø b·∫±ng ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø c·ªßa b·∫°n)</h1>
<p>base_path = '.' # Gi·∫£ s·ª≠ notebook n·∫±m ·ªü th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n</p>
<h1>ƒê∆∞·ªùng d·∫´n ƒë·∫øn file CSV</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>ƒê·ªçc file CSV v√†o DataFrame</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>H√†m t√≠nh to√°n LogP</h1>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol:
        return Descriptors.MolLogP(mol)  # T√≠nh to√°n LogP
    else:
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi SMILES</p>
<h1>√Åp d·ª•ng h√†m t√≠nh to√°n LogP cho c·ªôt 'canonical_smiles'</h1>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã LogP l√† None (c√°c ph√¢n t·ª≠ kh√¥ng h·ª£p l·ªá)</h1>
<p>df = df.dropna(subset=['logp'])</p>
<h1>In 5 d√≤ng ƒë·∫ßu ti√™n c·ªßa DataFrame, bao g·ªìm c·∫£ LogP</h1>
<p>print(df.head())
```</p>
<p><strong>V√≠ d·ª• 4: Chu·∫©n b·ªã d·ªØ li·ªáu cho m√¥ h√¨nh QSAR</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np</p>
<h1>Database credentials</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>Define base path (replace with your actual base path)</h1>
<p>base_path = '.' # Assuming the notebook is in the root of your project</p>
<h1>CSV file path</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>Read the CSV file</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>Function to calculate molecular descriptors</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return [Descriptors.MolWt(mol), Descriptors.MolLogP(mol)]  # Example descriptors
    else:
        return None</p>
<h1>Apply the function to the 'canonical_smiles' column</h1>
<p>df['descriptors'] = df['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Remove rows where descriptors is None (invalid molecules)</h1>
<p>df = df.dropna(subset=['descriptors'])</p>
<h1>Convert descriptors to separate columns</h1>
<p>df[['mol_weight', 'logp']] = pd.DataFrame(df['descriptors'].tolist(), index=df.index)</p>
<h1>Convert IC50 to pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to M</p>
<h1>Print the first 5 rows with descriptors and pIC50</h1>
<p>print(df.head())</p>
<h1>Vietnamese</h1>
<p>import os  # Import th∆∞ vi·ªán os ƒë·ªÉ l√†m vi·ªác v·ªõi ƒë∆∞·ªùng d·∫´n file
import pandas as pd  # Import th∆∞ vi·ªán pandas ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Import th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # Import c√°c descriptor (thu·ªôc t√≠nh) h√≥a h·ªçc t·ª´ RDKit
import numpy as np # Import th∆∞ vi·ªán numpy ƒë·ªÉ t√≠nh to√°n s·ªë h·ªçc</p>
<h1>Th√¥ng tin ƒëƒÉng nh·∫≠p c∆° s·ªü d·ªØ li·ªáu</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n (thay th·∫ø b·∫±ng ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø c·ªßa b·∫°n)</h1>
<p>base_path = '.' # Gi·∫£ s·ª≠ notebook n·∫±m ·ªü th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n</p>
<h1>ƒê∆∞·ªùng d·∫´n ƒë·∫øn file CSV</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>ƒê·ªçc file CSV v√†o DataFrame</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol:
        return [Descriptors.MolWt(mol), Descriptors.MolLogP(mol)]  # V√≠ d·ª•: Kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ v√† LogP
    else:
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi SMILES</p>
<h1>√Åp d·ª•ng h√†m t√≠nh to√°n descriptor cho c·ªôt 'canonical_smiles'</h1>
<p>df['descriptors'] = df['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã descriptor l√† None (c√°c ph√¢n t·ª≠ kh√¥ng h·ª£p l·ªá)</h1>
<p>df = df.dropna(subset=['descriptors'])</p>
<h1>Chuy·ªÉn ƒë·ªïi c√°c descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát</h1>
<p>df[['mol_weight', 'logp']] = pd.DataFrame(df['descriptors'].tolist(), index=df.index)</p>
<h1>Chuy·ªÉn ƒë·ªïi IC50 th√†nh pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM th√†nh M</p>
<h1>In 5 d√≤ng ƒë·∫ßu ti√™n c·ªßa DataFrame, bao g·ªìm c√°c descriptor v√† pIC50</h1>
<p>print(df.head())
```</p>
<p><strong>V√≠ d·ª• 5: X√¢y d·ª±ng m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh ƒë∆°n gi·∫£n</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error</p>
<h1>Database credentials</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>Define base path (replace with your actual base path)</h1>
<p>base_path = '.' # Assuming the notebook is in the root of your project</p>
<h1>CSV file path</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>Read the CSV file</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>Function to calculate molecular descriptors</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return [Descriptors.MolWt(mol), Descriptors.MolLogP(mol)]  # Example descriptors
    else:
        return None</p>
<h1>Apply the function to the 'canonical_smiles' column</h1>
<p>df['descriptors'] = df['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Remove rows where descriptors is None (invalid molecules)</h1>
<p>df = df.dropna(subset=['descriptors'])</p>
<h1>Convert descriptors to separate columns</h1>
<p>df[['mol_weight', 'logp']] = pd.DataFrame(df['descriptors'].tolist(), index=df.index)</p>
<h1>Convert IC50 to pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to M</p>
<h1>Prepare data for modeling</h1>
<p>X = df[['mol_weight', 'logp']]
y = df['pIC50']</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Create and train the model</h1>
<p>model = LinearRegression()
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")</p>
<h1>Vietnamese</h1>
<p>import os  # Import th∆∞ vi·ªán os ƒë·ªÉ l√†m vi·ªác v·ªõi ƒë∆∞·ªùng d·∫´n file
import pandas as pd  # Import th∆∞ vi·ªán pandas ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Import th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # Import c√°c descriptor (thu·ªôc t√≠nh) h√≥a h·ªçc t·ª´ RDKit
import numpy as np # Import th∆∞ vi·ªán numpy ƒë·ªÉ t√≠nh to√°n s·ªë h·ªçc
from sklearn.model_selection import train_test_split  # Import h√†m chia d·ªØ li·ªáu
from sklearn.linear_model import LinearRegression  # Import m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh
from sklearn.metrics import mean_squared_error  # Import h√†m ƒë√°nh gi√° m√¥ h√¨nh</p>
<h1>Th√¥ng tin ƒëƒÉng nh·∫≠p c∆° s·ªü d·ªØ li·ªáu</h1>
<p>db_ip = '192.168.206.136'
db_user = 'rd'
db_pass = 'rd'
db_name = 'chembl_35'</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n (thay th·∫ø b·∫±ng ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø c·ªßa b·∫°n)</h1>
<p>base_path = '.' # Gi·∫£ s·ª≠ notebook n·∫±m ·ªü th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n</p>
<h1>ƒê∆∞·ªùng d·∫´n ƒë·∫øn file CSV</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_ic50_100.csv')</p>
<h1>ƒê·ªçc file CSV v√†o DataFrame</h1>
<p>df = pd.read_csv(csv_file_path)</p>
<h1>H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol:
        return [Descriptors.MolWt(mol), Descriptors.MolLogP(mol)]  # V√≠ d·ª•: Kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ v√† LogP
    else:
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th·ªÉ chuy·ªÉn ƒë·ªïi SMILES</p>
<h1>√Åp d·ª•ng h√†m t√≠nh to√°n descriptor cho c·ªôt 'canonical_smiles'</h1>
<p>df['descriptors'] = df['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã descriptor l√† None (c√°c ph√¢n t·ª≠ kh√¥ng h·ª£p l·ªá)</h1>
<p>df = df.dropna(subset=['descriptors'])</p>
<h1>Chuy·ªÉn ƒë·ªïi c√°c descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát</h1>
<p>df[['mol_weight', 'logp']] = pd.DataFrame(df['descriptors'].tolist(), index=df.index)</p>
<h1>Chuy·ªÉn ƒë·ªïi IC50 th√†nh pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM th√†nh M</p>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu cho m√¥ h√¨nh</h1>
<p>X = df[['mol_weight', 'logp']]  # C√°c descriptor l√†m bi·∫øn ƒë·ªôc l·∫≠p
y = df['pIC50']  # pIC50 l√†m bi·∫øn ph·ª• thu·ªôc</p>
<h1>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>T·∫°o v√† hu·∫•n luy·ªán m√¥ h√¨nh</h1>
<p>model = LinearRegression()  # Kh·ªüi t·∫°o m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh
model.fit(X_train, y_train)  # Hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p hu·∫•n luy·ªán</p>
<h1>D·ª± ƒëo√°n gi√° tr·ªã</h1>
<p>y_pred = model.predict(X_test)  # D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>mse = mean_squared_error(y_test, y_pred)  # T√≠nh Mean Squared Error
print(f"Mean Squared Error: {mse}")  # In k·∫øt qu·∫£
```</p>
<p><strong>X·ª≠ l√Ω l·ªói <code>squared=False</code> trong <code>mean_squared_error</code>:</strong></p>
<p>N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, tham s·ªë <code>squared=False</code> c√≥ th·ªÉ kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Trong tr∆∞·ªùng h·ª£p n√†y, b·∫°n c√≥ th·ªÉ t√≠nh cƒÉn b·∫≠c hai c·ªßa MSE ƒë·ªÉ c√≥ ƒë∆∞·ª£c RMSE (Root Mean Squared Error):</p>
<p>```python</p>
<h1>English</h1>
<p>mse = mean_squared_error(y_test, y_pred)
rmse = mse**0.5
print(f"Root Mean Squared Error: {rmse}")</p>
<h1>Vietnamese</h1>
<p>mse = mean_squared_error(y_test, y_pred)  # T√≠nh Mean Squared Error
rmse = mse**0.5  # T√≠nh Root Mean Squared Error b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE
print(f"Root Mean Squared Error: {rmse}")  # In k·∫øt qu·∫£
```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li>H√£y nh·ªõ thay th·∫ø c√°c ƒë∆∞·ªùng d·∫´n file v√† th√¥ng tin ƒëƒÉng nh·∫≠p c∆° s·ªü d·ªØ li·ªáu b·∫±ng th√¥ng tin th·ª±c t·∫ø c·ªßa b·∫°n.</li>
<li>C√°c v√≠ d·ª• tr√™n ch·ªâ l√† ƒëi·ªÉm kh·ªüi ƒë·∫ßu. B·∫°n c√≥ th·ªÉ t√πy ch·ªânh v√† m·ªü r·ªông ch√∫ng ƒë·ªÉ ph√π h·ª£p v·ªõi nhu c·∫ßu c·ª• th·ªÉ c·ªßa d·ª± √°n.</li>
<li>Vi·ªác l·ª±a ch·ªçn descriptor v√† thu·∫≠t to√°n h·ªçc m√°y ph√π h·ª£p l√† r·∫•t quan tr·ªçng ƒë·ªÉ x√¢y d·ª±ng c√°c m√¥ h√¨nh QSAR/SAR hi·ªáu qu·∫£. H√£y th·ª≠ nghi·ªám v·ªõi c√°c l·ª±a ch·ªçn kh√°c nhau v√† ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa ch√∫ng m·ªôt c√°ch c·∫©n th·∫≠n.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        