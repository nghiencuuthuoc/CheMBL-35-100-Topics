
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_5</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Ph√¢n t√≠ch t√≠nh gi·ªëng thu·ªëc b·∫±ng RDKit</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&amp;D D∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n h∆∞·ªõng d·∫´n chi ti·∫øt, code m·∫´u v√† gi·∫£i th√≠ch ƒë·ªÉ b·∫°n c√≥ th·ªÉ tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.</p>
<p><strong>T·ªïng quan d·ª± √°n:</strong></p>
<p>D·ª± √°n n√†y t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, k·∫øt h·ª£p v·ªõi c√°c c√¥ng c·ª• tin sinh h·ªçc nh∆∞ RDKit, ƒë·ªÉ h·ªó tr·ª£ qu√° tr√¨nh nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. B·∫°n s·∫Ω s·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n v√† tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ ChEMBL, sau ƒë√≥ s·ª≠ d·ª•ng Python (v·ªõi RDKit v√† c√°c th∆∞ vi·ªán li√™n quan) ƒë·ªÉ ph√¢n t√≠ch v√† m√¥ h√¨nh h√≥a d·ªØ li·ªáu.</p>
<p><strong>C·∫•u tr√∫c th∆∞ m·ª•c d·ª± √°n (tu√¢n theo AIMLOps Template):</strong></p>
<p><code>‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ *.csv  # D·ªØ li·ªáu tr√≠ch xu·∫•t t·ª´ SQL
‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îî‚îÄ‚îÄ Topic_CheMBL_35_5_1_*.ipynb
‚îÇ   ‚îî‚îÄ‚îÄ Topic_CheMBL_35_5_2_*.ipynb
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ # (Optional) C√°c module Python t√πy ch·ªânh
‚îî‚îÄ‚îÄ README.md</code></p>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch (Analysis Model):</strong></p>
<p>Ch·ªß ƒë·ªÅ <code>Topic_CheMBL_35_5</code> c√≥ th·ªÉ t·∫≠p trung v√†o nhi·ªÅu kh√≠a c·∫°nh kh√°c nhau c·ªßa qu√° tr√¨nh ph√°t tri·ªÉn thu·ªëc. D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë m√¥ h√¨nh ph√¢n t√≠ch ti·ªÅm nƒÉng, c√πng v·ªõi h∆∞·ªõng d·∫´n v√† code m·∫´u:</p>
<ul>
<li><strong>M√¥ h√¨nh 1: Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc v√† ho·∫°t t√≠nh sinh h·ªçc (SAR/QSAR):</strong><ul>
<li><strong>M·ª•c ti√™u:</strong> X√°c ƒë·ªãnh c√°c nh√≥m ch·ª©c ho·∫∑c ƒë·∫∑c ƒëi·ªÉm c·∫•u tr√∫c n√†o ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh c·ªßa m·ªôt h·ª£p ch·∫•t ƒë·ªëi v·ªõi m·ªôt m·ª•c ti√™u sinh h·ªçc c·ª• th·ªÉ.</li>
<li><strong>Ph∆∞∆°ng ph√°p:</strong><ol>
<li><strong>Tr√≠ch xu·∫•t d·ªØ li·ªáu:</strong> L·∫•y d·ªØ li·ªáu v·ªÅ c·∫•u tr√∫c h√≥a h·ªçc (SMILES) v√† ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: IC50, Ki) c·ªßa c√°c h·ª£p ch·∫•t t·ª´ ChEMBL.</li>
<li><strong>T√≠nh to√°n descriptor:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ (v√≠ d·ª•: tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠, logP, s·ªë l∆∞·ª£ng li√™n k·∫øt hydro, di·ªán t√≠ch b·ªÅ m·∫∑t ph√¢n c·ª±c).</li>
<li><strong>Ph√¢n t√≠ch t∆∞∆°ng quan:</strong> S·ª≠ d·ª•ng c√°c ph∆∞∆°ng ph√°p th·ªëng k√™ (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, random forest) ƒë·ªÉ t√¨m m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
</ol>
</li>
<li><strong>·ª®ng d·ª•ng:</strong> D·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t m·ªõi, t·ªëi ∆∞u h√≥a c·∫•u tr√∫c h·ª£p ch·∫•t ƒë·ªÉ c·∫£i thi·ªán ho·∫°t t√≠nh.</li>
</ul>
</li>
<li><strong>M√¥ h√¨nh 2: Ph√¢n t√≠ch ƒëa d·∫°ng h√≥a h·ªçc (Chemical Diversity Analysis):</strong><ul>
<li><strong>M·ª•c ti√™u:</strong> ƒê√°nh gi√° s·ª± ƒëa d·∫°ng c·ªßa m·ªôt t·∫≠p h·ª£p c√°c h·ª£p ch·∫•t, x√°c ƒë·ªãnh c√°c h·ª£p ch·∫•t ƒë·∫°i di·ªán cho c√°c v√πng kh√°c nhau trong kh√¥ng gian h√≥a h·ªçc.</li>
<li><strong>Ph∆∞∆°ng ph√°p:</strong><ol>
<li><strong>T√≠nh to√°n fingerprint:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t·∫°o fingerprint cho c√°c h·ª£p ch·∫•t (v√≠ d·ª•: Morgan fingerprint, MACCS keys).</li>
<li><strong>Ph√¢n t√≠ch th√†nh ph·∫ßn ch√≠nh (PCA) ho·∫∑c t-SNE:</strong> Gi·∫£m chi·ªÅu d·ªØ li·ªáu fingerprint ƒë·ªÉ tr·ª±c quan h√≥a kh√¥ng gian h√≥a h·ªçc.</li>
<li><strong>Ph√¢n c·ª•m (clustering):</strong> Ph√¢n nh√≥m c√°c h·ª£p ch·∫•t d·ª±a tr√™n s·ª± t∆∞∆°ng ƒë·ªìng v·ªÅ c·∫•u tr√∫c.</li>
</ol>
</li>
<li><strong>·ª®ng d·ª•ng:</strong> L·ª±a ch·ªçn c√°c h·ª£p ch·∫•t ƒë·∫°i di·ªán cho th·ª≠ nghi·ªám s√†ng l·ªçc, thi·∫øt k·∫ø th∆∞ vi·ªán h·ª£p ch·∫•t ƒëa d·∫°ng.</li>
</ul>
</li>
<li><strong>M√¥ h√¨nh 3: D·ª± ƒëo√°n t√≠nh ch·∫•t h·∫•p th·ª•, ph√¢n b·ªë, chuy·ªÉn h√≥a, th·∫£i tr·ª´ (ADMET):</strong><ul>
<li><strong>M·ª•c ti√™u:</strong> D·ª± ƒëo√°n c√°c t√≠nh ch·∫•t d∆∞·ª£c ƒë·ªông h·ªçc c·ªßa m·ªôt h·ª£p ch·∫•t, gi√∫p ƒë√°nh gi√° kh·∫£ nƒÉng tr·ªü th√†nh thu·ªëc ti·ªÅm nƒÉng.</li>
<li><strong>Ph∆∞∆°ng ph√°p:</strong><ol>
<li><strong>T√≠nh to√°n descriptor:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ li√™n quan ƒë·∫øn ADMET (v√≠ d·ª•: logP, di·ªán t√≠ch b·ªÅ m·∫∑t ph√¢n c·ª±c).</li>
<li><strong>S·ª≠ d·ª•ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n:</strong> √Åp d·ª•ng c√°c m√¥ h√¨nh m√°y h·ªçc (v√≠ d·ª•: random forest, SVM) ho·∫∑c c√°c quy t·∫Øc d·ª±a tr√™n c·∫•u tr√∫c ƒë·ªÉ d·ª± ƒëo√°n c√°c t√≠nh ch·∫•t ADMET (v√≠ d·ª•: kh·∫£ nƒÉng h·∫•p th·ª• qua ƒë∆∞·ªùng u·ªëng, kh·∫£ nƒÉng x√¢m nh·∫≠p h√†ng r√†o m√°u n√£o).</li>
</ol>
</li>
<li><strong>·ª®ng d·ª•ng:</strong> L·ªçc b·ªè c√°c h·ª£p ch·∫•t c√≥ t√≠nh ch·∫•t ADMET kh√¥ng ph√π h·ª£p, t·ªëi ∆∞u h√≥a c·∫•u tr√∫c h·ª£p ch·∫•t ƒë·ªÉ c·∫£i thi·ªán t√≠nh ch·∫•t ADMET.</li>
</ul>
</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions):</strong></p>
<ul>
<li><strong>(English)</strong>: This project focuses on analyzing ChEMBL 35 data using RDKit to support drug discovery and development. You will use SQL to query and extract data, then use Python (with RDKit) to analyze and model the data.</li>
<li><strong>(Ti·∫øng Vi·ªát)</strong>: D·ª± √°n n√†y t·∫≠p trung v√†o ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. B·∫°n s·∫Ω s·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n v√† tr√≠ch xu·∫•t d·ªØ li·ªáu, sau ƒë√≥ s·ª≠ d·ª•ng Python (v·ªõi RDKit) ƒë·ªÉ ph√¢n t√≠ch v√† m√¥ h√¨nh h√≥a d·ªØ li·ªáu.</li>
</ul>
<p><strong>3. Code SQL v√† Python m·∫´u (SQL and Python Code Examples):</strong></p>
<p><strong>SQL (v√≠ d·ª• 1): L·∫•y 100 h·ª£p ch·∫•t ·ª©c ch·∫ø enzyme c√≥ IC50 &lt; 100 nM</strong></p>
<p>```sql
-- English
SELECT
    m.chembl_id,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary m ON act.molregno = m.molregno
JOIN
    compound_structures cs ON m.molregno = cs.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.target_type = 'SINGLE PROTEIN'
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND act.standard_value &gt; 0  -- Ensure positive values
    AND act.standard_value &lt;= 100
LIMIT 100;</p>
<p>--Ti·∫øng Vi·ªát
--L·∫•y 100 h·ª£p ch·∫•t ·ª©c ch·∫ø enzyme c√≥ IC50 &lt; 100 nM
SELECT
    m.chembl_id,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary m ON act.molregno = m.molregno
JOIN
    compound_structures cs ON m.molregno = cs.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.target_type = 'SINGLE PROTEIN'
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND act.standard_value &gt; 0  -- ƒê·∫£m b·∫£o gi√° tr·ªã d∆∞∆°ng
    AND act.standard_value &lt;= 100
LIMIT 100;
```</p>
<p><strong>Python (v√≠ d·ª• 1): T√≠nh to√°n descriptor ph√¢n t·ª≠ v√† v·∫Ω bi·ªÉu ƒë·ªì</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import matplotlib.pyplot as plt</p>
<h1>Load data from CSV file</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>Function to calculate molecular weight</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>Apply the function to the SMILES column</h1>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>Remove rows with NaN values in 'molecular_weight'</h1>
<p>df = df.dropna(subset=['molecular_weight'])</p>
<h1>Plotting the distribution of molecular weights</h1>
<p>plt.figure(figsize=(10, 6))
plt.hist(df['molecular_weight'], bins=50, color='skyblue', edgecolor='black')
plt.title('Distribution of Molecular Weights')
plt.xlabel('Molecular Weight (Da)')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()</p>
<h1>Ti·∫øng Vi·ªát</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import matplotlib.pyplot as plt</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ file CSV</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Thay th·∫ø "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>H√†m t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho c·ªôt SMILES</h1>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã NaN trong c·ªôt 'molecular_weight'</h1>
<p>df = df.dropna(subset=['molecular_weight'])</p>
<h1>V·∫Ω bi·ªÉu ƒë·ªì ph√¢n b·ªë tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>plt.figure(figsize=(10, 6))
plt.hist(df['molecular_weight'], bins=50, color='skyblue', edgecolor='black')
plt.title('Ph√¢n b·ªë tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠')
plt.xlabel('Tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Da)')
plt.ylabel('T·∫ßn s·ªë')
plt.grid(True)
plt.show()
```</p>
<p><strong>4. V√≠ d·ª• code SQL v√† Python m·∫´u (SQL and Python Code Examples):</strong></p>
<p><strong>SQL (v√≠ d·ª• 2): L·∫•y s·ªë l∆∞·ª£ng h·ª£p ch·∫•t cho m·ªói lo·∫°i m·ª•c ti√™u (target type)</strong></p>
<p>```sql
-- English
SELECT td.target_type, COUNT(DISTINCT m.molregno) AS num_compounds
FROM target_dictionary td
JOIN activities act ON td.tid = act.tid
JOIN molecule_dictionary m ON act.molregno = m.molregno
GROUP BY td.target_type
ORDER BY num_compounds DESC
LIMIT 10;</p>
<p>-- Ti·∫øng Vi·ªát
-- L·∫•y s·ªë l∆∞·ª£ng h·ª£p ch·∫•t cho m·ªói lo·∫°i m·ª•c ti√™u (target type)
SELECT td.target_type, COUNT(DISTINCT m.molregno) AS num_compounds
FROM target_dictionary td
JOIN activities act ON td.tid = act.tid
JOIN molecule_dictionary m ON act.molregno = m.molregno
GROUP BY td.target_type
ORDER BY num_compounds DESC
LIMIT 10;
```</p>
<p><strong>Python (v√≠ d·ª• 2): T√≠nh to√°n LogP v√† v·∫Ω scatter plot v·ªõi IC50</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import matplotlib.pyplot as plt
import numpy as np</p>
<h1>Load data from CSV (replace 'your_data.csv' with your actual file)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>Convert IC50 to numeric, handling potential errors</h1>
<p>df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')
df = df.dropna(subset=['standard_value'])</p>
<h1>Function to calculate LogP</h1>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolLogP(mol)
    else:
        return None</p>
<h1>Apply the function to the SMILES column</h1>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)</p>
<h1>Remove rows with NaN values in 'logp'</h1>
<p>df = df.dropna(subset=['logp'])</p>
<h1>Ensure standard_value is numeric and convert to pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to M and then to pIC50</p>
<h1>Create the scatter plot</h1>
<p>plt.figure(figsize=(10, 6))
plt.scatter(df['logp'], df['pIC50'], alpha=0.5)
plt.xlabel('LogP')
plt.ylabel('pIC50')
plt.title('LogP vs pIC50')
plt.grid(True)
plt.show()</p>
<h1>Ti·∫øng Vi·ªát</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import matplotlib.pyplot as plt
import numpy as np</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ file CSV (thay 'your_data.csv' b·∫±ng t√™n file c·ªßa b·∫°n)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Thay th·∫ø "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>Chuy·ªÉn ƒë·ªïi IC50 sang d·∫°ng s·ªë, x·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra</h1>
<p>df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')
df = df.dropna(subset=['standard_value'])</p>
<h1>H√†m t√≠nh to√°n LogP</h1>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolLogP(mol)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho c·ªôt SMILES</h1>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã NaN trong c·ªôt 'logp'</h1>
<p>df = df.dropna(subset=['logp'])</p>
<h1>ƒê·∫£m b·∫£o standard_value l√† s·ªë v√† chuy·ªÉn ƒë·ªïi sang pIC50</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM sang M v√† sau ƒë√≥ sang pIC50</p>
<h1>T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n</h1>
<p>plt.figure(figsize=(10, 6))
plt.scatter(df['logp'], df['pIC50'], alpha=0.5)
plt.xlabel('LogP')
plt.ylabel('pIC50')
plt.title('LogP so v·ªõi pIC50')
plt.grid(True)
plt.show()
```</p>
<p><strong>SQL (v√≠ d·ª• 3): L·∫•y c√°c h·ª£p ch·∫•t c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ n·∫±m trong kho·∫£ng 200-500 Da</strong></p>
<p>```sql
-- English
SELECT
    m.chembl_id,
    cs.canonical_smiles
FROM
    molecule_dictionary m
JOIN
    compound_structures cs ON m.molregno = cs.molregno
WHERE m.molregno IN (SELECT molregno FROM molecule_properties WHERE mw_freebase BETWEEN 200 AND 500)
LIMIT 100;</p>
<p>-- Ti·∫øng Vi·ªát
-- L·∫•y c√°c h·ª£p ch·∫•t c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ n·∫±m trong kho·∫£ng 200-500 Da
SELECT
    m.chembl_id,
    cs.canonical_smiles
FROM
    molecule_dictionary m
JOIN
    compound_structures cs ON m.molregno = m.molregno
WHERE m.molregno IN (SELECT molregno FROM molecule_properties WHERE mw_freebase BETWEEN 200 AND 500)
LIMIT 100;
```</p>
<p><strong>Python (v√≠ d·ª• 3): T√≠nh to√°n fingerprint Morgan v√† ph√¢n t√≠ch PCA</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import numpy as np</p>
<h1>Load data (replace 'your_data.csv' with your actual file)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>Function to generate Morgan Fingerprint</h1>
<p>def generate_morgan_fingerprint(smiles, radius=2, nBits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=nBits)
    else:
        return None</p>
<h1>Apply the function to the SMILES column</h1>
<p>df['morgan_fp'] = df['canonical_smiles'].apply(generate_morgan_fingerprint)</p>
<h1>Remove rows where fingerprint generation failed</h1>
<p>df = df.dropna(subset=['morgan_fp'])</p>
<h1>Convert fingerprints to a numpy array</h1>
<p>fingerprint_array = np.array([list(fp) for fp in df['morgan_fp']])</p>
<h1>Apply PCA</h1>
<p>pca = PCA(n_components=2)
pca_result = pca.fit_transform(fingerprint_array)</p>
<h1>Create a scatter plot of the PCA results</h1>
<p>plt.figure(figsize=(10, 8))
plt.scatter(pca_result[:, 0], pca_result[:, 1], alpha=0.5)
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('PCA of Morgan Fingerprints')
plt.grid(True)
plt.show()</p>
<h1>Ti·∫øng Vi·ªát</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt
import numpy as np</p>
<h1>T·∫£i d·ªØ li·ªáu (thay 'your_data.csv' b·∫±ng t√™n file c·ªßa b·∫°n)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Thay th·∫ø "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>H√†m t·∫°o Morgan Fingerprint</h1>
<p>def generate_morgan_fingerprint(smiles, radius=2, nBits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=nBits)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho c·ªôt SMILES</h1>
<p>df['morgan_fp'] = df['canonical_smiles'].apply(generate_morgan_fingerprint)</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng m√† qu√° tr√¨nh t·∫°o fingerprint b·ªã l·ªói</h1>
<p>df = df.dropna(subset=['morgan_fp'])</p>
<h1>Chuy·ªÉn ƒë·ªïi fingerprint th√†nh m·ªôt m·∫£ng numpy</h1>
<p>fingerprint_array = np.array([list(fp) for fp in df['morgan_fp']])</p>
<h1>√Åp d·ª•ng PCA</h1>
<p>pca = PCA(n_components=2)
pca_result = pca.fit_transform(fingerprint_array)</p>
<h1>T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n c·ªßa k·∫øt qu·∫£ PCA</h1>
<p>plt.figure(figsize=(10, 8))
plt.scatter(pca_result[:, 0], pca_result[:, 1], alpha=0.5)
plt.xlabel('Th√†nh ph·∫ßn ch√≠nh 1')
plt.ylabel('Th√†nh ph·∫ßn ch√≠nh 2')
plt.title('PCA c·ªßa Morgan Fingerprints')
plt.grid(True)
plt.show()
```</p>
<p><strong>SQL (v√≠ d·ª• 4): T√¨m c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± v·ªõi m·ªôt h·ª£p ch·∫•t c·ª• th·ªÉ (d·ª±a tr√™n SubstructureKeys)</strong></p>
<p>```sql
-- English
SELECT m.chembl_id, cs.canonical_smiles
FROM molecule_dictionary m
JOIN compound_structures cs ON m.molregno = cs.molregno
WHERE m.molregno IN (
    SELECT molregno
    FROM substructure_sets
    WHERE substructure IN (
        SELECT substructure FROM substructure_sets WHERE molregno = (SELECT molregno FROM molecule_dictionary WHERE chembl_id = 'CHEMBL121')
    )
    AND molregno != (SELECT molregno FROM molecule_dictionary WHERE chembl_id = 'CHEMBL121')
)
LIMIT 100;</p>
<p>-- Ti·∫øng Vi·ªát
-- T√¨m c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± v·ªõi m·ªôt h·ª£p ch·∫•t c·ª• th·ªÉ (d·ª±a tr√™n SubstructureKeys)
SELECT m.chembl_id, cs.canonical_smiles
FROM molecule_dictionary m
JOIN compound_structures cs ON m.molregno = cs.molregno
WHERE m.molregno IN (
    SELECT molregno
    FROM substructure_sets
    WHERE substructure IN (
        SELECT substructure FROM substructure_sets WHERE molregno = (SELECT molregno FROM molecule_dictionary WHERE chembl_id = 'CHEMBL121')
    )
    AND molregno != (SELECT molregno FROM molecule_dictionary WHERE chembl_id = 'CHEMBL121')
)
LIMIT 100;
```</p>
<p><strong>Python (v√≠ d·ª• 4): T√≠nh Tanimoto similarity gi·ªØa c√°c fingerprint</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit import DataStructs</p>
<h1>Load data (replace 'your_data.csv' with your actual file)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>Compound to compare against (replace with a valid CHEMBL_ID from your data)</h1>
<p>reference_smiles = df['canonical_smiles'].iloc[0] # l·∫•y smiles ƒë·∫ßu ti√™n l√†m chu·∫©n, b·∫°n c√≥ th·ªÉ thay ƒë·ªïi
reference_mol = Chem.MolFromSmiles(reference_smiles)
reference_fp = AllChem.GetMorganFingerprintAsBitVect(reference_mol, 2, nBits=2048)</p>
<h1>Function to calculate Tanimoto similarity</h1>
<p>def calculate_tanimoto_similarity(smiles, reference_fp):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
        return DataStructs.TanimotoSimilarity(reference_fp, fp)
    else:
        return None</p>
<h1>Apply the function to the SMILES column</h1>
<p>df['tanimoto_similarity'] = df['canonical_smiles'].apply(lambda x: calculate_tanimoto_similarity(x, reference_fp))</p>
<h1>Show the results</h1>
<p>print(df[['chembl_id', 'tanimoto_similarity']].head())</p>
<h1>Ti·∫øng Vi·ªát</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit import DataStructs</p>
<h1>T·∫£i d·ªØ li·ªáu (thay 'your_data.csv' b·∫±ng t√™n file c·ªßa b·∫°n)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Thay th·∫ø "your_data.csv"
df = pd.read_csv(data_path)</p>
<h1>H·ª£p ch·∫•t ƒë·ªÉ so s√°nh (thay b·∫±ng m·ªôt CHEMBL_ID h·ª£p l·ªá t·ª´ d·ªØ li·ªáu c·ªßa b·∫°n)</h1>
<p>reference_smiles = df['canonical_smiles'].iloc[0] # l·∫•y smiles ƒë·∫ßu ti√™n l√†m chu·∫©n, b·∫°n c√≥ th·ªÉ thay ƒë·ªïi
reference_mol = Chem.MolFromSmiles(reference_smiles)
reference_fp = AllChem.GetMorganFingerprintAsBitVect(reference_mol, 2, nBits=2048)</p>
<h1>H√†m t√≠nh ƒë·ªô t∆∞∆°ng ƒë·ªìng Tanimoto</h1>
<p>def calculate_tanimoto_similarity(smiles, reference_fp):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
        return DataStructs.TanimotoSimilarity(reference_fp, fp)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho c·ªôt SMILES</h1>
<p>df['tanimoto_similarity'] = df['canonical_smiles'].apply(lambda x: calculate_tanimoto_similarity(x, reference_fp))</p>
<h1>Hi·ªÉn th·ªã k·∫øt qu·∫£</h1>
<p>print(df[['chembl_id', 'tanimoto_similarity']].head())
```</p>
<p><strong>SQL (v√≠ d·ª• 5): L·∫•y th√¥ng tin v·ªÅ c√°c m·ª•c ti√™u (targets) li√™n quan ƒë·∫øn m·ªôt b·ªánh c·ª• th·ªÉ (v√≠ d·ª•: ung th∆∞)</strong></p>
<p>```sql
-- English
SELECT td.chembl_id, td.pref_name, td.target_type
FROM target_dictionary td
JOIN target_components tc ON td.tid = tc.tid
JOIN component_sequences cs ON tc.component_id = cs.component_id
WHERE cs.description LIKE '%cancer%'
LIMIT 100;</p>
<p>-- Ti·∫øng Vi·ªát
-- L·∫•y th√¥ng tin v·ªÅ c√°c m·ª•c ti√™u (targets) li√™n quan ƒë·∫øn m·ªôt b·ªánh c·ª• th·ªÉ (v√≠ d·ª•: ung th∆∞)
SELECT td.chembl_id, td.pref_name, td.target_type
FROM target_dictionary td
JOIN target_components tc ON td.tid = tc.tid
JOIN component_sequences cs ON tc.component_id = cs.component_id
WHERE cs.description LIKE '%cancer%'
LIMIT 100;
```</p>
<p><strong>Python (v√≠ d·ª• 5): S·ª≠ d·ª•ng RDKit ƒë·ªÉ chu·∫©n h√≥a SMILES</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import MolStandardize</p>
<h1>Load data (replace 'your_data.csv' with your actual file)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace "your_data.csv"
df = pd.read_csv(data_path)</p>
<p>def standardize_smiles(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is not None:
            # Initialize the standardization object
            std = MolStandardize.Standardizer()
            mol = std.charge_parent(mol)  # Get the parent molecule
            mol = std.normalize(mol)  # Apply normalization
            mol = std.reionize(mol)  # Reionize the molecule
            return Chem.MolToSmiles(mol)  # Convert back to SMILES
        else:
            return None
    except Exception as e:
        print(f"Error processing SMILES: {smiles} - {e}")
        return None</p>
<h1>Apply the standardization function</h1>
<p>df['standardized_smiles'] = df['canonical_smiles'].apply(standardize_smiles)</p>
<h1>Display the standardized SMILES</h1>
<p>print(df[['canonical_smiles', 'standardized_smiles']].head())</p>
<h1>Ti·∫øng Vi·ªát</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import MolStandardize</p>
<h1>T·∫£i d·ªØ li·ªáu (thay 'your_data.csv' b·∫±ng t√™n file c·ªßa b·∫°n)</h1>
<p>base_path = "." # Thay ƒë·ªïi n·∫øu c·∫ßn
data_path = os.path.join(base_path, "data", "your_data.csv")  # Thay th·∫ø "your_data.csv"
df = pd.read_csv(data_path)</p>
<p>def standardize_smiles(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is not None:
            # Kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng chu·∫©n h√≥a
            std = MolStandardize.Standardizer()
            mol = std.charge_parent(mol)  # L·∫•y ph√¢n t·ª≠ g·ªëc
            mol = std.normalize(mol)  # √Åp d·ª•ng chu·∫©n h√≥a
            mol = std.reionize(mol)  # T√°i ion h√≥a ph√¢n t·ª≠
            return Chem.MolToSmiles(mol)  # Chuy·ªÉn ƒë·ªïi l·∫°i th√†nh SMILES
        else:
            return None
    except Exception as e:
        print(f"L·ªói x·ª≠ l√Ω SMILES: {smiles} - {e}")
        return None</p>
<h1>√Åp d·ª•ng h√†m chu·∫©n h√≥a</h1>
<p>df['standardized_smiles'] = df['canonical_smiles'].apply(standardize_smiles)</p>
<h1>Hi·ªÉn th·ªã SMILES ƒë√£ ƒë∆∞·ª£c chu·∫©n h√≥a</h1>
<p>print(df[['canonical_smiles', 'standardized_smiles']].head())
```</p>
<p><strong>5. Gi·∫£i quy·∫øt c√°c l·ªói th∆∞·ªùng g·∫∑p (Addressing Common Errors):</strong></p>
<ul>
<li>
<p><strong>L·ªói SQL: <code>ERROR: operator does not exist: numeric ~ unknown</code></strong></p>
<ul>
<li><strong>(English)</strong>: This error occurs because you're trying to use a regular expression operator (<code>~</code>) on a numeric column.  To fix this, ensure that the <code>standard_value</code> column contains only numeric data <em>before</em> applying the regular expression. You can use <code>TRY_CAST</code> to safely convert the column to numeric.</li>
<li><strong>(Ti·∫øng Vi·ªát)</strong>: L·ªói n√†y x·∫£y ra v√¨ b·∫°n ƒëang c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ bi·ªÉu th·ª©c ch√≠nh quy (<code>~</code>) tr√™n m·ªôt c·ªôt s·ªë. ƒê·ªÉ kh·∫Øc ph·ª•c, h√£y ƒë·∫£m b·∫£o r·∫±ng c·ªôt <code>standard_value</code> ch·ªâ ch·ª©a d·ªØ li·ªáu s·ªë <em>tr∆∞·ªõc khi</em> √°p d·ª•ng bi·ªÉu th·ª©c ch√≠nh quy. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng <code>TRY_CAST</code> ƒë·ªÉ chuy·ªÉn ƒë·ªïi an to√†n c·ªôt n√†y sang ki·ªÉu s·ªë.</li>
</ul>
<p>```sql
-- English
SELECT
    m.chembl_id,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary m ON act.molregno = m.molregno
JOIN
    compound_structures cs ON m.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    -- Try to cast to numeric <em>before</em> filtering by regex
    AND TRY_CAST(act.standard_value AS NUMERIC) IS NOT NULL
    -- Now that we <em>know</em> it's numeric, we can compare it as such
    AND TRY_CAST(act.standard_value AS NUMERIC) &gt; 0
    AND TRY_CAST(act.standard_value AS NUMERIC) &lt;= 100
LIMIT 100;</p>
<p>-- Ti·∫øng Vi·ªát
SELECT
    m.chembl_id,
    cs.canonical_smiles,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary m ON act.molregno = m.molregno
JOIN
    compound_structures cs ON m.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    -- Th·ª≠ chuy·ªÉn ƒë·ªïi sang ki·ªÉu s·ªë <em>tr∆∞·ªõc khi</em> l·ªçc b·∫±ng regex
    AND TRY_CAST(act.standard_value AS NUMERIC) IS NOT NULL
    -- B√¢y gi·ªù <em>ch√∫ng ta bi·∫øt</em> n√≥ l√† s·ªë, ch√∫ng ta c√≥ th·ªÉ so s√°nh n√≥ nh∆∞ v·∫≠y
    AND TRY_CAST(act.standard_value AS NUMERIC) &gt; 0
    AND TRY_CAST(act.standard_value AS NUMERIC) &lt;= 100
LIMIT 100;
```</p>
</li>
<li>
<p><strong>L·ªói Python: <code>TypeError: mean_squared_error() got an unexpected keyword argument 'squared'</code></strong></p>
<ul>
<li><strong>(English)</strong>: This error indicates that your version of scikit-learn is outdated. The <code>squared=False</code> parameter was introduced in a later version.  You have two options:<ol>
<li><strong>Upgrade scikit-learn:</strong>  <code>pip install scikit-learn --upgrade</code></li>
<li><strong>Remove <code>squared=False</code>:</strong> If you can't upgrade, remove the <code>squared=False</code> argument and take the square root of the result to get the RMSE (Root Mean Squared Error).</li>
</ol>
</li>
<li><strong>(Ti·∫øng Vi·ªát)</strong>: L·ªói n√†y ch·ªâ ra r·∫±ng phi√™n b·∫£n scikit-learn c·ªßa b·∫°n ƒë√£ c≈©. Tham s·ªë <code>squared=False</code> ƒë∆∞·ª£c gi·ªõi thi·ªáu trong m·ªôt phi√™n b·∫£n sau n√†y. B·∫°n c√≥ hai l·ª±a ch·ªçn:<ol>
<li><strong>N√¢ng c·∫•p scikit-learn:</strong> <code>pip install scikit-learn --upgrade</code></li>
<li><strong>X√≥a <code>squared=False</code>:</strong> N·∫øu b·∫°n kh√¥ng th·ªÉ n√¢ng c·∫•p, h√£y x√≥a ƒë·ªëi s·ªë <code>squared=False</code> v√† l·∫•y cƒÉn b·∫≠c hai c·ªßa k·∫øt qu·∫£ ƒë·ªÉ c√≥ ƒë∆∞·ª£c RMSE (Root Mean Squared Error).</li>
</ol>
</li>
</ul>
<p>```python</p>
<h1>V√≠ d·ª•:</h1>
<p>from sklearn.metrics import mean_squared_error
import numpy as np</p>
<p>y_true = [3, -0.5, 2, 7]
y_predicted = [2.5, 0.0, 2, 8]</p>
<h1>N·∫øu b·∫°n kh√¥ng th·ªÉ n√¢ng c·∫•p scikit-learn:</h1>
<p>mse = mean_squared_error(y_true, y_predicted)
rmse = np.sqrt(mse)
print(f"RMSE: {rmse}")</p>
<h1>N·∫øu b·∫°n ƒë√£ n√¢ng c·∫•p scikit-learn:</h1>
<p>rmse = mean_squared_error(y_true, y_predicted, squared=False)
print(f"RMSE: {rmse}")
```</p>
</li>
</ul>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li>H√£y thay th·∫ø <code>"your_data.csv"</code> b·∫±ng t√™n file CSV th·ª±c t·∫ø c·ªßa b·∫°n.</li>
<li>ƒêi·ªÅu ch·ªânh c√°c tham s·ªë v√† truy v·∫•n SQL cho ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u c·ª• th·ªÉ c·ªßa b·∫°n.</li>
<li>S·ª≠ d·ª•ng <code>os.path.join(base_path, "data", "your_data.csv")</code> ƒë·ªÉ ƒë·∫£m b·∫£o code c·ªßa b·∫°n ho·∫°t ƒë·ªông tr√™n c√°c h·ªá ƒëi·ªÅu h√†nh kh√°c nhau.</li>
<li>H√£y nh·ªõ c√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt: <code>pip install pandas rdkit scikit-learn matplotlib</code></li>
</ul>
<p>T√¥i hy v·ªçng h∆∞·ªõng d·∫´n n√†y s·∫Ω gi√∫p b·∫°n b·∫Øt ƒë·∫ßu d·ª± √°n c·ªßa m√¨nh m·ªôt c√°ch su√¥n s·∫ª. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi!</p>
        </body>
        </html>
        