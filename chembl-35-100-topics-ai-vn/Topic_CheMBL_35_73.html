
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_73</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: ·ª®ng d·ª•ng t√¨m ki·∫øm t∆∞∆°ng ƒë·ªìng t∆∞∆°ng t√°c</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&amp;D d∆∞·ª£c h·ªçc, t√¥i s·∫Ω gi√∫p b·∫°n x√¢y d·ª±ng quy tr√¨nh ph√¢n t√≠ch hi·ªáu qu·∫£, kh·∫Øc ph·ª•c c√°c l·ªói v√† ƒë∆∞a ra c√°c v√≠ d·ª• c·ª• th·ªÉ ƒë·ªÉ b·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu ngay.</p>
<p><strong>Ph√¢n t√≠ch T·ªïng quan v√† M√¥ h√¨nh Ph√¢n t√≠ch (Overview and Analysis Model)</strong></p>
<p>D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, s·ª≠ d·ª•ng RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc v√† PostgreSQL ƒë·ªÉ qu·∫£n l√Ω d·ªØ li·ªáu. M·ª•c ti√™u l√† h·ªó tr·ª£ c√°c nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. D∆∞·ªõi ƒë√¢y l√† m√¥ h√¨nh ph√¢n t√≠ch t·ªïng quan m√† ch√∫ng ta c√≥ th·ªÉ √°p d·ª•ng:</p>
<ol>
<li><strong>Data Extraction and Preparation (Tr√≠ch xu·∫•t v√† Chu·∫©n b·ªã D·ªØ li·ªáu):</strong><ul>
<li>S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ ChEMBL 35, t·∫≠p trung v√†o c√°c b·∫£ng ch·ª©a th√¥ng tin v·ªÅ ho·∫°t t√≠nh sinh h·ªçc (bioactivity), c·∫•u tr√∫c h√≥a h·ªçc, v√† c√°c thu·ªôc t√≠nh li√™n quan.</li>
<li>L∆∞u d·ªØ li·ªáu tr√≠ch xu·∫•t v√†o c√°c file CSV ƒë·ªÉ d·ªÖ d√†ng x·ª≠ l√Ω b·∫±ng Python.</li>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ (v√≠ d·ª•: tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠, logP, s·ªë l∆∞·ª£ng v√≤ng) t·ª´ c·∫•u tr√∫c SMILES.</li>
</ul>
</li>
<li><strong>Data Cleaning and Preprocessing (L√†m s·∫°ch v√† Ti·ªÅn x·ª≠ l√Ω D·ªØ li·ªáu):</strong><ul>
<li>X·ª≠ l√Ω c√°c gi√° tr·ªã thi·∫øu (missing values) v√† ngo·∫°i l·ªá (outliers).</li>
<li>Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n.</li>
<li>Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªãnh t√≠nh th√†nh ƒë·ªãnh l∆∞·ª£ng n·∫øu c·∫ßn thi·∫øt.</li>
</ul>
</li>
<li><strong>Exploratory Data Analysis (EDA) (Ph√¢n t√≠ch Kh√°m ph√° D·ªØ li·ªáu):</strong><ul>
<li>S·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t th·ªëng k√™ v√† tr·ª±c quan h√≥a ƒë·ªÉ kh√°m ph√° c√°c xu h∆∞·ªõng v√† m·ªëi quan h·ªá trong d·ªØ li·ªáu.</li>
<li>V√≠ d·ª•: ph√¢n ph·ªëi c·ªßa c√°c gi√° tr·ªã ho·∫°t t√≠nh, m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor ph√¢n t·ª≠ v√† ho·∫°t t√≠nh.</li>
</ul>
</li>
<li><strong>Model Building and Evaluation (X√¢y d·ª±ng v√† ƒê√°nh gi√° M√¥ h√¨nh):</strong><ul>
<li>X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, random forest, m·∫°ng n∆°-ron) d·ª±a tr√™n c√°c descriptor ph√¢n t·ª≠.</li>
<li>ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°c ch·ªâ s·ªë ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE, AUC).</li>
</ul>
</li>
<li><strong>Interpretation and Application (Gi·∫£i th√≠ch v√† ·ª®ng d·ª•ng):</strong><ul>
<li>Gi·∫£i th√≠ch c√°c k·∫øt qu·∫£ m√¥ h√¨nh ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c v√† ho·∫°t t√≠nh.</li>
<li>·ª®ng d·ª•ng m√¥ h√¨nh ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t m·ªõi, s√†ng l·ªçc ·∫£o (virtual screening), v√† t·ªëi ∆∞u h√≥a c·∫•u tr√∫c thu·ªëc.</li>
</ul>
</li>
</ol>
<p><strong>H∆∞·ªõng d·∫´n Song ng·ªØ v√† M√£ (Bilingual Guide and Code)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt v√† m√£ m·∫´u cho t·ª´ng b∆∞·ªõc, k√®m theo gi·∫£i th√≠ch b·∫±ng c·∫£ ti·∫øng Anh v√† ti·∫øng Vi·ªát:</p>
<p><strong>1. Data Extraction (Tr√≠ch xu·∫•t D·ªØ li·ªáu)</strong></p>
<p><strong>SQL Code (Ti·∫øng Anh):</strong></p>
<p>```sql
-- Extract bioactivity data and molecule structures from ChEMBL
-- L·∫•y d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc v√† c·∫•u tr√∫c ph√¢n t·ª≠ t·ª´ ChEMBL
SELECT
    act.molregno,
    mol.chembl_id,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    mol.molsmiles
FROM
    activities act
JOIN
    molecule_dictionary mol ON act.molregno = mol.molregno
WHERE
    act.standard_type = 'IC50'  -- You can change this to other activity types like Ki, EC50, etc.
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value &gt; 0
    AND act.standard_value &lt; 10000 -- Filter out very high IC50 values
    AND act.standard_units = 'nM'
LIMIT 100; -- Limit to 100 rows for testing</p>
<p>-- Save the result as a CSV file (e.g., chembl_ic50_data.csv)
-- L∆∞u k·∫øt qu·∫£ v√†o file CSV (v√≠ d·ª•: chembl_ic50_data.csv)
```</p>
<p><strong>SQL Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):</strong></p>
<p>```sql
-- L·∫•y d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc v√† c·∫•u tr√∫c ph√¢n t·ª≠ t·ª´ ChEMBL
SELECT
    act.molregno,  -- M√£ s·ªë ph√¢n t·ª≠ (molecule registry number)
    mol.chembl_id, -- M√£ ChEMBL c·ªßa ph√¢n t·ª≠
    act.standard_type, -- Lo·∫°i ho·∫°t t√≠nh (v√≠ d·ª•: IC50, Ki)
    act.standard_value, -- Gi√° tr·ªã ho·∫°t t√≠nh
    act.standard_units, -- ƒê∆°n v·ªã c·ªßa gi√° tr·ªã ho·∫°t t√≠nh
    mol.molsmiles -- C·∫•u tr√∫c SMILES c·ªßa ph√¢n t·ª≠
FROM
    activities act  -- B·∫£ng ch·ª©a th√¥ng tin ho·∫°t t√≠nh
JOIN
    molecule_dictionary mol ON act.molregno = mol.molregno  -- B·∫£ng ch·ª©a th√¥ng tin ph√¢n t·ª≠, k·∫øt n·ªëi qua molregno
WHERE
    act.standard_type = 'IC50'  -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh lo·∫°i IC50 (c√≥ th·ªÉ thay ƒë·ªïi)
    AND act.standard_relation = '=' -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh c√≥ quan h·ªá "=" (b·∫±ng)
    AND act.standard_value IS NOT NULL -- L·ªçc b·ªè c√°c gi√° tr·ªã ho·∫°t t√≠nh b·ªã thi·∫øu
    AND act.standard_value &gt; 0 -- L·ªçc b·ªè c√°c gi√° tr·ªã ho·∫°t t√≠nh √¢m ho·∫∑c b·∫±ng 0
    AND act.standard_value &lt; 10000 -- L·ªçc b·ªè c√°c gi√° tr·ªã IC50 qu√° cao (l·ªõn h∆°n 10000 nM)
    AND act.standard_units = 'nM' -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh c√≥ ƒë∆°n v·ªã l√† nM (nanomolar)
LIMIT 100; -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ l√† 100 d√≤ng (cho m·ª•c ƒë√≠ch th·ª≠ nghi·ªám)</p>
<p>-- L∆∞u k·∫øt qu·∫£ v√†o file CSV (v√≠ d·ª•: chembl_ic50_data.csv)
```</p>
<p><strong>L∆∞u √Ω v·ªÅ l·ªói "operator does not exist: numeric ~ unknown":</strong></p>
<p>L·ªói n√†y th∆∞·ªùng x·∫£y ra khi b·∫°n c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ <code>~</code> (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë (numeric). ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ chuy·ªÉn ƒë·ªïi c·ªôt s·ªë th√†nh ki·ªÉu chu·ªói (text) tr∆∞·ªõc khi s·ª≠ d·ª•ng to√°n t·ª≠ <code>~</code>. Tuy nhi√™n, trong tr∆∞·ªùng h·ª£p n√†y, b·∫°n kh√¥ng c·∫ßn s·ª≠ d·ª•ng regular expression ƒë·ªÉ l·ªçc c√°c gi√° tr·ªã s·ªë. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c to√°n t·ª≠ so s√°nh tr·ª±c ti·∫øp nh∆∞ <code>&gt;</code> v√† <code>&lt;</code>.</p>
<p><strong>2. Data Loading and Processing with RDKit (T·∫£i v√† X·ª≠ l√Ω D·ªØ li·ªáu v·ªõi RDKit)</strong></p>
<p><strong>Python Code (Ti·∫øng Anh):</strong></p>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import os</p>
<h1>Define the base path for your project</h1>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n</h1>
<p>base_path = '.'  # Adjust this to your actual base path</p>
<h1>Load the CSV file containing ChEMBL data</h1>
<h1>T·∫£i file CSV ch·ª©a d·ªØ li·ªáu ChEMBL</h1>
<p>data_path = os.path.join(base_path, 'data', 'chembl_ic50_data.csv')  # Adjust the file name accordingly
df = pd.read_csv(data_path)</p>
<h1>Function to calculate molecular descriptors using RDKit</h1>
<h1>H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ b·∫±ng RDKit</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {
        "MW": Descriptors.MolWt(mol),
        "LogP": Descriptors.MolLogP(mol),
        "HBA": Descriptors.NumHAcceptors(mol),
        "HBD": Descriptors.NumHDonors(mol),
        "TPSA": Descriptors.TPSA(mol)
    }
    return descriptors</p>
<h1>Apply the function to each SMILES string in the dataframe</h1>
<h1>√Åp d·ª•ng h√†m cho m·ªói chu·ªói SMILES trong dataframe</h1>
<p>df['descriptors'] = df['molsmiles'].apply(calculate_descriptors)</p>
<h1>Expand the descriptor dictionary into separate columns</h1>
<h1>M·ªü r·ªông t·ª´ ƒëi·ªÉn descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát</h1>
<p>df = pd.concat([df, df['descriptors'].apply(pd.Series)], axis=1)</p>
<h1>Drop rows with missing descriptors</h1>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ descriptor b·ªã thi·∫øu</h1>
<p>df = df.dropna(subset=['MW', 'LogP', 'HBA', 'HBD', 'TPSA'])</p>
<h1>Convert IC50 values to pIC50 (optional)</h1>
<h1>Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50 (t√πy ch·ªçn)</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to Molar</p>
<h1>Display the first few rows of the processed dataframe</h1>
<h1>Hi·ªÉn th·ªã m·ªôt v√†i h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe ƒë√£ x·ª≠ l√Ω</h1>
<p>print(df.head())
```</p>
<p><strong>Python Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):</strong></p>
<p>```python
import pandas as pd  # Th∆∞ vi·ªán ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # C√°c module con c·ªßa RDKit ƒë·ªÉ t√≠nh to√°n descriptor
import os  # Th∆∞ vi·ªán ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi h·ªá ƒëi·ªÅu h√†nh</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n</h1>
<p>base_path = '.'  # ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n n√†y cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c c·ªßa b·∫°n</p>
<h1>T·∫£i file CSV ch·ª©a d·ªØ li·ªáu ChEMBL</h1>
<p>data_path = os.path.join(base_path, 'data', 'chembl_ic50_data.csv')  # ƒêi·ªÅu ch·ªânh t√™n file cho ph√π h·ª£p
df = pd.read_csv(data_path)  # ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV v√†o m·ªôt dataframe</p>
<h1>H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ b·∫±ng RDKit</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi chu·ªói SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol is None:  # Ki·ªÉm tra xem chuy·ªÉn ƒë·ªïi c√≥ th√†nh c√¥ng kh√¥ng
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th√†nh c√¥ng (v√≠ d·ª•: SMILES kh√¥ng h·ª£p l·ªá)
    descriptors = {  # T·∫°o m·ªôt t·ª´ ƒëi·ªÉn ƒë·ªÉ l∆∞u tr·ªØ c√°c descriptor
        "MW": Descriptors.MolWt(mol),  # Tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Molecular Weight)
        "LogP": Descriptors.MolLogP(mol),  # H·ªá s·ªë ph√¢n v√πng octanol-n∆∞·ªõc (LogP)
        "HBA": Descriptors.NumHAcceptors(mol),  # S·ªë l∆∞·ª£ng ch·∫•t nh·∫≠n li√™n k·∫øt hydro (Hydrogen Bond Acceptors)
        "HBD": Descriptors.NumHDonors(mol),  # S·ªë l∆∞·ª£ng ch·∫•t cho li√™n k·∫øt hydro (Hydrogen Bond Donors)
        "TPSA": Descriptors.TPSA(mol)  # Di·ªán t√≠ch b·ªÅ m·∫∑t ph√¢n c·ª±c (Topological Polar Surface Area)
    }
    return descriptors  # Tr·∫£ v·ªÅ t·ª´ ƒëi·ªÉn ch·ª©a c√°c descriptor</p>
<h1>√Åp d·ª•ng h√†m cho m·ªói chu·ªói SMILES trong dataframe</h1>
<p>df['descriptors'] = df['molsmiles'].apply(calculate_descriptors)  # T·∫°o m·ªôt c·ªôt m·ªõi 'descriptors' ch·ª©a k·∫øt qu·∫£</p>
<h1>M·ªü r·ªông t·ª´ ƒëi·ªÉn descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát</h1>
<p>df = pd.concat([df, df['descriptors'].apply(pd.Series)], axis=1)  # T·∫°o c√°c c·ªôt m·ªõi t·ª´ t·ª´ ƒëi·ªÉn descriptor</p>
<h1>Lo·∫°i b·ªè c√°c h√†ng c√≥ descriptor b·ªã thi·∫øu</h1>
<p>df = df.dropna(subset=['MW', 'LogP', 'HBA', 'HBD', 'TPSA'])  # Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã NaN trong c√°c c·ªôt descriptor</p>
<h1>Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50 (t√πy ch·ªçn)</h1>
<p>df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM sang Molar v√† t√≠nh pIC50</p>
<h1>Hi·ªÉn th·ªã m·ªôt v√†i h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe ƒë√£ x·ª≠ l√Ω</h1>
<p>print(df.head())  # In ra 5 h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe
```</p>
<p><strong>3. Model Building (X√¢y d·ª±ng M√¥ h√¨nh)</strong></p>
<p><strong>Python Code (Ti·∫øng Anh):</strong></p>
<p>```python
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Prepare the data for modeling</h1>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu cho vi·ªác x√¢y d·ª±ng m√¥ h√¨nh</h1>
<p>X = df[['MW', 'LogP', 'HBA', 'HBD', 'TPSA']]  # Features
y = df['pIC50']  # Target variable</p>
<h1>Split the data into training and testing sets</h1>
<h1>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Create a Random Forest Regressor model</h1>
<h1>T·∫°o m·ªôt m√¥ h√¨nh Random Forest Regressor</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)</p>
<h1>Train the model</h1>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh</h1>
<p>model.fit(X_train, y_train)</p>
<h1>Make predictions on the test set</h1>
<h1>D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>Python Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):</strong></p>
<p>```python
from sklearn.model_selection import train_test_split  # H√†m ƒë·ªÉ chia d·ªØ li·ªáu
from sklearn.ensemble import RandomForestRegressor  # M√¥ h√¨nh Random Forest
from sklearn.metrics import mean_squared_error, r2_score  # C√°c ch·ªâ s·ªë ƒë√°nh gi√° m√¥ h√¨nh</p>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu cho vi·ªác x√¢y d·ª±ng m√¥ h√¨nh</h1>
<p>X = df[['MW', 'LogP', 'HBA', 'HBD', 'TPSA']]  # C√°c bi·∫øn ƒë·ªôc l·∫≠p (features)
y = df['pIC50']  # Bi·∫øn ph·ª• thu·ªôc (target variable)</p>
<h1>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # 80% cho hu·∫•n luy·ªán, 20% cho ki·ªÉm tra</p>
<h1>T·∫°o m·ªôt m√¥ h√¨nh Random Forest Regressor</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)  # S·ªë l∆∞·ª£ng c√¢y trong r·ª´ng l√† 100</p>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh</h1>
<p>model.fit(X_train, y_train)  # S·ª≠ d·ª•ng t·∫≠p hu·∫•n luy·ªán ƒë·ªÉ "d·∫°y" m√¥ h√¨nh</p>
<h1>D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra</h1>
<p>y_pred = model.predict(X_test)  # S·ª≠ d·ª•ng m√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán ƒë·ªÉ d·ª± ƒëo√°n gi√° tr·ªã pIC50 tr√™n t·∫≠p ki·ªÉm tra</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>mse = mean_squared_error(y_test, y_pred)  # T√≠nh sai s·ªë b√¨nh ph∆∞∆°ng trung b√¨nh (Mean Squared Error)
r2 = r2_score(y_test, y_pred)  # T√≠nh h·ªá s·ªë x√°c ƒë·ªãnh (R-squared)</p>
<p>print(f"Mean Squared Error: {mse}")  # In ra gi√° tr·ªã MSE
print(f"R-squared: {r2}")  # In ra gi√° tr·ªã R-squared
```</p>
<p><strong>L∆∞u √Ω v·ªÅ l·ªói "squared=False trong h√†m mean_squared_error":</strong></p>
<p>Tham s·ªë <code>squared=False</code> ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†m <code>mean_squared_error</code> trong c√°c phi√™n b·∫£n scikit-learn m·ªõi h∆°n ƒë·ªÉ tr·∫£ v·ªÅ Root Mean Squared Error (RMSE) thay v√¨ MSE. N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, b·∫°n s·∫Ω g·∫∑p l·ªói khi s·ª≠ d·ª•ng tham s·ªë n√†y. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ n√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t ho·∫∑c t√≠nh RMSE th·ªß c√¥ng b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE:</p>
<p><code>python
mse = mean_squared_error(y_test, y_pred)
rmse = mse**0.5
print(f"Root Mean Squared Error: {rmse}")</code></p>
<p><strong>4. V√≠ d·ª• M√£ (Code Examples)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• m√£ SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>V√≠ d·ª• 1: L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh (Filtering Data by Activity Range)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
SELECT mol.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary mol ON act.molregno = mol.molregno
WHERE act.standard_type = 'IC50' AND act.standard_value BETWEEN 100 AND 1000;</code></p>
<p><strong>Python:</strong></p>
<p><code>python
df_filtered = df[(df['standard_value'] &gt;= 100) &amp; (df['standard_value'] &lt;= 1000)]
print(df_filtered.head())</code></p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n s·ªë l∆∞·ª£ng ph√¢n t·ª≠ c√≥ m·ªôt s·ªë l∆∞·ª£ng v√≤ng nh·∫•t ƒë·ªãnh (Calculating Number of Molecules with Specific Ring Count)</strong></p>
<p><strong>SQL (C·∫ßn th√™m th√¥ng tin v·ªÅ s·ªë l∆∞·ª£ng v√≤ng v√†o b·∫£ng):</strong></p>
<p><code>sql
-- This requires a table with ring count information
-- ƒêi·ªÅu n√†y y√™u c·∫ßu m·ªôt b·∫£ng c√≥ th√¥ng tin v·ªÅ s·ªë l∆∞·ª£ng v√≤ng
-- Example: molecule_properties table with 'num_rings' column
-- V√≠ d·ª•: b·∫£ng molecule_properties c√≥ c·ªôt 'num_rings'
SELECT mol.chembl_id
FROM molecule_dictionary mol
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE mp.num_rings = 3;</code></p>
<p><strong>Python:</strong></p>
<p>```python
from rdkit.Chem import RingInfo</p>
<p>def get_ring_count(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        ring_info = mol.GetRingInfo()
        return ring_info.NumRings()
    return None</p>
<p>df['ring_count'] = df['molsmiles'].apply(get_ring_count)
print(df['ring_count'].value_counts())
```</p>
<p><strong>V√≠ d·ª• 3: T√¨m c√°c ph√¢n t·ª≠ c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trong m·ªôt kho·∫£ng nh·∫•t ƒë·ªãnh (Finding Molecules with Molecular Weight in a Specific Range)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
-- Assuming you have a table with molecular weights
-- Gi·∫£ s·ª≠ b·∫°n c√≥ m·ªôt b·∫£ng v·ªõi tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠
-- Example: molecule_properties table with 'molecular_weight' column
-- V√≠ d·ª•: b·∫£ng molecule_properties c√≥ c·ªôt 'molecular_weight'
SELECT mol.chembl_id
FROM molecule_dictionary mol
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE mp.molecular_weight BETWEEN 200 AND 400;</code></p>
<p><strong>Python:</strong></p>
<p><code>python
df_mw_filtered = df[(df['MW'] &gt;= 200) &amp; (df['MW'] &lt;= 400)]
print(df_mw_filtered.head())</code></p>
<p><strong>V√≠ d·ª• 4: Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa LogP v√† pIC50 (Analyzing Correlation between LogP and pIC50)</strong></p>
<p><strong>SQL (Kh√¥ng th·ªÉ t√≠nh t∆∞∆°ng quan tr·ª±c ti·∫øp trong SQL ƒë∆°n gi·∫£n):</strong></p>
<p><code>sql
-- SQL can't directly calculate correlation easily, use Python
-- SQL kh√¥ng th·ªÉ t√≠nh t∆∞∆°ng quan tr·ª±c ti·∫øp m·ªôt c√°ch d·ªÖ d√†ng, h√£y s·ª≠ d·ª•ng Python
SELECT mol.chembl_id, act.standard_value, mp.logp
FROM activities act
JOIN molecule_dictionary mol ON act.molregno = mol.molregno
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE act.standard_type = 'IC50';</code></p>
<p><strong>Python:</strong></p>
<p><code>python
correlation = df['LogP'].corr(df['pIC50'])
print(f"Correlation between LogP and pIC50: {correlation}")</code></p>
<p><strong>V√≠ d·ª• 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng scatter plot (Data Visualization using Scatter Plot)</strong></p>
<p><strong>Python:</strong></p>
<p>```python
import matplotlib.pyplot as plt</p>
<p>plt.scatter(df['LogP'], df['pIC50'])
plt.xlabel('LogP')
plt.ylabel('pIC50')
plt.title('LogP vs pIC50')
plt.show()
```</p>
<p><strong>L∆∞u √Ω Quan tr·ªçng:</strong></p>
<ul>
<li><strong>ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n:</strong> H√£y ch·∫Øc ch·∫Øn r·∫±ng b·∫°n ƒë√£ ƒëi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n file v√† t√™n file trong code cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c v√† t√™n file th·ª±c t·∫ø c·ªßa b·∫°n.</li>
<li><strong>C√†i ƒë·∫∑t th∆∞ vi·ªán:</strong> ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√†i ƒë·∫∑t t·∫•t c·∫£ c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt (v√≠ d·ª•: pandas, rdkit, scikit-learn, matplotlib) tr∆∞·ªõc khi ch·∫°y code Python.</li>
<li><strong>X·ª≠ l√Ω l·ªói:</strong> Lu√¥n ki·ªÉm tra v√† x·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh ch·∫°y code.</li>
<li><strong>Gi·ªõi h·∫°n d·ªØ li·ªáu:</strong> V√¨ l√Ω do hi·ªáu su·∫•t, ch√∫ng ta ƒëang gi·ªõi h·∫°n s·ªë l∆∞·ª£ng d·ªØ li·ªáu ƒë∆∞·ª£c tr√≠ch xu·∫•t v√† x·ª≠ l√Ω. B·∫°n c√≥ th·ªÉ tƒÉng gi·ªõi h·∫°n n√†y khi c·∫ßn thi·∫øt, nh∆∞ng h√£y c·∫©n th·∫≠n v·ªõi t√†i nguy√™n m√°y t√≠nh c·ªßa b·∫°n.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        