
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_9</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: T√¨m ki·∫øm t∆∞∆°ng ƒë·ªìng Tanimoto v·ªõi ChEMBL v√† RDKit</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 b·∫±ng RDKit. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n, v√† c√°c v√≠ d·ª• code ƒë·ªÉ b·∫°n b·∫Øt ƒë·∫ßu, t·∫≠p trung v√†o ch·ªß ƒë·ªÅ <strong>Topic_CheMBL_35_9</strong>.</p>
<p><strong>1. Ph√¢n t√≠ch v√† M√¥ h√¨nh Ph√¢n t√≠ch (Analysis and Analysis Model)</strong></p>
<p><strong>Ch·ªß ƒë·ªÅ (Topic):</strong> Topic_CheMBL_35_9 c√≥ th·ªÉ li√™n quan ƒë·∫øn m·ªôt m·ª•c ti√™u c·ª• th·ªÉ (v√≠ d·ª•: m·ªôt protein, m·ªôt lo·∫°i enzyme) ho·∫∑c m·ªôt lo·∫°i ho·∫°t ƒë·ªông sinh h·ªçc (v√≠ d·ª•: ·ª©c ch·∫ø, k√≠ch ho·∫°t). Ph√¢n t√≠ch n√†y s·∫Ω t·∫≠p trung v√†o vi·ªác x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng.</p>
<p><strong>M√¥ h√¨nh ph√¢n t√≠ch (Analysis Model):</strong></p>
<ul>
<li><strong>Thu th·∫≠p d·ªØ li·ªáu (Data Acquisition):</strong> L·∫•y d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.</li>
<li><strong>Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing):</strong><ul>
<li>L√†m s·∫°ch d·ªØ li·ªáu: Lo·∫°i b·ªè c√°c gi√° tr·ªã kh√¥ng h·ª£p l·ªá, tr√πng l·∫∑p.</li>
<li>Chu·∫©n h√≥a d·ªØ li·ªáu: ƒê·∫£m b·∫£o t√≠nh nh·∫•t qu√°n c·ªßa d·ªØ li·ªáu.</li>
<li>T√≠nh to√°n c√°c thu·ªôc t√≠nh c·∫•u tr√∫c (Molecular Descriptors): S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c thu·ªôc t√≠nh h√≥a h·ªçc t·ª´ SMILES (Simplified Molecular Input Line Entry System).</li>
</ul>
</li>
<li><strong>L·ª±a ch·ªçn ƒë·∫∑c tr∆∞ng (Feature Selection):</strong> Ch·ªçn c√°c thu·ªôc t√≠nh quan tr·ªçng nh·∫•t ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh.</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh (Model Building):</strong> S·ª≠ d·ª•ng c√°c thu·∫≠t to√°n h·ªçc m√°y (v√≠ d·ª•: Random Forest, Support Vector Machines) ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n.</li>
<li><strong>ƒê√°nh gi√° m√¥ h√¨nh (Model Evaluation):</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°c ch·ªâ s·ªë ph√π h·ª£p (v√≠ d·ª•: RMSE, R^2).</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)</strong></p>
<p><strong>Ti·∫øng Anh (English):</strong></p>
<p>This analysis focuses on building a predictive model for compound activity based on their chemical structures. The process involves data acquisition from ChEMBL 35, preprocessing (cleaning, standardization), calculating molecular descriptors using RDKit, feature selection, model building using machine learning algorithms, and model evaluation.</p>
<p><strong>Ti·∫øng Vi·ªát (Vietnamese):</strong></p>
<p>Ph√¢n t√≠ch n√†y t·∫≠p trung v√†o vi·ªác x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng. Qu√° tr√¨nh n√†y bao g·ªìm thu th·∫≠p d·ªØ li·ªáu t·ª´ ChEMBL 35, ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (l√†m s·∫°ch, chu·∫©n h√≥a), t√≠nh to√°n c√°c thu·ªôc t√≠nh ph√¢n t·ª≠ b·∫±ng RDKit, l·ª±a ch·ªçn ƒë·∫∑c tr∆∞ng, x√¢y d·ª±ng m√¥ h√¨nh b·∫±ng c√°c thu·∫≠t to√°n h·ªçc m√°y, v√† ƒë√°nh gi√° m√¥ h√¨nh.</p>
<p><strong>3. Code SQL v√† Python (SQL and Python Code)</strong></p>
<p><strong>SQL (ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ ChEMBL 35):</strong></p>
<p><code>sql
-- Select 100 rows for demonstration purposes
SELECT DISTINCT
    act.molregno,
    act.standard_value,
    act.standard_units,
    act.standard_type,
    md.chembl_id,
    md.canonical_smiles
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'  -- You can change this to your desired activity type
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 0 -- Exclude zero values
  AND act.standard_value ~ '^[0-9\.]+$' -- Ensure standard_value is numeric
LIMIT 100;</code></p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li><code>SELECT DISTINCT</code>: Ch·ªçn c√°c h√†ng duy nh·∫•t.</li>
<li><code>act.molregno</code>: ID ph√¢n t·ª≠.</li>
<li><code>act.standard_value</code>: Gi√° tr·ªã ho·∫°t t√≠nh.</li>
<li><code>act.standard_units</code>: ƒê∆°n v·ªã ho·∫°t t√≠nh.</li>
<li><code>act.standard_type</code>: Lo·∫°i ho·∫°t t√≠nh (v√≠ d·ª•: IC50).</li>
<li><code>md.chembl_id</code>: ChEMBL ID.</li>
<li><code>md.canonical_smiles</code>: SMILES string (bi·ªÉu di·ªÖn c·∫•u tr√∫c h√≥a h·ªçc).</li>
<li><code>FROM activities act JOIN molecule_dictionary md ON act.molregno = md.molregno</code>: K·∫øt n·ªëi hai b·∫£ng <code>activities</code> v√† <code>molecule_dictionary</code> d·ª±a tr√™n <code>molregno</code>.</li>
<li><code>WHERE act.standard_type = 'IC50'</code>: L·ªçc theo lo·∫°i ho·∫°t t√≠nh.</li>
<li><code>AND act.standard_units = 'nM'</code>: L·ªçc theo ƒë∆°n v·ªã ho·∫°t t√≠nh.</li>
<li><code>AND act.standard_value IS NOT NULL</code>: Lo·∫°i b·ªè c√°c gi√° tr·ªã NULL.</li>
<li><code>AND act.standard_value &gt; 0</code>: Lo·∫°i b·ªè c√°c gi√° tr·ªã b·∫±ng 0.</li>
<li><code>AND act.standard_value ~ '^[0-9\.]+$'</code>: <strong>S·ª≠a l·ªói (Fixing the Error)</strong>: ƒê·∫£m b·∫£o r·∫±ng <code>standard_value</code> l√† m·ªôt s·ªë.  Bi·ªÉu th·ª©c ch√≠nh quy <code>^[0-9\.]+$</code> ki·ªÉm tra xem chu·ªói ch·ªâ ch·ª©a c√°c ch·ªØ s·ªë v√† d·∫•u ch·∫•m.</li>
<li><code>LIMIT 100</code>: Gi·ªõi h·∫°n k·∫øt qu·∫£ ·ªü 100 h√†ng.</li>
</ul>
<p><strong>Python (ƒë·ªÉ ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu v√† t√≠nh to√°n thu·ªôc t√≠nh):</strong></p>
<p>```python
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler</p>
<h1>Define base path</h1>
<p>base_path = '.'  # Adjust as needed</p>
<h1>File path to the CSV file</h1>
<p>csv_file_path = os.path.join(base_path, 'data', 'chembl_data.csv') # Replace 'chembl_data.csv' with your actual filename</p>
<h1>Load data from CSV</h1>
<p>try:
    df = pd.read_csv(csv_file_path)
    print("Data loaded successfully.")
except FileNotFoundError:
    print(f"Error: File not found at {csv_file_path}")
    exit()</p>
<h1>Data Cleaning and Preprocessing</h1>
<p>df = df.dropna(subset=['canonical_smiles', 'standard_value']) # Drop rows with missing SMILES or standard_value</p>
<h1>Convert standard_value to numeric and filter out non-numeric values</h1>
<p>df = df[pd.to_numeric(df['standard_value'], errors='coerce').notna()]
df['standard_value'] = pd.to_numeric(df['standard_value'])</p>
<h1>Function to calculate molecular descriptors using RDKit</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    for name, func in Descriptors.descList:
        try:
            descriptors[name] = func(mol)
        except:
            descriptors[name] = np.nan  # Handle potential errors during descriptor calculation
    return pd.Series(descriptors)</p>
<h1>Apply the descriptor calculation to each SMILES string</h1>
<p>descriptors_df = df['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Merge descriptors with the main dataframe</h1>
<p>df = pd.concat([df, descriptors_df], axis=1)</p>
<h1>Remove rows with NaN values in descriptors</h1>
<p>df = df.dropna(axis=0)</p>
<h1>Feature Selection (Example: Select top 10 descriptors)</h1>
<h1>You can use more sophisticated feature selection techniques here</h1>
<p>X = df.drop(columns=['molregno', 'chembl_id', 'canonical_smiles', 'standard_units', 'standard_type'])
y = df['standard_value']</p>
<h1>Scale the features</h1>
<p>scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)</p>
<h1>Model Building (Random Forest Regressor)</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)  # You can adjust hyperparameters
model.fit(X_train, y_train)</p>
<h1>Model Evaluation</h1>
<p>y_pred = model.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"RMSE: {rmse}")
print(f"R^2: {r2}")
```</p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li><strong>Import Libraries:</strong> Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt.</li>
<li><strong>Load Data:</strong> T·∫£i d·ªØ li·ªáu t·ª´ file CSV.</li>
<li><strong>Data Cleaning:</strong> Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã <code>NaN</code> trong c·ªôt <code>canonical_smiles</code> v√† <code>standard_value</code>.</li>
<li><strong>Descriptor Calculation:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c thu·ªôc t√≠nh ph√¢n t·ª≠ t·ª´ SMILES string.</li>
<li><strong>Feature Selection:</strong> Ch·ªçn c√°c thu·ªôc t√≠nh quan tr·ªçng nh·∫•t (v√≠ d·ª•: s·ª≠ d·ª•ng SelectKBest).</li>
<li><strong>Data Scaling:</strong> Chu·∫©n h√≥a d·ªØ li·ªáu b·∫±ng StandardScaler.</li>
<li><strong>Model Building:</strong> X√¢y d·ª±ng m√¥ h√¨nh Random Forest Regressor.</li>
<li><strong>Model Evaluation:</strong> ƒê√°nh gi√° m√¥ h√¨nh b·∫±ng RMSE v√† R^2.</li>
</ul>
<p><strong>4. V√≠ d·ª• Code SQL v√† Python m·∫´u (Example SQL and Python Code)</strong></p>
<p><strong>V√≠ d·ª• 1: L·ªçc theo m·ª•c ti√™u c·ª• th·ªÉ (Filtering by Specific Target)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
SELECT DISTINCT
    act.molregno,
    act.standard_value,
    act.standard_units,
    act.standard_type,
    md.chembl_id,
    md.canonical_smiles
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
JOIN target_dictionary td ON act.tid = td.tid
WHERE td.chembl_id = 'CHEMBL205'  -- Example target: 'CHEMBL205' (e.g., Dopamine D4 receptor)
  AND act.standard_type = 'Ki'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 0
  AND act.standard_value ~ '^[0-9\.]+$'
LIMIT 100;</code></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>After loading data, filter based on a specific range of activity values</h1>
<p>df_filtered = df[(df['standard_value'] &gt;= 100) &amp; (df['standard_value'] &lt;= 1000)]
print(f"Number of compounds after filtering: {len(df_filtered)}")
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n thu·ªôc t√≠nh LogP (Calculating LogP)</strong></p>
<p><strong>Python:</strong></p>
<p>```python
from rdkit.Chem import AllChem
from rdkit.Chem import Crippen</p>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    return Crippen.MolLogP(mol)</p>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)
df = df.dropna(subset=['logp'])
print(df[['canonical_smiles', 'logp']].head())
```</p>
<p><strong>V√≠ d·ª• 3: S·ª≠ d·ª•ng Support Vector Regression (Using Support Vector Regression)</strong></p>
<p><strong>Python:</strong></p>
<p>```python
from sklearn.svm import SVR</p>
<h1>Model Building (Support Vector Regression)</h1>
<p>model = SVR(kernel='rbf')  # You can adjust hyperparameters
model.fit(X_train, y_train)</p>
<h1>Model Evaluation</h1>
<p>y_pred = model.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"RMSE (SVR): {rmse}")
print(f"R^2 (SVR): {r2}")
```</p>
<p><strong>V√≠ d·ª• 4: L∆∞u k·∫øt qu·∫£ v√†o file CSV (Saving Results to CSV)</strong></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>After model evaluation, save the predictions to a CSV file</h1>
<p>results = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
results.to_csv(os.path.join(base_path, 'data', 'predictions.csv'), index=False)
```</p>
<p><strong>V√≠ d·ª• 5: L·ªçc theo ho·∫°t t√≠nh (Filtering by Activity values)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
SELECT DISTINCT
    act.molregno,
    act.standard_value,
    act.standard_units,
    act.standard_type,
    md.chembl_id,
    md.canonical_smiles
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'  -- You can change this to your desired activity type
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value &gt; 10 and  act.standard_value &lt; 100 -- Exclude zero values
  AND act.standard_value ~ '^[0-9\.]+$' -- Ensure standard_value is numeric
LIMIT 100;</code></p>
<p>T√¥i hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n b·∫Øt ƒë·∫ßu d·ª± √°n c·ªßa m√¨nh m·ªôt c√°ch hi·ªáu qu·∫£. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi!</p>
        </body>
        </html>
        