
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_53</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Ph√¢n t·ª≠ kh√°ng virus t∆∞∆°ng ·ª©ng v·ªõi ƒë√≠ch COVID-19</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. V·ªõi vai tr√≤ l√† chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n nh·ªØng ph√¢n t√≠ch, h∆∞·ªõng d·∫´n v√† m√£ ngu·ªìn m·∫´u ƒë·ªÉ b·∫°n c√≥ th·ªÉ ti·∫øn h√†nh d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.</p>
<p><strong>Ph√¢n t√≠ch t·ªïng quan</strong></p>
<p>D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, m·ªôt ngu·ªìn t√†i nguy√™n v√¥ gi√° trong lƒ©nh v·ª±c ph√°t tri·ªÉn thu·ªëc. Vi·ªác k·∫øt h·ª£p ChEMBL v·ªõi RDKit, m·ªôt b·ªô c√¥ng c·ª• h√≥a tin h·ªçc m·∫°nh m·∫Ω, cho ph√©p b·∫°n th·ª±c hi·ªán c√°c ph√¢n t√≠ch s√¢u s·∫Øc v·ªÅ c·∫•u tr√∫c ph√¢n t·ª≠, t√≠nh ch·∫•t h√≥a l√Ω v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t.</p>
<p><strong>M·ª•c ti√™u c·ªßa d·ª± √°n:</strong></p>
<ul>
<li><strong>Thu th·∫≠p d·ªØ li·ªáu:</strong> L·∫•y d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 b·∫±ng c√°c truy v·∫•n SQL.</li>
<li><strong>Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu:</strong> L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu, lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá v√† x·ª≠ l√Ω c√°c gi√° tr·ªã thi·∫øu.</li>
<li><strong>T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠, m√¥ t·∫£ c√°c ƒë·∫∑c t√≠nh c·∫•u tr√∫c v√† h√≥a l√Ω c·ªßa c√°c h·ª£p ch·∫•t.</li>
<li><strong>Ph√¢n t√≠ch d·ªØ li·ªáu:</strong> √Åp d·ª•ng c√°c k·ªπ thu·∫≠t th·ªëng k√™ v√† h·ªçc m√°y ƒë·ªÉ kh√°m ph√° c√°c m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c ph√¢n t·ª≠, t√≠nh ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh:</strong> X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c c·ªßa ch√∫ng.</li>
<li><strong>Tr·ª±c quan h√≥a d·ªØ li·ªáu:</strong> S·ª≠ d·ª•ng c√°c c√¥ng c·ª• tr·ª±c quan h√≥a ƒë·ªÉ tr√¨nh b√†y k·∫øt qu·∫£ ph√¢n t√≠ch m·ªôt c√°ch r√µ r√†ng v√† d·ªÖ hi·ªÉu.</li>
</ul>
<p><strong>1. Ph√¢n t√≠ch v√† m√¥ h√¨nh ph√¢n t√≠ch</strong></p>
<p>Ch√∫ng ta s·∫Ω t·∫≠p trung v√†o vi·ªác x√¢y d·ª±ng m·ªôt quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t. D∆∞·ªõi ƒë√¢y l√† m√¥ h√¨nh ph√¢n t√≠ch chi ti·∫øt:</p>
<p><strong>B∆∞·ªõc 1: Thu th·∫≠p d·ªØ li·ªáu (Data Acquisition)</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> L·∫•y d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, bao g·ªìm th√¥ng tin v·ªÅ c·∫•u tr√∫c ph√¢n t·ª≠ (SMILES), ho·∫°t t√≠nh sinh h·ªçc (IC50, Ki, EC50, v.v.) v√† c√°c thu·ªôc t√≠nh li√™n quan kh√°c.</li>
<li><strong>C√¥ng c·ª•:</strong> SQL, psycopg2 (Python library for PostgreSQL).</li>
<li><strong>ƒê·∫ßu ra:</strong> M·ªôt t·∫≠p d·ªØ li·ªáu ch·ª©a th√¥ng tin v·ªÅ c√°c h·ª£p ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng.</li>
</ul>
<p><strong>B∆∞·ªõc 2: Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing)</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng v√† t√≠nh nh·∫•t qu√°n.</li>
<li><strong>C√¥ng c·ª•:</strong> Pandas (Python library for data manipulation), RDKit.</li>
<li><strong>C√°c b∆∞·ªõc:</strong><ul>
<li>Lo·∫°i b·ªè c√°c h·ª£p ch·∫•t tr√πng l·∫∑p.</li>
<li>Chu·∫©n h√≥a chu·ªói SMILES.</li>
<li>X·ª≠ l√Ω c√°c gi√° tr·ªã ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: chuy·ªÉn ƒë·ªïi IC50 sang pIC50).</li>
<li>Lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá ho·∫∑c kh√¥ng h·ª£p l·ªá.</li>
</ul>
</li>
</ul>
<p><strong>B∆∞·ªõc 3: T√≠nh to√°n descriptor ph√¢n t·ª≠ (Molecular Descriptor Calculation)</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ t·ª´ c·∫•u tr√∫c c·ªßa c√°c h·ª£p ch·∫•t.</li>
<li><strong>C√¥ng c·ª•:</strong> RDKit.</li>
<li><strong>C√°c descriptor:</strong><ul>
<li>C√°c descriptor 2D: Molecular Weight, LogP, Topological Polar Surface Area (TPSA).</li>
<li>C√°c descriptor d·ª±a tr√™n fragments: Murcko Fragments.</li>
<li>C√°c descriptor kh√°c: S·ªë l∆∞·ª£ng v√≤ng, s·ªë l∆∞·ª£ng nguy√™n t·ª≠, v.v.</li>
</ul>
</li>
</ul>
<p><strong>B∆∞·ªõc 4: Ph√¢n t√≠ch d·ªØ li·ªáu v√† x√¢y d·ª±ng m√¥ h√¨nh (Data Analysis and Model Building)</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> X√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c√°c descriptor ph√¢n t·ª≠.</li>
<li><strong>C√¥ng c·ª•:</strong> Scikit-learn (Python library for machine learning).</li>
<li><strong>C√°c thu·∫≠t to√°n:</strong><ul>
<li>H·ªìi quy tuy·∫øn t√≠nh (Linear Regression).</li>
<li>M√°y vector h·ªó tr·ª£ (Support Vector Machine - SVM).</li>
<li>R·ª´ng ng·∫´u nhi√™n (Random Forest).</li>
<li>M·∫°ng n∆°-ron (Neural Networks).</li>
</ul>
</li>
<li><strong>ƒê√°nh gi√° m√¥ h√¨nh:</strong> S·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t ƒë√°nh gi√° m√¥ h√¨nh ph√π h·ª£p (v√≠ d·ª•: cross-validation, R-squared, RMSE) ƒë·ªÉ ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa c√°c m√¥ h√¨nh.</li>
</ul>
<p><strong>B∆∞·ªõc 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu (Data Visualization)</strong></p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> Tr√¨nh b√†y k·∫øt qu·∫£ ph√¢n t√≠ch m·ªôt c√°ch r√µ r√†ng v√† d·ªÖ hi·ªÉu.</li>
<li><strong>C√¥ng c·ª•:</strong> Matplotlib, Seaborn (Python libraries for data visualization).</li>
<li><strong>C√°c lo·∫°i bi·ªÉu ƒë·ªì:</strong><ul>
<li>Bi·ªÉu ƒë·ªì ph√¢n t√°n (Scatter plots) ƒë·ªÉ hi·ªÉn th·ªã m·ªëi quan h·ªá gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
<li>Bi·ªÉu ƒë·ªì h·ªôp (Box plots) ƒë·ªÉ so s√°nh ph√¢n ph·ªëi c·ªßa c√°c descriptor gi·ªØa c√°c nh√≥m h·ª£p ch·∫•t kh√°c nhau.</li>
<li>Bi·ªÉu ƒë·ªì quan tr·ªçng t√≠nh nƒÉng (Feature importance plots) ƒë·ªÉ x√°c ƒë·ªãnh c√°c descriptor quan tr·ªçng nh·∫•t trong m√¥ h√¨nh.</li>
</ul>
</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt b·∫±ng c·∫£ ti·∫øng Anh v√† ti·∫øng Vi·ªát cho t·ª´ng b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch:</p>
<p><strong>B∆∞·ªõc 1: Thu th·∫≠p d·ªØ li·ªáu (Data Acquisition)</strong></p>
<ul>
<li><strong>English:</strong><ol>
<li>Connect to the ChEMBL 35 database using <code>psycopg2</code>.</li>
<li>Execute SQL queries to retrieve the necessary data (e.g., compound structures, activity data).</li>
<li>Save the data to a CSV file.</li>
</ol>
</li>
<li><strong>Ti·∫øng Vi·ªát:</strong><ol>
<li>K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 b·∫±ng <code>psycopg2</code>.</li>
<li>Th·ª±c thi c√°c truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu c·∫ßn thi·∫øt (v√≠ d·ª•: c·∫•u tr√∫c h·ª£p ch·∫•t, d·ªØ li·ªáu ho·∫°t t√≠nh).</li>
<li>L∆∞u d·ªØ li·ªáu v√†o m·ªôt file CSV.</li>
</ol>
</li>
</ul>
<p><strong>B∆∞·ªõc 2: Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing)</strong></p>
<ul>
<li><strong>English:</strong><ol>
<li>Load the CSV file into a Pandas DataFrame.</li>
<li>Remove duplicate compounds.</li>
<li>Standardize SMILES strings using RDKit.</li>
<li>Convert activity values (e.g., IC50) to pIC50.</li>
<li>Remove outliers or invalid values.</li>
</ol>
</li>
<li><strong>Ti·∫øng Vi·ªát:</strong><ol>
<li>T·∫£i file CSV v√†o m·ªôt Pandas DataFrame.</li>
<li>Lo·∫°i b·ªè c√°c h·ª£p ch·∫•t tr√πng l·∫∑p.</li>
<li>Chu·∫©n h√≥a chu·ªói SMILES b·∫±ng RDKit.</li>
<li>Chuy·ªÉn ƒë·ªïi gi√° tr·ªã ho·∫°t t√≠nh (v√≠ d·ª•: IC50) sang pIC50.</li>
<li>Lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá ho·∫∑c kh√¥ng h·ª£p l·ªá.</li>
</ol>
</li>
</ul>
<p><strong>B∆∞·ªõc 3: T√≠nh to√°n descriptor ph√¢n t·ª≠ (Molecular Descriptor Calculation)</strong></p>
<ul>
<li><strong>English:</strong><ol>
<li>Use RDKit to calculate molecular descriptors for each compound.</li>
<li>Calculate 2D descriptors (e.g., Molecular Weight, LogP, TPSA).</li>
<li>Calculate fragment-based descriptors (e.g., Murcko Fragments).</li>
<li>Add the descriptors to the Pandas DataFrame.</li>
</ol>
</li>
<li><strong>Ti·∫øng Vi·ªát:</strong><ol>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ cho m·ªói h·ª£p ch·∫•t.</li>
<li>T√≠nh to√°n c√°c descriptor 2D (v√≠ d·ª•: Molecular Weight, LogP, TPSA).</li>
<li>T√≠nh to√°n c√°c descriptor d·ª±a tr√™n fragments (v√≠ d·ª•: Murcko Fragments).</li>
<li>Th√™m c√°c descriptor v√†o Pandas DataFrame.</li>
</ol>
</li>
</ul>
<p><strong>B∆∞·ªõc 4: Ph√¢n t√≠ch d·ªØ li·ªáu v√† x√¢y d·ª±ng m√¥ h√¨nh (Data Analysis and Model Building)</strong></p>
<ul>
<li><strong>English:</strong><ol>
<li>Split the data into training and testing sets.</li>
<li>Train a machine learning model (e.g., Linear Regression, SVM, Random Forest) using the training data.</li>
<li>Evaluate the model's performance on the testing data.</li>
</ol>
</li>
<li><strong>Ti·∫øng Vi·ªát:</strong><ol>
<li>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.</li>
<li>Hu·∫•n luy·ªán m·ªôt m√¥ h√¨nh h·ªçc m√°y (v√≠ d·ª•: Linear Regression, SVM, Random Forest) s·ª≠ d·ª•ng d·ªØ li·ªáu hu·∫•n luy·ªán.</li>
<li>ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh tr√™n d·ªØ li·ªáu ki·ªÉm tra.</li>
</ol>
</li>
</ul>
<p><strong>B∆∞·ªõc 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu (Data Visualization)</strong></p>
<ul>
<li><strong>English:</strong><ol>
<li>Use Matplotlib and Seaborn to create visualizations of the data and model results.</li>
<li>Create scatter plots, box plots, and feature importance plots.</li>
</ol>
</li>
<li><strong>Ti·∫øng Vi·ªát:</strong><ol>
<li>S·ª≠ d·ª•ng Matplotlib v√† Seaborn ƒë·ªÉ t·∫°o c√°c h√¨nh ·∫£nh tr·ª±c quan v·ªÅ d·ªØ li·ªáu v√† k·∫øt qu·∫£ m√¥ h√¨nh.</li>
<li>T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n, bi·ªÉu ƒë·ªì h·ªôp v√† bi·ªÉu ƒë·ªì quan tr·ªçng t√≠nh nƒÉng.</li>
</ol>
</li>
</ul>
<p><strong>3. Code SQL v√† Python (SQL and Python Code)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† c√°c v√≠ d·ª• v·ªÅ code SQL v√† Python ƒë·ªÉ th·ª±c hi·ªán c√°c b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch. T√¥i s·∫Ω t·∫≠p trung v√†o vi·ªác kh·∫Øc ph·ª•c c√°c l·ªói b·∫°n ƒë√£ ƒë·ªÅ c·∫≠p.</p>
<p><strong>a. SQL Code (Data Acquisition)</strong></p>
<p>```sql
-- English
-- Select 100 compounds with activity data
SELECT DISTINCT ON (molregno)
    md.molregno,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'  -- You can change this to other activity types
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value::text ~ '^[0-9.]+$'  -- Corrected line
ORDER BY molregno
LIMIT 100;</p>
<p>-- Vietnamese
-- Ch·ªçn 100 h·ª£p ch·∫•t c√≥ d·ªØ li·ªáu ho·∫°t t√≠nh
SELECT DISTINCT ON (molregno)
    md.molregno,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'  -- B·∫°n c√≥ th·ªÉ thay ƒë·ªïi th√†nh lo·∫°i ho·∫°t t√≠nh kh√°c
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value::text ~ '^[0-9.]+$'  -- D√≤ng ƒë√£ s·ª≠a
ORDER BY molregno
LIMIT 100;
```</p>
<p><strong>Gi·∫£i th√≠ch l·ªói v√† c√°ch s·ª≠a:</strong></p>
<ul>
<li><strong>L·ªói:</strong> <code>ERROR: operator does not exist: numeric ~ unknown, LINE 12: AND act.standard_value ~ '^[0-9\.]+$'</code></li>
<li><strong>Nguy√™n nh√¢n:</strong> To√°n t·ª≠ <code>~</code> trong PostgreSQL ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ so s√°nh m·ªôt chu·ªói v·ªõi m·ªôt regular expression. Trong tr∆∞·ªùng h·ª£p n√†y, <code>act.standard_value</code> c√≥ ki·ªÉu d·ªØ li·ªáu l√† <code>numeric</code>, kh√¥ng ph·∫£i l√† <code>text</code>.</li>
<li><strong>C√°ch s·ª≠a:</strong> √âp ki·ªÉu <code>act.standard_value</code> v·ªÅ <code>text</code> b·∫±ng c√°ch s·ª≠ d·ª•ng <code>act.standard_value::text</code>.</li>
</ul>
<p><strong>b. Python Code (Data Preprocessing and Descriptor Calculation)</strong></p>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
import os</p>
<p>base_path = "../data"  # Adjust as needed</p>
<p>def calculate_descriptors(smiles):
    """Calculates molecular descriptors using RDKit."""
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    descriptors['Molecular Weight'] = Descriptors.MolWt(mol)
    descriptors['LogP'] = Chem.Crippen.MolLogP(mol)
    descriptors['TPSA'] = Chem.rdMolDescriptors.CalcTPSA(mol)
    return descriptors</p>
<h1>Load data</h1>
<p>data = pd.read_csv(os.path.join(base_path, "chembl_data.csv"))  # Replace with your CSV file</p>
<h1>Handle missing SMILES</h1>
<p>data = data.dropna(subset=['canonical_smiles'])</p>
<h1>Calculate descriptors</h1>
<p>data['descriptors'] = data['canonical_smiles'].apply(calculate_descriptors)
data = data.dropna(subset=['descriptors'])
data = data[data['descriptors'].notna()]</p>
<h1>Convert descriptors to columns</h1>
<p>data = pd.concat([data.drop(['descriptors'], axis=1), data['descriptors'].apply(pd.Series)], axis=1)</p>
<h1>Convert IC50 to pIC50</h1>
<p>def ic50_to_pic50(ic50):
    """Converts IC50 to pIC50."""
    if pd.isna(ic50):
        return np.nan
    ic50 = float(ic50)
    if ic50 &lt;= 0:
        return np.nan
    pIC50 = -np.log10(ic50 / 1e9)
    return pIC50</p>
<p>data['pIC50'] = data['standard_value'].apply(ic50_to_pic50)</p>
<h1>Display the first few rows</h1>
<p>print(data.head())</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
import os</p>
<p>base_path = "../data"  # ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn</p>
<p>def tinh_toan_descriptor(smiles):
    """T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ s·ª≠ d·ª•ng RDKit."""
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    descriptors['Molecular Weight'] = Descriptors.MolWt(mol)
    descriptors['LogP'] = Chem.Crippen.MolLogP(mol)
    descriptors['TPSA'] = Chem.rdMolDescriptors.CalcTPSA(mol)
    return descriptors</p>
<h1>T·∫£i d·ªØ li·ªáu</h1>
<p>data = pd.read_csv(os.path.join(base_path, "chembl_data.csv"))  # Thay th·∫ø b·∫±ng file CSV c·ªßa b·∫°n</p>
<h1>X·ª≠ l√Ω SMILES b·ªã thi·∫øu</h1>
<p>data = data.dropna(subset=['canonical_smiles'])</p>
<h1>T√≠nh to√°n c√°c descriptor</h1>
<p>data['descriptors'] = data['canonical_smiles'].apply(tinh_toan_descriptor)
data = data.dropna(subset=['descriptors'])
data = data[data['descriptors'].notna()]</p>
<h1>Chuy·ªÉn descriptor th√†nh c√°c c·ªôt</h1>
<p>data = pd.concat([data.drop(['descriptors'], axis=1), data['descriptors'].apply(pd.Series)], axis=1)</p>
<h1>Chuy·ªÉn ƒë·ªïi IC50 sang pIC50</h1>
<p>def ic50_sang_pic50(ic50):
    """Chuy·ªÉn ƒë·ªïi IC50 sang pIC50."""
    if pd.isna(ic50):
        return np.nan
    ic50 = float(ic50)
    if ic50 &lt;= 0:
        return np.nan
    pIC50 = -np.log10(ic50 / 1e9)
    return pIC50</p>
<p>data['pIC50'] = data['standard_value'].apply(ic50_sang_pic50)</p>
<h1>Hi·ªÉn th·ªã m·ªôt v√†i d√≤ng ƒë·∫ßu ti√™n</h1>
<p>print(data.head())
```</p>
<p><strong>c. Python Code (Model Building)</strong></p>
<p>```python</p>
<h1>English</h1>
<p>from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler</p>
<h1>Select features and target</h1>
<p>features = ['Molecular Weight', 'LogP', 'TPSA']  # Add more features as needed
target = 'pIC50'</p>
<h1>Handle missing values</h1>
<p>data = data.dropna(subset=features + [target])</p>
<h1>Scale features</h1>
<p>scaler = StandardScaler()
X = scaler.fit_transform(data[features])
y = data[target]</p>
<h1>Split data</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Train model</h1>
<p>model = LinearRegression()
model.fit(X_train, y_train)</p>
<h1>Evaluate model</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")</p>
<h1>Vietnamese</h1>
<p>from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler</p>
<h1>Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng v√† m·ª•c ti√™u</h1>
<p>features = ['Molecular Weight', 'LogP', 'TPSA']  # Th√™m c√°c ƒë·∫∑c tr∆∞ng kh√°c n·∫øu c·∫ßn
target = 'pIC50'</p>
<h1>X·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu</h1>
<p>data = data.dropna(subset=features + [target])</p>
<h1>Chu·∫©n h√≥a c√°c ƒë·∫∑c tr∆∞ng</h1>
<p>scaler = StandardScaler()
X = scaler.fit_transform(data[features])
y = data[target]</p>
<h1>Chia d·ªØ li·ªáu</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh</h1>
<p>model = LinearRegression()
model.fit(X_train, y_train)</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>Gi·∫£i th√≠ch l·ªói v√† c√°ch s·ª≠a:</strong></p>
<ul>
<li><strong>L·ªói:</strong> <code>ValueError:</code>squared<code>is deprecated and will be removed in scikit-learn 1.4. Use</code>squared=False` if you want to calculate the root mean squared error.</li>
<li><strong>Nguy√™n nh√¢n:</strong> Phi√™n b·∫£n scikit-learn c·ªßa b·∫°n c≈© v√† kh√¥ng h·ªó tr·ª£ tham s·ªë <code>squared=False</code> trong h√†m <code>mean_squared_error</code>.</li>
<li><strong>C√°ch s·ª≠a:</strong> N√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t b·∫±ng l·ªánh <code>pip install -U scikit-learn</code>. N·∫øu kh√¥ng th·ªÉ n√¢ng c·∫•p, b·∫°n c√≥ th·ªÉ t√≠nh RMSE b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE: <code>rmse = mean_squared_error(y_test, y_pred, squared=False)</code>. Tuy nhi√™n, t√¥i khuy·∫øn kh√≠ch b·∫°n n√¢ng c·∫•p scikit-learn ƒë·ªÉ t·∫≠n d·ª•ng c√°c t√≠nh nƒÉng m·ªõi nh·∫•t v√† s·ª≠a l·ªói.</li>
</ul>
<p><strong>4. V√≠ d·ª• Code SQL v√† Python m·∫´u</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• kh√°c nhau v·ªÅ code SQL v√† Python ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>V√≠ d·ª• 1: L·ªçc c√°c h·ª£p ch·∫•t d·ª±a tr√™n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Filtering compounds based on molecular weight)</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p>```sql
-- English
SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    md.mw_freebase BETWEEN 200 AND 400
LIMIT 100;</p>
<p>-- Vietnamese
SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    md.mw_freebase BETWEEN 200 AND 400
LIMIT 100;
```</p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem</p>
<h1>Load data (replace with your actual loading method)</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>Function to calculate molecular weight using RDKit</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Chem.Descriptors.MolWt(mol)
    return None</p>
<h1>Apply the function to calculate molecular weight</h1>
<p>data['MW'] = data['canonical_smiles'].apply(calculate_mw)</p>
<h1>Filter compounds with MW between 200 and 400</h1>
<p>filtered_data = data[(data['MW'] &gt;= 200) &amp; (data['MW'] &lt;= 400)]</p>
<p>print(filtered_data.head())</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
from rdkit import Chem</p>
<h1>T·∫£i d·ªØ li·ªáu (thay th·∫ø b·∫±ng ph∆∞∆°ng ph√°p t·∫£i d·ªØ li·ªáu th·ª±c t·∫ø c·ªßa b·∫°n)</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>H√†m t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ b·∫±ng RDKit</h1>
<p>def tinh_trong_luong_phan_tu(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Chem.Descriptors.MolWt(mol)
    return None</p>
<h1>√Åp d·ª•ng h√†m ƒë·ªÉ t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>data['MW'] = data['canonical_smiles'].apply(tinh_trong_luong_phan_tu)</p>
<h1>L·ªçc c√°c h·ª£p ch·∫•t c√≥ MW trong kho·∫£ng 200 v√† 400</h1>
<p>filtered_data = data[(data['MW'] &gt;= 200) &amp; (data['MW'] &lt;= 400)]</p>
<p>print(filtered_data.head())
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n s·ªë l∆∞·ª£ng v√≤ng (Calculating the number of rings)</strong></p>
<ul>
<li><strong>SQL:</strong> (Kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp trong SQL, c·∫ßn s·ª≠ d·ª•ng Python)</li>
<li><strong>Python:</strong></li>
</ul>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors</p>
<h1>Load data</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>Function to calculate the number of rings</h1>
<p>def calculate_num_rings(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return rdMolDescriptors.CalcNumRings(mol)
    return None</p>
<h1>Apply the function</h1>
<p>data['NumRings'] = data['canonical_smiles'].apply(calculate_num_rings)</p>
<p>print(data.head())</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors</p>
<h1>T·∫£i d·ªØ li·ªáu</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>H√†m t√≠nh to√°n s·ªë l∆∞·ª£ng v√≤ng</h1>
<p>def tinh_so_luong_vong(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return rdMolDescriptors.CalcNumRings(mol)
    return None</p>
<h1>√Åp d·ª•ng h√†m</h1>
<p>data['NumRings'] = data['canonical_smiles'].apply(tinh_so_luong_vong)</p>
<p>print(data.head())
```</p>
<p><strong>V√≠ d·ª• 3: Ph√¢n t√≠ch ho·∫°t t√≠nh sinh h·ªçc (Analyzing activity data)</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p>```sql
-- English
SELECT
    act.standard_type,
    AVG(act.standard_value) AS average_value,
    COUNT(*) AS num_measurements
FROM
    activities act
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')
    AND act.standard_value IS NOT NULL
GROUP BY
    act.standard_type;</p>
<p>-- Vietnamese
SELECT
    act.standard_type,
    AVG(act.standard_value) AS average_value,
    COUNT(*) AS num_measurements
FROM
    activities act
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')
    AND act.standard_value IS NOT NULL
GROUP BY
    act.standard_type;
```</p>
<ul>
<li><strong>Python:</strong> (C√≥ th·ªÉ d√πng ƒë·ªÉ tr·ª±c quan h√≥a k·∫øt qu·∫£)</li>
</ul>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
import matplotlib.pyplot as plt</p>
<h1>Load data (assuming you have activity data in a CSV)</h1>
<p>data = pd.read_csv("chembl_data.csv")</p>
<h1>Group by standard_type and calculate the mean standard_value</h1>
<p>activity_summary = data.groupby('standard_type')['standard_value'].mean()</p>
<h1>Plot the activity summary</h1>
<p>activity_summary.plot(kind='bar')
plt.title('Average Activity Values by Standard Type')
plt.xlabel('Standard Type')
plt.ylabel('Average Standard Value')
plt.show()</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
import matplotlib.pyplot as plt</p>
<h1>T·∫£i d·ªØ li·ªáu (gi·∫£ s·ª≠ b·∫°n c√≥ d·ªØ li·ªáu ho·∫°t t√≠nh trong m·ªôt file CSV)</h1>
<p>data = pd.read_csv("chembl_data.csv")</p>
<h1>Nh√≥m theo standard_type v√† t√≠nh gi√° tr·ªã trung b√¨nh c·ªßa standard_value</h1>
<p>activity_summary = data.groupby('standard_type')['standard_value'].mean()</p>
<h1>V·∫Ω bi·ªÉu ƒë·ªì t√≥m t·∫Øt ho·∫°t t√≠nh</h1>
<p>activity_summary.plot(kind='bar')
plt.title('Gi√° tr·ªã Ho·∫°t t√≠nh Trung b√¨nh theo Lo·∫°i Ti√™u chu·∫©n')
plt.xlabel('Lo·∫°i Ti√™u chu·∫©n')
plt.ylabel('Gi√° tr·ªã Ti√™u chu·∫©n Trung b√¨nh')
plt.show()
```</p>
<p><strong>V√≠ d·ª• 4: S·ª≠ d·ª•ng Random Forest ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh (Using Random Forest for activity prediction)</strong></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Load data and calculate descriptors (as shown in previous examples)</h1>
<h1>Assuming 'data' DataFrame is already prepared</h1>
<h1>Prepare data</h1>
<p>features = ['Molecular Weight', 'LogP', 'TPSA']  # Adjust based on your available descriptors
target = 'pIC50'</p>
<p>data = data.dropna(subset=features + [target])</p>
<p>X = data[features]
y = data[target]</p>
<h1>Split data</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Train Random Forest model</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>Evaluate model</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>T·∫£i d·ªØ li·ªáu v√† t√≠nh to√°n descriptor (nh∆∞ trong c√°c v√≠ d·ª• tr∆∞·ªõc)</h1>
<h1>Gi·∫£ s·ª≠ DataFrame 'data' ƒë√£ ƒë∆∞·ª£c chu·∫©n b·ªã</h1>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu</h1>
<p>features = ['Molecular Weight', 'LogP', 'TPSA']  # ƒêi·ªÅu ch·ªânh d·ª±a tr√™n c√°c descriptor c√≥ s·∫µn
target = 'pIC50'</p>
<p>data = data.dropna(subset=features + [target])</p>
<p>X = data[features]
y = data[target]</p>
<h1>Chia d·ªØ li·ªáu</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>V√≠ d·ª• 5: T√≠nh to√°n Murcko Fragments (Calculating Murcko Fragments)</strong></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python</p>
<h1>English</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import MurckoFragment</p>
<h1>Load data</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>Function to calculate Murcko Fragment</h1>
<p>def calculate_murcko(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        core = MurckoFragment.GetMurckoFragment(mol)
        return Chem.MolToSmiles(core)
    return None</p>
<h1>Apply the function</h1>
<p>data['MurckoFragment'] = data['canonical_smiles'].apply(calculate_murcko)</p>
<p>print(data.head())</p>
<h1>Vietnamese</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import MurckoFragment</p>
<h1>T·∫£i d·ªØ li·ªáu</h1>
<p>data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])</p>
<h1>H√†m t√≠nh to√°n Murcko Fragment</h1>
<p>def tinh_murcko(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        core = MurckoFragment.GetMurckoFragment(mol)
        return Chem.MolToSmiles(core)
    return None</p>
<h1>√Åp d·ª•ng h√†m</h1>
<p>data['MurckoFragment'] = data['canonical_smiles'].apply(tinh_murcko)</p>
<p>print(data.head())
```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li>ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√†i ƒë·∫∑t t·∫•t c·∫£ c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt (RDKit, Pandas, Scikit-learn, Matplotlib, Seaborn). B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng <code>pip install rdkit pandas scikit-learn matplotlib seaborn</code> ƒë·ªÉ c√†i ƒë·∫∑t ch√∫ng.</li>
<li>ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n file v√† t√™n c·ªôt cho ph√π h·ª£p v·ªõi d·ªØ li·ªáu c·ªßa b·∫°n.</li>
<li>C√°c v√≠ d·ª• tr√™n ch·ªâ l√† ƒëi·ªÉm kh·ªüi ƒë·∫ßu. B·∫°n c√≥ th·ªÉ t√πy ch·ªânh v√† m·ªü r·ªông ch√∫ng ƒë·ªÉ ph√π h·ª£p v·ªõi nhu c·∫ßu c·ª• th·ªÉ c·ªßa d·ª± √°n.</li>
</ul>
<p>T√¥i hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n ti·∫øn h√†nh d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 m·ªôt c√°ch hi·ªáu qu·∫£. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi! Ch√∫c b·∫°n th√†nh c√¥ng!</p>
        </body>
        </html>
        