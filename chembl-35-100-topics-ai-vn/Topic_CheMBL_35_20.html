
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_20</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: So s√°nh khung h√≥a h·ªçc ChEMBL v·ªõi thu·ªëc FDA</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i hi·ªÉu r√µ t·∫ßm quan tr·ªçng c·ªßa vi·ªác khai th√°c d·ªØ li·ªáu Chembl ƒë·ªÉ t√¨m ki·∫øm c√°c ·ª©ng vi√™n ti·ªÅm nƒÉng cho thu·ªëc m·ªõi.</p>
<p>D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n song ng·ªØ, code m·∫´u SQL v√† Python, c√πng v·ªõi c√°c v√≠ d·ª• c·ª• th·ªÉ ƒë·ªÉ gi√∫p b·∫°n tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£:</p>
<p><strong>1. Ph√¢n t√≠ch M√¥ h√¨nh (Analysis Model)</strong></p>
<p>M·ª•c ti√™u c·ªßa ch·ªß ƒë·ªÅ "Topic_CheMBL_35_20" l√† g√¨? (What is the objective of "Topic_CheMBL_35_20"?)</p>
<p>Tr∆∞·ªõc khi ƒëi s√¢u v√†o code, ch√∫ng ta c·∫ßn x√°c ƒë·ªãnh r√µ m·ª•c ti√™u c·ªßa ch·ªß ƒë·ªÅ "Topic_CheMBL_35_20". V√≠ d·ª•, b·∫°n c√≥ th·ªÉ mu·ªën:</p>
<ul>
<li><strong>D·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t:</strong> X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh (v√≠ d·ª•: IC50, Ki) c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng. (Predict compound activity: Build a model to predict the activity (e.g., IC50, Ki) of compounds based on their chemical structure.)</li>
<li><strong>T√¨m ki·∫øm c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª±:</strong> X√°c ƒë·ªãnh c√°c h·ª£p ch·∫•t c√≥ c·∫•u tr√∫c t∆∞∆°ng t·ª± v·ªõi m·ªôt h·ª£p ch·∫•t m·ª•c ti√™u v√† c√≥ kh·∫£ nƒÉng c√≥ ho·∫°t t√≠nh t∆∞∆°ng t·ª±. (Search for similar compounds: Identify compounds with similar structures to a target compound and likely to have similar activity.)</li>
<li><strong>Ph√¢n t√≠ch m·ªëi quan h·ªá c·∫•u tr√∫c-ho·∫°t t√≠nh (SAR):</strong> T√¨m hi·ªÉu m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc c·ªßa c√°c h·ª£p ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng. (Structure-Activity Relationship (SAR) Analysis: Understand the relationship between the chemical structure of compounds and their biological activity.)</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh QSAR:</strong> X√¢y d·ª±ng m√¥ h√¨nh ƒë·ªãnh l∆∞·ª£ng m·ªëi quan h·ªá c·∫•u tr√∫c-ho·∫°t t√≠nh (QSAR) ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t m·ªõi. (Build QSAR model: Building a quantitative structure-activity relationship (QSAR) model to predict the activity of new compounds.)</li>
</ul>
<p>D·ª±a tr√™n m·ª•c ti√™u n√†y, ch√∫ng ta s·∫Ω ch·ªçn c√°c ph∆∞∆°ng ph√°p v√† k·ªπ thu·∫≠t ph√¢n t√≠ch ph√π h·ª£p.</p>
<p><strong>V√≠ d·ª• (Example):</strong> Gi·∫£ s·ª≠ m·ª•c ti√™u c·ªßa b·∫°n l√† d·ª± ƒëo√°n ho·∫°t t√≠nh IC50 c·ªßa c√°c h·ª£p ch·∫•t ƒë·ªëi v·ªõi m·ªôt m·ª•c ti√™u c·ª• th·ªÉ (v√≠ d·ª•: enzyme).</p>
<p><strong>M√¥ h√¨nh ph√¢n t√≠ch (Analysis Model):</strong></p>
<ol>
<li><strong>Tr√≠ch xu·∫•t d·ªØ li·ªáu:</strong> L·∫•y d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu Chembl, bao g·ªìm th√¥ng tin v·ªÅ c·∫•u tr√∫c h√≥a h·ªçc (SMILES) v√† ho·∫°t t√≠nh IC50 c·ªßa c√°c h·ª£p ch·∫•t. (Extract data: Retrieve data from the Chembl database, including information on chemical structure (SMILES) and IC50 activity of compounds.)</li>
<li><strong>Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu:</strong> L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu, lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá v√† x·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu. (Data preprocessing: Clean and standardize the data, remove outliers, and handle missing values.)</li>
<li><strong>T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng (Features):</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc t·ª´ c·∫•u tr√∫c SMILES, ch·∫≥ng h·∫°n nh∆∞ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠, ƒë·ªô tan, s·ªë l∆∞·ª£ng li√™n k·∫øt, v.v. (Calculate features: Use RDKit to calculate chemical features from SMILES structures, such as molecular weight, solubility, number of bonds, etc.)</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh:</strong> S·ª≠ d·ª•ng c√°c thu·∫≠t to√°n h·ªçc m√°y (v√≠ d·ª•: Random Forest, Support Vector Machine) ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n IC50 d·ª±a tr√™n c√°c ƒë·∫∑c tr∆∞ng ƒë√£ t√≠nh to√°n. (Build a model: Use machine learning algorithms (e.g., Random Forest, Support Vector Machine) to build a model to predict IC50 based on the calculated features.)</li>
<li><strong>ƒê√°nh gi√° m√¥ h√¨nh:</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c ch·ªâ s·ªë ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE). (Evaluate the model: Evaluate the performance of the model using appropriate metrics (e.g., R-squared, RMSE).)</li>
</ol>
<p><strong>2. H∆∞·ªõng d·∫´n Song ng·ªØ (Bilingual Instructions)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n song ng·ªØ v·ªÅ c√°ch th·ª±c hi·ªán t·ª´ng b∆∞·ªõc trong m√¥ h√¨nh ph√¢n t√≠ch:</p>
<p>| B∆∞·ªõc (Step)                                    | Ti·∫øng Anh (English)                                                                                             | Ti·∫øng Vi·ªát (Vietnamese)                                                                                                                               |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Tr√≠ch xu·∫•t d·ªØ li·ªáu (Data Extraction)       | Extract relevant data from the Chembl database using SQL queries.                                                   | Tr√≠ch xu·∫•t d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu Chembl b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c truy v·∫•n SQL.                                                                |
| 2. Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing)    | Clean and prepare the data for analysis, handling missing values and outliers.                                    | L√†m s·∫°ch v√† chu·∫©n b·ªã d·ªØ li·ªáu cho ph√¢n t√≠ch, x·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu v√† ngo·∫°i l·ªá.                                                                    |
| 3. T√≠nh to√°n ƒë·∫∑c tr∆∞ng (Feature Calculation) | Use RDKit to calculate molecular descriptors from SMILES strings.                                                     | S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ t·ª´ chu·ªói SMILES.                                                                                           |
| 4. X√¢y d·ª±ng m√¥ h√¨nh (Model Building)          | Train a machine learning model to predict IC50 values based on the calculated features.                             | Hu·∫•n luy·ªán m·ªôt m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n gi√° tr·ªã IC50 d·ª±a tr√™n c√°c ƒë·∫∑c tr∆∞ng ƒë√£ t√≠nh to√°n.                                                              |
| 5. ƒê√°nh gi√° m√¥ h√¨nh (Model Evaluation)       | Evaluate the model's performance using metrics like R-squared and RMSE.                                             | ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c ch·ªâ s·ªë nh∆∞ R-squared v√† RMSE.                                                                     |</p>
<p><strong>3. Code M·∫´u SQL (SQL Code Example)</strong></p>
<p><code>sql
-- L·∫•y 100 d√≤ng d·ªØ li·ªáu t·ª´ b·∫£ng activities v√† molecule_dictionary
-- Get 100 rows of data from the activities and molecule_dictionary tables
SELECT act.molregno, md.chembl_id, act.standard_type, act.standard_value, act.standard_units, md.structure
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value IS NOT NULL
  AND act.standard_value::text ~ '^[0-9\.]+$' --S·ª≠a l·ªói a
LIMIT 100;</code></p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li>C√¢u truy v·∫•n n√†y l·∫•y d·ªØ li·ªáu t·ª´ hai b·∫£ng <code>activities</code> v√† <code>molecule_dictionary</code>. (This query retrieves data from the <code>activities</code> and <code>molecule_dictionary</code> tables.)</li>
<li>N√≥ l·ªçc d·ªØ li·ªáu ƒë·ªÉ ch·ªâ l·∫•y c√°c ho·∫°t ƒë·ªông c√≥ lo·∫°i <code>IC50</code> v√† ƒë∆°n v·ªã <code>nM</code>. (It filters the data to only include activities with type <code>IC50</code> and units <code>nM</code>.)</li>
<li><code>act.standard_value::text ~ '^[0-9\.]+$'</code> √âp ki·ªÉu standard_value sang text tr∆∞·ªõc khi so s√°nh</li>
<li>Gi·ªõi h·∫°n k·∫øt qu·∫£ tr·∫£ v·ªÅ 100 d√≤ng. (Limits the result to 100 rows.)</li>
</ul>
<p><strong>4. Code M·∫´u Python (Python Code Example)</strong></p>
<p>```python
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np
import psycopg2</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>H√†m t√≠nh to√°n ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ s·ª≠ d·ª•ng RDKit (Function to calculate molecular features using RDKit)</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    for name, func in Descriptors.descList:
        try:
            descriptors[name] = func(mol)
        except:
            descriptors[name] = None
    return descriptors</p>
<h1>H√†m ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data preprocessing function)</h1>
<p>def preprocess_data(df):
    # X·ª≠ l√Ω d·ªØ li·ªáu b·ªã thi·∫øu (Handle missing data)
    df = df.dropna(subset=['standard_value', 'structure'])
    df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')
    df = df.dropna(subset=['standard_value'])
    df = df[df['standard_value'] &gt; 0]
    df = df[df['standard_value'] &lt; 100000]
    return df</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT act.molregno, md.chembl_id, act.standard_type, act.standard_value, act.standard_units, md.structure
    FROM activities act
    JOIN molecule_dictionary md ON act.molregno = md.molregno
    WHERE act.standard_type = 'IC50'
      AND act.standard_units = 'nM'
      AND act.standard_value IS NOT NULL
      AND act.standard_value::text ~ '^[0-9.]+$'
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    # Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Preprocess the data)
    df = preprocess_data(df.copy())

    # T√≠nh to√°n ƒë·∫∑c tr∆∞ng (Calculate features)
    descriptors_list = []
    for smiles in df['structure']:
        descriptors = calculate_descriptors(smiles)
        descriptors_list.append(descriptors)

    # Chuy·ªÉn ƒë·ªïi danh s√°ch c√°c ƒë·∫∑c tr∆∞ng th√†nh DataFrame (Convert the list of features into a DataFrame)
    descriptors_df = pd.DataFrame(descriptors_list)

    # Lo·∫°i b·ªè c√°c c·ªôt c√≥ qu√° nhi·ªÅu gi√° tr·ªã thi·∫øu (Remove columns with too many missing values)
    descriptors_df = descriptors_df.dropna(axis=1, thresh=len(descriptors_df) * 0.8)

    # ƒêi·ªÅn gi√° tr·ªã thi·∫øu b·∫±ng gi√° tr·ªã trung b√¨nh c·ªßa c·ªôt (Fill missing values with the mean of the column)
    descriptors_df = descriptors_df.fillna(descriptors_df.mean())

    # K·∫øt h·ª£p c√°c ƒë·∫∑c tr∆∞ng v·ªõi DataFrame ch√≠nh (Combine the features with the main DataFrame)
    df = pd.concat([df, descriptors_df], axis=1)

    # Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra (Split the data into training and test sets)
    X = df.drop(columns=['molregno', 'chembl_id', 'standard_type', 'standard_value', 'standard_units', 'structure'])
    y = np.log10(df['standard_value'])
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # ƒê·∫£m b·∫£o kh√¥ng c√≥ gi√° tr·ªã NaN trong d·ªØ li·ªáu hu·∫•n luy·ªán (Ensure there are no NaN values in the training data)
    X_train = np.nan_to_num(X_train)
    X_test = np.nan_to_num(X_test)

    # Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest (Train a Random Forest model)
    model = RandomForestRegressor(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra (Predict on the test set)
    y_pred = model.predict(X_test)

    # ƒê√°nh gi√° m√¥ h√¨nh (Evaluate the model)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f'Mean Squared Error: {mse}')
    print(f'R-squared: {r2}')
</code></pre>
<p>```</p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li>ƒêo·∫°n code n√†y k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu Chembl b·∫±ng th∆∞ vi·ªán <code>psycopg2</code>. (This code connects to the Chembl database using the <code>psycopg2</code> library.)</li>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc t·ª´ c·∫•u tr√∫c SMILES. (Uses RDKit to calculate chemical features from SMILES structures.)</li>
<li>X√¢y d·ª±ng m√¥ h√¨nh Random Forest ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh IC50. (Builds a Random Forest model to predict IC50 activity.)</li>
<li>ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng MSE v√† R-squared. (Evaluates the model's performance using MSE and R-squared.)</li>
</ul>
<p><strong>L∆∞u √Ω (Note):</strong></p>
<ul>
<li>B·∫°n c·∫ßn c√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt: <code>rdkit</code>, <code>scikit-learn</code>, <code>pandas</code>, <code>psycopg2</code>. (You need to install the necessary libraries: <code>rdkit</code>, <code>scikit-learn</code>, <code>pandas</code>, <code>psycopg2</code>.)</li>
<li>H√£y thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu v√† c√°c tham s·ªë kh√°c cho ph√π h·ª£p v·ªõi m√¥i tr∆∞·ªùng c·ªßa b·∫°n. (Change the path to the database and other parameters to suit your environment.)</li>
<li>Code n√†y ch·ªâ l√† m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n, b·∫°n c√≥ th·ªÉ t√πy ch·ªânh v√† c·∫£i thi·ªán n√≥ ƒë·ªÉ ph√π h·ª£p v·ªõi nhu c·∫ßu c·ª• th·ªÉ c·ªßa d·ª± √°n. (This code is just a simple example, you can customize and improve it to suit the specific needs of the project.)</li>
<li>ƒê√£ s·ª≠a l·ªói  <code>ERROR: operator does not exist: numeric ~ unknown</code> b·∫±ng c√°ch √©p ki·ªÉu d·ªØ li·ªáu v·ªÅ text tr∆∞·ªõc khi so s√°nh.</li>
<li>Kh√¥ng c·∫ßn s·ª≠a l·ªói <code>squared=False</code> v√¨ scikit-learn ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p.</li>
</ul>
<p><strong>5. V√≠ d·ª• Code SQL v√† Python M·∫´u (Sample SQL and Python Code Examples)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u, m·ªói v√≠ d·ª• t·∫≠p trung v√†o m·ªôt kh√≠a c·∫°nh kh√°c nhau c·ªßa vi·ªác ph√¢n t√≠ch d·ªØ li·ªáu Chembl:</p>
<p><strong>V√≠ d·ª• 1: L·ªçc c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh cao (Filtering Highly Active Compounds)</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
-- L·∫•y c√°c h·ª£p ch·∫•t c√≥ IC50 &lt; 100 nM
-- Get compounds with IC50 &lt; 100 nM
SELECT md.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_units = 'nM'
  AND act.standard_value &lt; 100
LIMIT 100;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import pandas as pd
import psycopg2</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT md.chembl_id, act.standard_value
    FROM activities act
    JOIN molecule_dictionary md ON act.molregno = md.molregno
    WHERE act.standard_type = 'IC50'
      AND act.standard_units = 'nM'
      AND act.standard_value &lt; 100
    LIMIT 100;
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    print(df.head())
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Calculating Molecular Weight)</strong></p>
<ul>
<li><strong>SQL:</strong> (Kh√¥ng th·ªÉ t√≠nh tr·ª±c ti·∫øp tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ b·∫±ng SQL, c·∫ßn k·∫øt h·ª£p v·ªõi Python) (Cannot directly calculate molecular weight with SQL, needs to be combined with Python)</li>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import psycopg2</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT md.chembl_id, md.structure
    FROM molecule_dictionary md
    LIMIT 100;
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    # H√†m t√≠nh tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Function to calculate molecular weight)
    def calculate_mw(smiles):
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        return None

    # T√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ cho m·ªói h·ª£p ch·∫•t (Calculate molecular weight for each compound)
    df['mol_weight'] = df['structure'].apply(calculate_mw)
    print(df.head())
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 3: Ph√¢n t√≠ch m·ªëi quan h·ªá c·∫•u tr√∫c-ho·∫°t t√≠nh (SAR) (Structure-Activity Relationship (SAR) Analysis)</strong></p>
<ul>
<li><strong>SQL:</strong> (C·∫ßn k·∫øt h·ª£p v·ªõi Python ƒë·ªÉ ph√¢n t√≠ch SAR) (Needs to be combined with Python to analyze SAR)</li>
<li><strong>Python:</strong> (V√≠ d·ª• n√†y ch·ªâ l√† m·ªôt ph·∫ßn nh·ªè c·ªßa ph√¢n t√≠ch SAR, b·∫°n c·∫ßn t√πy ch·ªânh n√≥ ƒë·ªÉ ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u c·ªßa m√¨nh) (This example is just a small part of SAR analysis, you need to customize it to suit your research goals)</li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from rdkit.Chem import AllChem
from rdkit.DataStructs import FingerprintSimilarity
import psycopg2</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT md.chembl_id, md.structure, act.standard_value
    FROM molecule_dictionary md
    JOIN activities act ON md.molregno = act.molregno
    WHERE act.standard_type = 'IC50'
      AND act.standard_units = 'nM'
    LIMIT 100;
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    # H√†m t√≠nh to√°n fingerprint (Function to calculate fingerprint)
    def calculate_fingerprint(smiles):
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=1024)
        return None

    # T√≠nh to√°n fingerprint cho m·ªói h·ª£p ch·∫•t (Calculate fingerprint for each compound)
    df['fingerprint'] = df['structure'].apply(calculate_fingerprint)

    # Ch·ªçn m·ªôt h·ª£p ch·∫•t l√†m tham chi·∫øu (Select a compound as a reference)
    reference_compound = df.iloc[0]
    reference_fingerprint = reference_compound['fingerprint']

    # H√†m t√≠nh ƒë·ªô t∆∞∆°ng ƒë·ªìng fingerprint (Function to calculate fingerprint similarity)
    def calculate_similarity(fingerprint):
        if fingerprint is not None and reference_fingerprint is not None:
            return FingerprintSimilarity(fingerprint, reference_fingerprint)
        return None

    # T√≠nh to√°n ƒë·ªô t∆∞∆°ng ƒë·ªìng fingerprint v·ªõi h·ª£p ch·∫•t tham chi·∫øu (Calculate fingerprint similarity with the reference compound)
    df['similarity'] = df['fingerprint'].apply(calculate_similarity)

    print(df.head())
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 4: T√¨m ki·∫øm c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± (Searching for Similar Compounds)</strong></p>
<ul>
<li><strong>SQL:</strong> (C√≥ th·ªÉ s·ª≠ d·ª•ng c√°c extension c·ªßa PostgreSQL ƒë·ªÉ t√¨m ki·∫øm t∆∞∆°ng t·ª±, nh∆∞ng c·∫ßn c√†i ƒë·∫∑t v√† c·∫•u h√¨nh) (Can use PostgreSQL extensions for similarity search, but requires installation and configuration)</li>
<li><strong>Python:</strong> (S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√¨m ki·∫øm c√°c h·ª£p ch·∫•t c√≥ c·∫•u tr√∫c t∆∞∆°ng t·ª±) (Use RDKit to find compounds with similar structures)</li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.DataStructs import FingerprintSimilarity
import psycopg2</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT md.chembl_id, md.structure
    FROM molecule_dictionary md
    LIMIT 100;
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    # H√†m t√≠nh to√°n fingerprint (Function to calculate fingerprint)
    def calculate_fingerprint(smiles):
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=1024)
        return None

    # T√≠nh to√°n fingerprint cho m·ªói h·ª£p ch·∫•t (Calculate fingerprint for each compound)
    df['fingerprint'] = df['structure'].apply(calculate_fingerprint)

    # Ch·ªçn m·ªôt h·ª£p ch·∫•t l√†m tham chi·∫øu (Select a compound as a reference)
    reference_smiles = 'CCOc1ccccc1C(=O)O'  # V√≠ d·ª• (Example)
    reference_mol = Chem.MolFromSmiles(reference_smiles)
    reference_fingerprint = AllChem.GetMorganFingerprintAsBitVect(reference_mol, 2, nBits=1024)

    # H√†m t√≠nh ƒë·ªô t∆∞∆°ng ƒë·ªìng fingerprint (Function to calculate fingerprint similarity)
    def calculate_similarity(fingerprint):
        if fingerprint is not None and reference_fingerprint is not None:
            return FingerprintSimilarity(fingerprint, reference_fingerprint)
        return 0.0  # Tr·∫£ v·ªÅ 0 n·∫øu fingerprint l√† None (Return 0 if fingerprint is None)
    # T√≠nh to√°n ƒë·ªô t∆∞∆°ng ƒë·ªìng fingerprint v·ªõi h·ª£p ch·∫•t tham chi·∫øu (Calculate fingerprint similarity with the reference compound)
    df['similarity'] = df['fingerprint'].apply(calculate_similarity)

    # L·ªçc c√°c h·ª£p ch·∫•t c√≥ ƒë·ªô t∆∞∆°ng ƒë·ªìng cao (Filter compounds with high similarity)
    similar_compounds = df[df['similarity'] &gt; 0.7]
    print(similar_compounds)
</code></pre>
<p>```</p>
<p><strong>V√≠ d·ª• 5: X√¢y d·ª±ng m√¥ h√¨nh QSAR ƒë∆°n gi·∫£n (Building a Simple QSAR Model)</strong></p>
<ul>
<li><strong>SQL:</strong> (Kh√¥ng s·ª≠ d·ª•ng SQL tr·ª±c ti·∫øp trong v√≠ d·ª• n√†y) (Not using SQL directly in this example)</li>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import psycopg2
import numpy as np</p>
<h1>C·∫•u h√¨nh k·∫øt n·ªëi database (Database connection configuration)</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35',
    'port': 5432  # C·ªïng m·∫∑c ƒë·ªãnh c·ªßa PostgreSQL (Default PostgreSQL port)
}</p>
<h1>H√†m k·∫øt n·ªëi database (Database connection function)</h1>
<p>def connect_to_db(params):
    try:
        conn = psycopg2.connect(**params)
        print("Connected to the database successfully!")
        return conn
    except psycopg2.Error as e:
        print(f"Unable to connect to the database: {e}")
        return None</p>
<h1>H√†m l·∫•y d·ªØ li·ªáu t·ª´ database (Function to retrieve data from the database)</h1>
<p>def fetch_data(conn, query, limit=100):
    try:
        cur = conn.cursor()
        cur.execute(query)
        data = cur.fetchmany(limit)  # L·∫•y s·ªë l∆∞·ª£ng b·∫£n ghi gi·ªõi h·∫°n (Fetch limited number of records)
        columns = [desc[0] for desc in cur.description]
        df = pd.DataFrame(data, columns=columns)
        print("Data fetched successfully!")
        return df
    except psycopg2.Error as e:
        print(f"Error fetching data: {e}")
        return None</p>
<h1>K·∫øt n·ªëi t·ªõi database (Connect to the database)</h1>
<p>conn = connect_to_db(db_params)
if conn:
    # Truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu (SQL query to retrieve data)
    query = """
    SELECT md.chembl_id, md.structure, act.standard_value
    FROM molecule_dictionary md
    JOIN activities act ON md.molregno = act.molregno
    WHERE act.standard_type = 'IC50'
      AND act.standard_units = 'nM'
      AND act.standard_value IS NOT NULL
      AND act.standard_value::text ~ '^[0-9.]+$'
    LIMIT 100;
    """</p>
<pre><code># L·∫•y d·ªØ li·ªáu t·ª´ database (Fetch data from the database)
df = fetch_data(conn, query)
conn.close()

if df is not None:
    # H√†m t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ ƒë∆°n gi·∫£n (Function to calculate simple molecular descriptors)
    def calculate_descriptors(smiles):
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)  # Ch·ªâ t√≠nh tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Only calculate molecular weight)
        return None

    # T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng (Calculate descriptors)
    df['mol_weight'] = df['structure'].apply(calculate_descriptors)
    df = df.dropna(subset=['mol_weight', 'standard_value'])

    # Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra (Split the data into training and test sets)
    X = df[['mol_weight']]
    y = np.log10(df['standard_value'])  # Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 v·ªÅ logarit (Convert IC50 values to logarithm)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Hu·∫•n luy·ªán m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh (Train a linear regression model)
    model = LinearRegression()
    model.fit(X_train, y_train)

    # D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra (Predict on the test set)
    y_pred = model.predict(X_test)

    # ƒê√°nh gi√° m√¥ h√¨nh (Evaluate the model)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f'Mean Squared Error: {mse}')
    print(f'R-squared: {r2}')
</code></pre>
<p>```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng (Important Notes):</strong></p>
<ul>
<li>C√°c v√≠ d·ª• tr√™n ch·ªâ l√† ƒëi·ªÉm kh·ªüi ƒë·∫ßu. B·∫°n c·∫ßn ƒëi·ªÅu ch·ªânh ch√∫ng ƒë·ªÉ ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u c·ª• th·ªÉ c·ªßa b·∫°n. (The above examples are just a starting point. You need to adjust them to fit your specific research goals.)</li>
<li>H√£y nh·ªõ x·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu v√† d·ªØ li·ªáu ngo·∫°i l·ªá m·ªôt c√°ch th√≠ch h·ª£p. (Remember to handle missing values and outliers appropriately.)</li>
<li>S·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t ƒë√°nh gi√° m√¥ h√¨nh ph√π h·ª£p ƒë·ªÉ ƒë·∫£m b·∫£o m√¥ h√¨nh c·ªßa b·∫°n c√≥ ƒë·ªô tin c·∫≠y cao. (Use appropriate model evaluation techniques to ensure your model is reliable.)</li>
<li>Lu√¥n tham kh·∫£o t√†i li·ªáu ch√≠nh th·ª©c c·ªßa RDKit v√† scikit-learn ƒë·ªÉ bi·∫øt th√™m th√¥ng tin chi ti·∫øt v·ªÅ c√°c h√†m v√† ph∆∞∆°ng ph√°p. (Always refer to the official documentation of RDKit and scikit-learn for more details on functions and methods.)</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi. (Good luck with your Chembl 35 data analysis project! If you have any other questions, don't hesitate to ask.)</p>
        </body>
        </html>
        