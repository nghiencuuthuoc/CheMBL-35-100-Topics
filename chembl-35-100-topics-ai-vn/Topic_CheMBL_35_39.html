
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_39</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: T√¨m target c√≥ ho·∫°t t√≠nh ƒë·ªëi kh√°ng v√† ƒë·ªìng v·∫≠n</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, ch√∫ng ta s·∫Ω t·∫≠p trung v√†o ch·ªß ƒë·ªÅ "Topic_CheMBL_35_39" v√† gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ c·ª• th·ªÉ b·∫°n g·∫∑p ph·∫£i.</p>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch (Analysis Model):</strong></p>
<p>M·ª•c ti√™u c·ªßa ch·ªß ƒë·ªÅ "Topic_CheMBL_35_39" l√† g√¨? ƒê·ªÉ ƒë∆∞a ra m√¥ h√¨nh ph√¢n t√≠ch ph√π h·ª£p, ch√∫ng ta c·∫ßn x√°c ƒë·ªãnh r√µ c√¢u h·ªèi nghi√™n c·ª©u. D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë kh·∫£ nƒÉng:</p>
<ul>
<li><strong>D·ª± ƒëo√°n ho·∫°t t√≠nh (Activity Prediction):</strong> X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng (v√≠ d·ª•: d·ª± ƒëo√°n IC50, Ki, EC50).</li>
<li><strong>Ph√¢n t√≠ch SAR (Structure-Activity Relationship):</strong> T√¨m hi·ªÉu m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc c·ªßa c√°c h·ª£p ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng. X√°c ƒë·ªãnh c√°c nh√≥m ch·ª©c (functional groups) ho·∫∑c ph·∫ßn t·ª≠ c·∫•u tr√∫c (structural motifs) quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh.</li>
<li><strong>Ph√¢n c·ª•m h·ª£p ch·∫•t (Compound Clustering):</strong> Ph√¢n nh√≥m c√°c h·ª£p ch·∫•t th√†nh c√°c c·ª•m d·ª±a tr√™n t√≠nh t∆∞∆°ng ƒë·ªìng v·ªÅ c·∫•u tr√∫c ho·∫∑c ho·∫°t t√≠nh.</li>
<li><strong>Ph√¢n t√≠ch QSAR/QSPR (Quantitative Structure-Activity/Property Relationship):</strong> X√¢y d·ª±ng m√¥ h√¨nh ƒë·ªãnh l∆∞·ª£ng m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc v√† ho·∫°t t√≠nh/t√≠nh ch·∫•t c·ªßa h·ª£p ch·∫•t.</li>
</ul>
<p>D·ª±a tr√™n m·ª•c ti√™u c·ª• th·ªÉ, ch√∫ng ta c√≥ th·ªÉ l·ª±a ch·ªçn c√°c ph∆∞∆°ng ph√°p ph√¢n t√≠ch ph√π h·ª£p:</p>
<ul>
<li><strong>Machine Learning:</strong> C√°c thu·∫≠t to√°n nh∆∞ Random Forest, Support Vector Machines (SVM), Neural Networks, Gradient Boosting.</li>
<li><strong>Cheminformatics:</strong> S·ª≠ d·ª•ng c√°c descriptor ph√¢n t·ª≠ (v√≠ d·ª•: Morgan fingerprints, physicochemical properties) ƒë·ªÉ bi·ªÉu di·ªÖn c·∫•u tr√∫c h√≥a h·ªçc v√† ph√¢n t√≠ch.</li>
<li><strong>Statistical Analysis:</strong> C√°c ph∆∞∆°ng ph√°p th·ªëng k√™ nh∆∞ h·ªìi quy tuy·∫øn t√≠nh, ph√¢n t√≠ch ph∆∞∆°ng sai (ANOVA).</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Guidance):</strong></p>
<p><strong>2.1. SQL:</strong></p>
<ul>
<li><strong>Purpose:</strong> To extract relevant data from the ChEMBL database.</li>
<li><strong>M·ª•c ƒë√≠ch:</strong> Tr√≠ch xu·∫•t d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL.</li>
</ul>
<p><strong>2.2. Python:</strong></p>
<ul>
<li><strong>Purpose:</strong> To process the data, perform calculations, build models, and visualize results.</li>
<li><strong>M·ª•c ƒë√≠ch:</strong> X·ª≠ l√Ω d·ªØ li·ªáu, th·ª±c hi·ªán t√≠nh to√°n, x√¢y d·ª±ng m√¥ h√¨nh v√† tr·ª±c quan h√≥a k·∫øt qu·∫£.</li>
</ul>
<p><strong>3. Code SQL v√† Python m·∫´u (Sample SQL and Python Code):</strong></p>
<p><strong>3.1. SQL (with error handling):</strong></p>
<p>```sql
-- Extract data for Topic_CheMBL_35_39 (limited to 100 records)
-- Tr√≠ch xu·∫•t d·ªØ li·ªáu cho Topic_CheMBL_35_39 (gi·ªõi h·∫°n 100 b·∫£n ghi)</p>
<p>SELECT
    act.molregno,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    md.chembl_id,
    cs.canonical_smiles
FROM
    activities act
JOIN
    molecule_dictionary md ON act.molregno = md.molregno
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')  -- Example activity types
    AND act.standard_units = 'nM' -- Example units
    AND act.standard_value IS NOT NULL
    AND cs.canonical_smiles IS NOT NULL
    -- Handle the numeric check safely:
    AND act.standard_value::text ~ '^[0-9.]+$'  -- Check if it's numeric
LIMIT 100;
```</p>
<p><strong>Explanation:</strong></p>
<ul>
<li>The <code>::text</code> cast is used to convert <code>standard_value</code> to text before applying the regular expression.</li>
<li>We limit the results to 100 records using <code>LIMIT 100</code>.</li>
</ul>
<p><strong>3.2. Python (with scikit-learn version check):</strong></p>
<p>```python
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import AllChem
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import sklearn
import os</p>
<p>print(f"Scikit-learn version: {sklearn.<strong>version</strong>}")</p>
<h1>Define paths (following AIMLOps Template)</h1>
<p>base_path = "../data"  # Adjust if needed
csv_file = os.path.join(base_path, "chembl_35_data.csv") # Replace with your actual filename</p>
<h1>Load data</h1>
<p>try:
    data = pd.read_csv(csv_file)
    print("Data loaded successfully.")
except FileNotFoundError:
    print(f"Error: File not found at {csv_file}")
    exit()</p>
<h1>Data Cleaning and Preprocessing</h1>
<p>data = data.dropna(subset=['canonical_smiles', 'standard_value']) # Drop rows with missing SMILES or activity values
data = data[data['standard_value'].astype(str).str.match(r'^[0-9.]+$')] #Keep numeric values only
data['standard_value'] = pd.to_numeric(data['standard_value']) # Transform to numeric</p>
<h1>Function to convert SMILES to Morgan Fingerprints</h1>
<p>def smiles_to_morgan(smiles, radius=2, n_bits=2048):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=n_bits)
            return np.array(list(fp.ToBitString()), dtype=int)
        else:
            return None
    except:
        return None</p>
<h1>Apply the function to create fingerprints</h1>
<p>data['morgan_fp'] = data['canonical_smiles'].apply(smiles_to_morgan)
data = data.dropna(subset=['morgan_fp'])  # Remove rows where fingerprint generation failed
data = data[data['morgan_fp'].map(len) &gt; 0]</p>
<h1>Prepare data for machine learning</h1>
<p>X = np.stack(data['morgan_fp'].values)
y = data['standard_value'].values</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Train a RandomForestRegressor model</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Calculate Mean Squared Error</h1>
<p>if sklearn.<strong>version</strong> &lt; '0.22':
    mse = mean_squared_error(y_test, y_pred)
else:
    mse = mean_squared_error(y_test, y_pred, squared=False)  # Use squared=False for newer versions</p>
<p>print(f"Mean Squared Error: {mse}")
```</p>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Error Handling:</strong> Includes <code>try...except</code> blocks for file loading and SMILES conversion.</li>
<li><strong>Scikit-learn Version Check:</strong>  Checks the scikit-learn version and uses the appropriate <code>mean_squared_error</code> call.</li>
<li><strong>Data Preprocessing:</strong>  Handles missing data and converts SMILES to Morgan fingerprints.</li>
<li><strong>Model Training:</strong>  Trains a Random Forest Regressor.</li>
<li><strong>Evaluation:</strong>  Calculates and prints the Mean Squared Error.</li>
</ul>
<p><strong>4. V√≠ d·ª• code SQL v√† Python m·∫´u (Sample SQL and Python Code Examples):</strong></p>
<p>Here are 5 examples of SQL and Python code snippets that you can adapt for your project.</p>
<p><strong>Example 1:  Extracting compounds with specific properties</strong></p>
<ul>
<li><strong>SQL:</strong>
    <code>sql
    SELECT md.chembl_id, cs.canonical_smiles, act.standard_value
    FROM molecule_dictionary md
    JOIN compound_structures cs ON md.molregno = cs.molregno
    JOIN activities act ON md.molregno = act.molregno
    WHERE md.mw_freebase &lt; 300 -- Molecular weight less than 300
    AND act.standard_type = 'IC50'
    LIMIT 10;</code></li>
<li><strong>Python:</strong> (Reading from a CSV file generated from the SQL query above)
    <code>python
    import pandas as pd
    data = pd.read_csv('../data/example1.csv') # Update with the correct path
    print(data.head())</code></li>
</ul>
<p><strong>Example 2: Calculating LogP using RDKit</strong></p>
<ul>
<li>
<p><strong>SQL:</strong> (Extract SMILES strings)
    <code>sql
    SELECT md.chembl_id, cs.canonical_smiles
    FROM molecule_dictionary md
    JOIN compound_structures cs ON md.molregno = cs.molregno
    LIMIT 10;</code></p>
</li>
<li>
<p><strong>Python:</strong>
    ```python
    import pandas as pd
    from rdkit import Chem
    from rdkit.Chem import Descriptors</p>
<p>data = pd.read_csv('../data/example2.csv') # Update with the correct path</p>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolLogP(mol)
    else:
        return None</p>
<p>data['logp'] = data['canonical_smiles'].apply(calculate_logp)
print(data.head())
```</p>
</li>
</ul>
<p><strong>Example 3:  Filtering by activity value range</strong></p>
<ul>
<li>
<p><strong>SQL:</strong>
    <code>sql
    SELECT md.chembl_id, cs.canonical_smiles, act.standard_value
    FROM molecule_dictionary md
    JOIN compound_structures cs ON md.molregno = cs.molregno
    JOIN activities act ON md.molregno = act.molregno
    WHERE act.standard_type = 'IC50'
    AND act.standard_value BETWEEN 10 AND 100  -- IC50 between 10 and 100 nM
    LIMIT 10;</code></p>
</li>
<li>
<p><strong>Python:</strong> (Analyzing the extracted data)
    ```python
    import pandas as pd
    import matplotlib.pyplot as plt</p>
<p>data = pd.read_csv('../data/example3.csv') # Update with the correct path
plt.hist(data['standard_value'])
plt.xlabel('IC50 (nM)')
plt.ylabel('Frequency')
plt.title('IC50 Distribution')
plt.show()
```</p>
</li>
</ul>
<p><strong>Example 4:  Generating Morgan fingerprints and visualizing them</strong></p>
<ul>
<li><strong>SQL:</strong> (Extract SMILES)
        <code>sql
    SELECT md.chembl_id, cs.canonical_smiles
    FROM molecule_dictionary md
    JOIN compound_structures cs ON md.molregno = cs.molregno
    LIMIT 10;</code></li>
<li>
<p><strong>Python:</strong>
    ```python
    import pandas as pd
    from rdkit import Chem
    from rdkit.Chem import AllChem
    import matplotlib.pyplot as plt</p>
<p>data = pd.read_csv('../data/example4.csv') # Update with the correct path</p>
<p>def generate_morgan_fp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        fp = AllChem.GetMorganFingerprint(mol, 2) # Radius 2
        return fp
    else:
        return None</p>
<p>data['morgan_fp'] = data['canonical_smiles'].apply(generate_morgan_fp)
print(data.head())
```</p>
</li>
</ul>
<p><strong>Example 5: Basic Activity Prediction with a Simple Model</strong></p>
<ul>
<li><strong>SQL:</strong>
    <code>sql
    SELECT md.chembl_id, cs.canonical_smiles, act.standard_value
    FROM molecule_dictionary md
    JOIN compound_structures cs ON md.molregno = cs.molregno
    JOIN activities act ON md.molregno = act.molregno
    WHERE act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    LIMIT 100;</code></li>
<li>
<p><strong>Python:</strong> (Simple Activity Prediction)
    ```python
    import pandas as pd
    from rdkit import Chem
    from rdkit.Chem import AllChem
    from sklearn.model_selection import train_test_split
    from sklearn.linear_model import LinearRegression
    from sklearn.metrics import mean_squared_error
    import numpy as np</p>
<h1>Load data</h1>
<p>data = pd.read_csv('../data/example5.csv') # Update with the correct path
data.dropna(inplace=True)</p>
<h1>RDKit: Generate Morgan Fingerprints</h1>
<p>def generate_fingerprint(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=2048)
        return np.array(list(fp))
    else:
        return None</p>
<p>data['fingerprint'] = data['canonical_smiles'].apply(generate_fingerprint)
data.dropna(subset=['fingerprint'], inplace=True)</p>
<h1>Prepare data</h1>
<p>X = np.stack(data['fingerprint'].values)
y = data['standard_value'].values</p>
<h1>Split data</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Model training</h1>
<p>model = LinearRegression()
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate</h1>
<p>mse = mean_squared_error(y_test, y_pred)
print(f'Mean Squared Error: {mse}')
```</p>
</li>
</ul>
<p><strong>Important Considerations:</strong></p>
<ul>
<li><strong>Database Connection:</strong> You'll need to establish a connection to your PostgreSQL database using a Python library like <code>psycopg2</code>.</li>
<li><strong>Data Scaling/Normalization:</strong> Consider scaling or normalizing your activity values (e.g., converting IC50 to pIC50) to improve model performance.</li>
<li><strong>Feature Selection:</strong> Explore different molecular descriptors and feature selection techniques to optimize your models.</li>
<li><strong>Model Validation:</strong> Use appropriate validation techniques (e.g., cross-validation) to ensure the robustness of your models.</li>
<li><strong>Logging:</strong> Implement logging to track the progress of your analysis and debug any issues.</li>
<li><strong>AIMLOps:</strong> Integrate your code into the AIMLOps framework for reproducibility, version control, and automated deployment.</li>
</ul>
<p>H√£y cho t√¥i bi·∫øt n·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi c·ª• th·ªÉ n√†o ho·∫∑c mu·ªën t√¥i ƒëi s√¢u h∆°n v√†o m·ªôt kh√≠a c·∫°nh c·ª• th·ªÉ c·ªßa d·ª± √°n. Ch√∫c b·∫°n th√†nh c√¥ng!</p>
        </body>
        </html>
        