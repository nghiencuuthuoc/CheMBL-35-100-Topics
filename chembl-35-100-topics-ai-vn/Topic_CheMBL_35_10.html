
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_10</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: B·∫£n ƒë·ªì kh√¥ng gian h√≥a h·ªçc c·ªßa c√°c ph√¢n t·ª≠ ChEMBL</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35 n√†y. V·ªõi vai tr√≤ l√† Chuy√™n gia R&amp;D D∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p h∆∞·ªõng d·∫´n chi ti·∫øt, code m·∫´u v√† gi·∫£i th√≠ch r√µ r√†ng ƒë·ªÉ b·∫°n c√≥ th·ªÉ tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.</p>
<p><strong>1. Ph√¢n T√≠ch M√¥ H√¨nh Ph√¢n T√≠ch (Analysis of the Analysis Model)</strong></p>
<p>D·ª±a tr√™n y√™u c·∫ßu c·ªßa b·∫°n, ch√∫ng ta s·∫Ω x√¢y d·ª±ng m·ªôt quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35 k·∫øt h·ª£p RDKit ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. M√¥ h√¨nh n√†y bao g·ªìm c√°c b∆∞·ªõc ch√≠nh sau:</p>
<ul>
<li><strong>Thu th·∫≠p v√† Chu·∫©n b·ªã D·ªØ li·ªáu (Data Acquisition and Preparation):</strong><ul>
<li>S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ database Chembl 35 (tr√™n PostgreSQL).</li>
<li>L·ªçc v√† ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (v√≠ d·ª•: lo·∫°i b·ªè c√°c gi√° tr·ªã kh√¥ng h·ª£p l·ªá, chu·∫©n h√≥a d·ªØ li·ªáu).</li>
<li>L∆∞u d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω v√†o file CSV.</li>
</ul>
</li>
<li><strong>T√≠nh To√°n ƒê·∫∑c Tr∆∞ng Ph√¢n T·ª≠ (Molecular Feature Calculation):</strong><ul>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ (molecular descriptors) t·ª´ SMILES strings. C√°c ƒë·∫∑c tr∆∞ng n√†y c√≥ th·ªÉ bao g·ªìm:<ul>
<li>T√≠nh ch·∫•t v·∫≠t l√Ω h√≥a h·ªçc (physicochemical properties): LogP, Molecular Weight, Topological Polar Surface Area (TPSA).</li>
<li>ƒê·∫∑c tr∆∞ng c·∫•u tr√∫c (structural features): s·ªë l∆∞·ª£ng v√≤ng, s·ªë l∆∞·ª£ng nguy√™n t·ª≠, s·ªë l∆∞·ª£ng li√™n k·∫øt.</li>
<li>Fingerprints: Morgan fingerprints, MACCS keys.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Ph√¢n T√≠ch Th·ªëng K√™ v√† Tr·ª±c Quan H√≥a (Statistical Analysis and Visualization):</strong><ul>
<li>S·ª≠ d·ª•ng Python (v·ªõi c√°c th∆∞ vi·ªán nh∆∞ pandas, numpy, matplotlib, seaborn) ƒë·ªÉ th·ª±c hi·ªán ph√¢n t√≠ch th·ªëng k√™ m√¥ t·∫£ (descriptive statistics) v√† tr·ª±c quan h√≥a d·ªØ li·ªáu.</li>
<li>V√≠ d·ª•: v·∫Ω bi·ªÉu ƒë·ªì ph√¢n ph·ªëi c·ªßa c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠, bi·ªÉu ƒë·ªì scatter ƒë·ªÉ t√¨m m·ªëi t∆∞∆°ng quan gi·ªØa c√°c ƒë·∫∑c tr∆∞ng v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
</ul>
</li>
<li><strong>X√¢y D·ª±ng M√¥ H√¨nh H·ªçc M√°y (Machine Learning Model Building):</strong><ul>
<li>S·ª≠ d·ª•ng scikit-learn ƒë·ªÉ x√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, random forest, support vector machines).</li>
<li>S·ª≠ d·ª•ng c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ l√†m ƒë·∫ßu v√†o cho m√¥ h√¨nh.</li>
<li>ƒê√°nh gi√° hi·ªáu su·∫•t m√¥ h√¨nh b·∫±ng c√°c metrics ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE, AUC).</li>
</ul>
</li>
</ul>
<p><strong>2. H∆∞·ªõng D·∫´n Song Ng·ªØ (Bilingual Instructions)</strong></p>
<p><strong>2.1. K·∫øt N·ªëi C∆° S·ªü D·ªØ Li·ªáu v√† Truy V·∫•n SQL (Database Connection and SQL Queries)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<ol>
<li>S·ª≠ d·ª•ng pgAdmin ƒë·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu PostgreSQL c·ªßa b·∫°n.</li>
<li>T·∫°o m·ªôt query m·ªõi v√† vi·∫øt c√°c c√¢u l·ªánh SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu mong mu·ªën t·ª´ Chembl 35.</li>
<li>L∆∞u k·∫øt qu·∫£ truy v·∫•n v√†o file CSV (v√≠ d·ª•: <code>../data/chembl_data.csv</code>).</li>
</ol>
<p><strong>English:</strong></p>
<ol>
<li>Use pgAdmin to connect to your PostgreSQL database.</li>
<li>Create a new query and write SQL statements to retrieve the desired data from Chembl 35.</li>
<li>Save the query results to a CSV file (e.g., <code>../data/chembl_data.csv</code>).</li>
</ol>
<p><strong>2.2. T√≠nh To√°n ƒê·∫∑c Tr∆∞ng Ph√¢n T·ª≠ v·ªõi RDKit (Molecular Feature Calculation with RDKit)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<ol>
<li>Trong Jupyter Notebook, import th∆∞ vi·ªán RDKit.</li>
<li>ƒê·ªçc file CSV ch·ª©a d·ªØ li·ªáu Chembl.</li>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ chuy·ªÉn ƒë·ªïi SMILES strings th√†nh c√°c ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠.</li>
<li>T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ mong mu·ªën (v√≠ d·ª•: LogP, Molecular Weight).</li>
<li>L∆∞u c√°c ƒë·∫∑c tr∆∞ng n√†y v√†o DataFrame.</li>
</ol>
<p><strong>English:</strong></p>
<ol>
<li>In a Jupyter Notebook, import the RDKit library.</li>
<li>Read the CSV file containing Chembl data.</li>
<li>Use RDKit to convert SMILES strings into molecule objects.</li>
<li>Calculate the desired molecular features (e.g., LogP, Molecular Weight).</li>
<li>Store these features in a DataFrame.</li>
</ol>
<p><strong>2.3. X√¢y D·ª±ng M√¥ H√¨nh H·ªçc M√°y (Machine Learning Model Building)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<ol>
<li>Chu·∫©n b·ªã d·ªØ li·ªáu: t√°ch features (ƒë·∫∑c tr∆∞ng) v√† target (bi·∫øn m·ª•c ti√™u).</li>
<li>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.</li>
<li>Ch·ªçn m·ªôt m√¥ h√¨nh h·ªçc m√°y (v√≠ d·ª•: Random Forest).</li>
<li>Hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p hu·∫•n luy·ªán.</li>
<li>ƒê√°nh gi√° m√¥ h√¨nh tr√™n t·∫≠p ki·ªÉm tra.</li>
</ol>
<p><strong>English:</strong></p>
<ol>
<li>Prepare the data: separate features and target.</li>
<li>Split the data into training and test sets.</li>
<li>Choose a machine learning model (e.g., Random Forest).</li>
<li>Train the model on the training set.</li>
<li>Evaluate the model on the test set.</li>
</ol>
<p><strong>3. Code SQL v√† Python (SQL and Python Code)</strong></p>
<p><strong>3.1. Code SQL</strong></p>
<p><code>sql
-- English: Select 100 rows from the activities table with specific conditions
-- Vietnamese: Ch·ªçn 100 d√≤ng t·ª´ b·∫£ng activities v·ªõi c√°c ƒëi·ªÅu ki·ªán c·ª• th·ªÉ
SELECT
    act.molregno,
    act.standard_type,
    act.standard_relation,
    act.standard_value,
    act.standard_units,
    cmp.chembl_id,
    cmp.smiles
FROM
    activities act
JOIN
    molecule_dictionary cmp ON act.molregno = cmp.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_units = 'nM'
    --AND act.standard_value ~ '^[0-9\.]+$' -- This line might cause an error
LIMIT 100;</code></p>
<p><strong>L∆∞u √Ω:</strong> D√≤ng <code>AND act.standard_value ~ '^[0-9\.]+$'</code> c√≥ th·ªÉ g√¢y ra l·ªói v√¨ ki·ªÉu d·ªØ li·ªáu c·ªßa <code>standard_value</code> l√† numeric. B·∫°n c√≥ th·ªÉ b·ªè qua d√≤ng n√†y ho·∫∑c chuy·ªÉn ƒë·ªïi <code>standard_value</code> sang ki·ªÉu text ƒë·ªÉ so s√°nh.</p>
<p><strong>3.2. Code Python</strong></p>
<p>```python
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Define the base path for your project</h1>
<p>base_path = "."  # Assuming the notebook is in the root directory</p>
<h1>Read the CSV file containing Chembl data</h1>
<p>data_path = os.path.join(base_path, 'data', 'chembl_data.csv') # Assuming the CSV is stored in a 'data' folder
df = pd.read_csv(data_path)</p>
<h1>Function to calculate molecular weight using RDKit</h1>
<p>def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None</p>
<h1>Apply the function to calculate molecular weight for each SMILES string</h1>
<p>df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)</p>
<h1>Convert standard_value to numeric, handling errors</h1>
<p>df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')</p>
<h1>Drop rows with missing values (NaN)</h1>
<p>df = df.dropna()</p>
<h1>Define features (X) and target (y)</h1>
<p>X = df[['molecular_weight']]
y = df['standard_value']</p>
<h1>Split the data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Create a Random Forest Regressor model</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)</p>
<h1>Train the model</h1>
<p>model.fit(X_train, y_train)</p>
<h1>Make predictions on the test set</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>4. V√≠ D·ª• Code SQL v√† Python (SQL and Python Code Examples)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>V√≠ d·ª• 1: Truy v·∫•n th√¥ng tin c∆° b·∫£n v·ªÅ c√°c h·ª£p ch·∫•t (Basic Compound Information Query)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
-- English: Select chembl_id and smiles for the first 100 compounds
-- Vietnamese: Ch·ªçn chembl_id v√† smiles c·ªßa 100 h·ª£p ch·∫•t ƒë·∫ßu ti√™n
SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;</code></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English: Read the first 100 rows from the molecule_dictionary table into a Pandas DataFrame</h1>
<h1>Vietnamese: ƒê·ªçc 100 d√≤ng ƒë·∫ßu ti√™n t·ª´ b·∫£ng molecule_dictionary v√†o DataFrame Pandas</h1>
<p>import pandas as pd
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Connect to the database</h1>
<p>conn = psycopg2.connect(**db_params)</p>
<h1>SQL query to retrieve the first 100 rows from molecule_dictionary</h1>
<p>sql_query = "SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;"</p>
<h1>Read the data into a Pandas DataFrame</h1>
<p>df = pd.read_sql(sql_query, conn)</p>
<h1>Close the database connection</h1>
<p>conn.close()</p>
<h1>Print the DataFrame</h1>
<p>print(df.head())
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh LogP s·ª≠ d·ª•ng RDKit (Calculate LogP using RDKit)</strong></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English: Calculate LogP for a list of SMILES strings</h1>
<h1>Vietnamese: T√≠nh LogP cho m·ªôt danh s√°ch c√°c chu·ªói SMILES</h1>
<p>from rdkit import Chem
from rdkit.Chem import Crippen</p>
<p>smiles_list = ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1', 'CCO']</p>
<p>logp_values = []
for smiles in smiles_list:
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        logp = Crippen.MolLogP(mol)
        logp_values.append(logp)
    else:
        logp_values.append(None)</p>
<p>print(logp_values)
```</p>
<p><strong>V√≠ d·ª• 3: L·ªçc c√°c h·ª£p ch·∫•t c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ nh·∫•t ƒë·ªãnh (Filter Compounds by Molecular Weight)</strong></p>
<p><strong>SQL:</strong></p>
<p>```sql
-- English: This SQL query is not directly possible as molecular weight is not stored in the database.
-- You would need to calculate it in Python using RDKit after fetching SMILES.
-- Vietnamese: Truy v·∫•n SQL n√†y kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp v√¨ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ kh√¥ng ƒë∆∞·ª£c l∆∞u tr·ªØ trong c∆° s·ªü d·ªØ li·ªáu.
-- B·∫°n c·∫ßn t√≠nh to√°n n√≥ trong Python b·∫±ng RDKit sau khi l·∫•y SMILES.</p>
<p>-- Example: Select chembl_id and smiles for compounds, then calculate molecular weight in Python
-- V√≠ d·ª•: Ch·ªçn chembl_id v√† smiles cho c√°c h·ª£p ch·∫•t, sau ƒë√≥ t√≠nh tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trong Python
SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;
```</p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English: Filter compounds by molecular weight after fetching data</h1>
<h1>Vietnamese: L·ªçc c√°c h·ª£p ch·∫•t theo tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ sau khi l·∫•y d·ªØ li·ªáu</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Connect to the database</h1>
<p>conn = psycopg2.connect(**db_params)</p>
<h1>SQL query to retrieve chembl_id and smiles</h1>
<p>sql_query = "SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;"</p>
<h1>Read the data into a Pandas DataFrame</h1>
<p>df = pd.read_sql(sql_query, conn)</p>
<h1>Close the database connection</h1>
<p>conn.close()</p>
<h1>Function to calculate molecular weight</h1>
<p>def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None</p>
<h1>Apply the function to calculate molecular weight for each SMILES string</h1>
<p>df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)</p>
<h1>Filter compounds with molecular weight between 200 and 400</h1>
<p>filtered_df = df[(df['molecular_weight'] &gt;= 200) &amp; (df['molecular_weight'] &lt;= 400)]</p>
<p>print(filtered_df)
```</p>
<p><strong>V√≠ d·ª• 4: Ph√¢n t√≠ch ho·∫°t t√≠nh sinh h·ªçc (Activity Analysis)</strong></p>
<p><strong>SQL:</strong></p>
<p><code>sql
-- English: Select IC50 values for a specific target
-- Vietnamese: Ch·ªçn gi√° tr·ªã IC50 cho m·ªôt target c·ª• th·ªÉ
SELECT act.standard_value
FROM activities act
JOIN target_dictionary tgt ON act.tid = tgt.tid
WHERE tgt.chembl_id = 'CHEMBL205'  -- Replace with the desired target CHEMBL ID
AND act.standard_type = 'IC50'
AND act.standard_relation = '='
LIMIT 100;</code></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English: Analyze IC50 values fetched from the database</h1>
<h1>Vietnamese: Ph√¢n t√≠ch c√°c gi√° tr·ªã IC50 ƒë∆∞·ª£c l·∫•y t·ª´ c∆° s·ªü d·ªØ li·ªáu</h1>
<p>import pandas as pd
import matplotlib.pyplot as plt
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Connect to the database</h1>
<p>conn = psycopg2.connect(**db_params)</p>
<h1>SQL query to retrieve IC50 values for a specific target</h1>
<p>sql_query = """
SELECT act.standard_value
FROM activities act
JOIN target_dictionary tgt ON act.tid = tgt.tid
WHERE tgt.chembl_id = 'CHEMBL205'  -- Replace with the desired target CHEMBL ID
AND act.standard_type = 'IC50'
AND act.standard_relation = '='
LIMIT 100;
"""</p>
<h1>Read the data into a Pandas DataFrame</h1>
<p>df = pd.read_sql(sql_query, conn)</p>
<h1>Close the database connection</h1>
<p>conn.close()</p>
<h1>Convert standard_value to numeric, handling errors</h1>
<p>df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')</p>
<h1>Drop rows with missing values (NaN)</h1>
<p>df = df.dropna()</p>
<h1>Plot a histogram of IC50 values</h1>
<p>plt.hist(df['standard_value'], bins=20)
plt.xlabel('IC50 Value')
plt.ylabel('Frequency')
plt.title('Distribution of IC50 Values')
plt.show()
```</p>
<p><strong>V√≠ d·ª• 5: X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh (Activity Prediction Model)</strong></p>
<p><strong>Python:</strong></p>
<p>```python</p>
<h1>English: Build a simple activity prediction model using molecular weight</h1>
<h1>Vietnamese: X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh ƒë∆°n gi·∫£n s·ª≠ d·ª•ng tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<h1>Connect to the database</h1>
<p>conn = psycopg2.connect(**db_params)</p>
<h1>SQL query to retrieve data for activity prediction</h1>
<p>sql_query = """
SELECT act.standard_value, cmp.smiles
FROM activities act
JOIN molecule_dictionary cmp ON act.molregno = cmp.molregno
WHERE act.standard_type = 'IC50'
AND act.standard_relation = '='
AND act.standard_value IS NOT NULL
LIMIT 100;
"""</p>
<h1>Read the data into a Pandas DataFrame</h1>
<p>df = pd.read_sql(sql_query, conn)</p>
<h1>Close the database connection</h1>
<p>conn.close()</p>
<h1>Function to calculate molecular weight</h1>
<p>def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None</p>
<h1>Apply the function to calculate molecular weight for each SMILES string</h1>
<p>df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)</p>
<h1>Convert standard_value to numeric, handling errors</h1>
<p>df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')</p>
<h1>Drop rows with missing values (NaN)</h1>
<p>df = df.dropna()</p>
<h1>Prepare data for modeling</h1>
<p>X = df[['molecular_weight']]
y = df['standard_value']</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Create a linear regression model</h1>
<p>model = LinearRegression()</p>
<h1>Train the model</h1>
<p>model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")
```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li><strong>S·ª≠a l·ªói SQL:</strong> Trong truy v·∫•n SQL, h√£y ƒë·∫£m b·∫£o x·ª≠ l√Ω ƒë√∫ng ki·ªÉu d·ªØ li·ªáu c·ªßa c·ªôt <code>standard_value</code>. N·∫øu c·∫ßn, b·∫°n c√≥ th·ªÉ b·ªè qua vi·ªác l·ªçc theo regular expression ho·∫∑c chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu tr∆∞·ªõc khi so s√°nh.</li>
<li><strong>Phi√™n b·∫£n Scikit-learn:</strong> N·∫øu b·∫°n g·∫∑p l·ªói v·ªÅ tham s·ªë <code>squared=False</code> trong <code>mean_squared_error</code>, h√£y c·∫≠p nh·∫≠t scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t ho·∫∑c b·ªè tham s·ªë n√†y (phi√™n b·∫£n c≈© m·∫∑c ƒë·ªãnh <code>squared=True</code>).</li>
<li><strong>ƒê∆∞·ªùng d·∫´n:</strong> S·ª≠ d·ª•ng <code>os.path.join(base_path, ...)</code> ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh di ƒë·ªông c·ªßa code khi di chuy·ªÉn gi·ªØa c√°c m√¥i tr∆∞·ªùng.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        