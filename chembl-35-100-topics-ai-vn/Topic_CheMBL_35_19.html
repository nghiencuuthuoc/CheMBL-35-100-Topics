
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_19</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: K·∫øt n·ªëi ChEMBL v·ªõi DrugBank ƒë·ªÉ t√°i ƒë·ªãnh h∆∞·ªõng thu·ªëc</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n h∆∞·ªõng d·∫´n chi ti·∫øt, m√£ ngu·ªìn SQL v√† Python m·∫´u, c√πng v·ªõi nh·ªØng l∆∞u √Ω quan tr·ªçng ƒë·ªÉ ƒë·∫£m b·∫£o d·ª± √°n c·ªßa b·∫°n di·ªÖn ra su√¥n s·∫ª.</p>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh (Analysis of the Model)</strong></p>
<p>D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, ch√∫ng ta s·∫Ω x√¢y d·ª±ng m·ªôt quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu tu√¢n theo c√°c b∆∞·ªõc sau:</p>
<ol>
<li><strong>Data Extraction (Tr√≠ch xu·∫•t d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 tr√™n PostgreSQL v√† l∆∞u k·∫øt qu·∫£ v√†o c√°c file CSV.</li>
<li><strong>Data Preprocessing (Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng Python (v·ªõi th∆∞ vi·ªán RDKit v√† Pandas) ƒë·ªÉ l√†m s·∫°ch, chuy·ªÉn ƒë·ªïi v√† chu·∫©n h√≥a d·ªØ li·ªáu. C√°c b∆∞·ªõc c√≥ th·ªÉ bao g·ªìm:<ul>
<li>X·ª≠ l√Ω c√°c gi√° tr·ªã missing.</li>
<li>Chuy·ªÉn ƒë·ªïi c√°c gi√° tr·ªã ho·∫°t t√≠nh (IC50, Ki, EC50) sang pChEMBL.</li>
<li>T√≠nh to√°n c√°c ƒë·∫∑c t√≠nh l√Ω h√≥a (physicochemical properties) v√† fingerprint ph√¢n t·ª≠ (molecular fingerprints) b·∫±ng RDKit.</li>
</ul>
</li>
<li><strong>Exploratory Data Analysis (EDA) (Ph√¢n t√≠ch kh√°m ph√° d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng Python ƒë·ªÉ kh√°m ph√° d·ªØ li·ªáu, t√¨m ki·∫øm c√°c xu h∆∞·ªõng v√† m·ªëi quan h·ªá gi·ªØa c√°c bi·∫øn. C√°c k·ªπ thu·∫≠t c√≥ th·ªÉ bao g·ªìm:<ul>
<li>V·∫Ω bi·ªÉu ƒë·ªì ph√¢n ph·ªëi c·ªßa c√°c bi·∫øn.</li>
<li>T√≠nh to√°n c√°c th·ªëng k√™ m√¥ t·∫£.</li>
<li>Ph√¢n t√≠ch t∆∞∆°ng quan.</li>
</ul>
</li>
<li><strong>Model Building (X√¢y d·ª±ng m√¥ h√¨nh):</strong> S·ª≠ d·ª•ng c√°c thu·∫≠t to√°n h·ªçc m√°y (v√≠ d·ª•: Random Forest, Support Vector Machines) ƒë·ªÉ x√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t.</li>
<li><strong>Model Evaluation (ƒê√°nh gi√° m√¥ h√¨nh):</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c ch·ªâ s·ªë ph√π h·ª£p (v√≠ d·ª•: RMSE, R-squared, AUC).</li>
</ol>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)</strong></p>
<p><strong>2.1. K·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu (Connecting to the Database)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<p>ƒê·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 c·ªßa b·∫°n, b·∫°n c·∫ßn s·ª≠ d·ª•ng th∆∞ vi·ªán <code>psycopg2</code> trong Python. ƒê·∫£m b·∫£o r·∫±ng b·∫°n ƒë√£ c√†i ƒë·∫∑t th∆∞ vi·ªán n√†y b·∫±ng l·ªánh <code>pip install psycopg2</code>.</p>
<p><strong>English:</strong></p>
<p>To connect to your ChEMBL 35 database, you need to use the <code>psycopg2</code> library in Python. Make sure you have installed this library using the command <code>pip install psycopg2</code>.</p>
<p>```python
import psycopg2</p>
<h1>Database credentials</h1>
<p>db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}</p>
<p>def connect_to_db(params):
    """Connects to the PostgreSQL database."""
    try:
        conn = psycopg2.connect(**params)
        return conn
    except psycopg2.Error as e:
        print(f"Error connecting to the database: {e}")
        return None</p>
<h1>Establish connection</h1>
<p>connection = connect_to_db(db_params)</p>
<p>if connection:
    print("Successfully connected to the database!")
    # Perform database operations here
    connection.close() # remember to close connection after done
else:
    print("Failed to connect to the database.")
```</p>
<p><strong>2.2. Tr√≠ch xu·∫•t d·ªØ li·ªáu v·ªõi SQL (Data Extraction with SQL)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<p>S·ª≠ d·ª•ng c√¢u l·ªánh SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35. L∆∞u √Ω, ƒë·ªÉ tr√°nh l·ªói "operator does not exist: numeric ~ unknown", h√£y s·ª≠ d·ª•ng h√†m <code>CAST</code> ƒë·ªÉ chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu c·ªßa c·ªôt <code>standard_value</code> sang ki·ªÉu <code>TEXT</code> tr∆∞·ªõc khi so s√°nh v·ªõi regular expression.</p>
<p><strong>English:</strong></p>
<p>Use SQL queries to extract data from the ChEMBL 35 database. Note, to avoid the error "operator does not exist: numeric ~ unknown", use the <code>CAST</code> function to convert the data type of the <code>standard_value</code> column to <code>TEXT</code> before comparing with the regular expression.</p>
<p><code>sql
-- L·∫•y 100 d√≤ng d·ªØ li·ªáu
-- Get 100 rows of data
SELECT DISTINCT
    md.chembl_id,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_units = 'nM'
  AND CAST(act.standard_value AS TEXT) ~ '^[0-9\.]+$' -- fix error here
LIMIT 100;</code></p>
<p><strong>2.3. Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu v·ªõi Python (Data Preprocessing with Python)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<p>S·ª≠ d·ª•ng th∆∞ vi·ªán Pandas ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ file CSV, RDKit ƒë·ªÉ t√≠nh to√°n fingerprint ph√¢n t·ª≠ v√† pChEMBL, v√† Scikit-learn cho c√°c b∆∞·ªõc ti·ªÅn x·ª≠ l√Ω kh√°c.</p>
<p><strong>English:</strong></p>
<p>Use the Pandas library to read data from CSV files, RDKit to calculate molecular fingerprints and pChEMBL, and Scikit-learn for other preprocessing steps.</p>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
import numpy as np</p>
<p>def calculate_pchembl(standard_value):
    """Calculates pChEMBL value."""
    return -np.log10(standard_value * 1e-9)</p>
<p>def calculate_fingerprint(smiles):
    """Calculates Morgan fingerprint using RDKit."""
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
    else:
        return None</p>
<h1>Example usage</h1>
<p>csv_file_path = '../data/your_file.csv'  # Replace with your actual file path
df = pd.read_csv(csv_file_path)</p>
<h1>Calculate pChEMBL (assuming IC50 in nM)</h1>
<p>df['pchembl_value'] = df['standard_value'].apply(calculate_pchembl)</p>
<h1>Calculate molecular fingerprints</h1>
<p>df['mol'] = df['canonical_smiles'].apply(Chem.MolFromSmiles)
df = df[df['mol'].notna()]
df['fingerprint'] = df['canonical_smiles'].apply(calculate_fingerprint)
df = df[df['fingerprint'].notna()]</p>
<p>print(df.head())
```</p>
<p><strong>2.4 X·ª≠ l√Ω l·ªói phi√™n b·∫£n Scikit-learn (Handling Scikit-learn Version Error)</strong></p>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
<p>N·∫øu b·∫°n g·∫∑p l·ªói li√™n quan ƒë·∫øn tham s·ªë <code>squared=False</code> trong h√†m <code>mean_squared_error</code>, h√£y ki·ªÉm tra phi√™n b·∫£n Scikit-learn c·ªßa b·∫°n. N·∫øu phi√™n b·∫£n c≈©, b·∫°n c√≥ th·ªÉ n√¢ng c·∫•p l√™n phi√™n b·∫£n m·ªõi h∆°n ho·∫∑c b·ªè tham s·ªë <code>squared=False</code> (khi ƒë√≥, k·∫øt qu·∫£ s·∫Ω l√† MSE thay v√¨ RMSE).</p>
<p><strong>English:</strong></p>
<p>If you encounter an error related to the <code>squared=False</code> parameter in the <code>mean_squared_error</code> function, check your Scikit-learn version. If the version is old, you can upgrade to a newer version or remove the <code>squared=False</code> parameter (in which case the result will be MSE instead of RMSE).</p>
<p>```python
from sklearn.metrics import mean_squared_error</p>
<h1>Example</h1>
<p>y_true = [3, -0.5, 2, 7]
y_predicted = [2.5, 0.0, 2, 8]</p>
<h1>Try to calculate RMSE; if it fails, calculate MSE instead</h1>
<p>try:
    rmse = mean_squared_error(y_true, y_predicted, squared=False)
    print(f"RMSE: {rmse}")
except TypeError:
    mse = mean_squared_error(y_true, y_predicted)
    print(f"MSE: {mse}. Consider upgrading scikit-learn for RMSE support.")</p>
<p>```</p>
<p><strong>3. V√≠ d·ª• m√£ SQL v√† Python m·∫´u (Example SQL and Python Code Samples)</strong></p>
<p><strong>3.1. SQL Examples</strong></p>
<p>```sql
-- 1. L·∫•y danh s√°ch c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh IC50 d∆∞·ªõi 100 nM
-- 1. Get a list of compounds with IC50 activity below 100 nM
SELECT md.chembl_id, cs.canonical_smiles
FROM molecule_dictionary md
JOIN compound_structures cs ON md.molregno = cs.molregno
JOIN activities act ON md.molregno = act.molregno
WHERE act.standard_type = 'IC50' AND act.standard_value &lt; 100 AND act.standard_units = 'nM';</p>
<p>-- 2. L·∫•y s·ªë l∆∞·ª£ng c√°c h·ª£p ch·∫•t cho m·ªói gi√° tr·ªã standard_type
-- 2. Get the number of compounds for each standard_type
SELECT act.standard_type, COUNT(DISTINCT md.chembl_id) AS num_compounds
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
GROUP BY act.standard_type;</p>
<p>-- 3. L·∫•y c√°c h·ª£p ch·∫•t c√≥ kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ n·∫±m trong kho·∫£ng 400-500 Da
-- 3. Get compounds with molecular weight between 400-500 Da
SELECT md.chembl_id, cs.canonical_smiles
FROM molecule_dictionary md
JOIN compound_structures cs ON md.molregno = cs.molregno
WHERE md.mw_freebase BETWEEN 400 AND 500;</p>
<p>-- 4. L·∫•y danh s√°ch c√°c m·ª•c ti√™u (targets) li√™n quan ƒë·∫øn m·ªôt h·ª£p ch·∫•t c·ª• th·ªÉ
-- 4. Get a list of targets related to a specific compound
SELECT td.chembl_id, td.pref_name
FROM target_dictionary td
JOIN assays a ON td.tid = a.tid
JOIN activities act ON a.assay_id = act.assay_id
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE md.chembl_id = 'CHEMBL188'; -- Thay th·∫ø b·∫±ng Chembl ID b·∫°n mu·ªën</p>
<p>-- 5. L·∫•y danh s√°ch c√°c protein c√≥ ho·∫°t t√≠nh Ki
-- 5. Get the list of proteins with Ki activities
SELECT td.chembl_id, td.pref_name
FROM target_dictionary td
JOIN assays a ON td.tid = a.tid
JOIN activities act ON a.assay_id = act.assay_id
WHERE act.standard_type = 'Ki';
```</p>
<p><strong>3.2. Python Examples</strong></p>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<h1>1. T√≠nh to√°n LogP cho m·ªôt danh s√°ch c√°c SMILES</h1>
<h1>1. Calculate LogP for a list of SMILES</h1>
<p>smiles_list = ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1', 'CCO']
logp_values = []</p>
<p>for smiles in smiles_list:
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        logp = Descriptors.MolLogP(mol)
        logp_values.append(logp)
    else:
        logp_values.append(None)</p>
<p>print(f"LogP values: {logp_values}")</p>
<h1>2. ƒê·ªçc d·ªØ li·ªáu t·ª´ CSV v√† t√≠nh to√°n s·ªë v√≤ng th∆°m</h1>
<h1>2. Read data from CSV and calculate the number of aromatic rings</h1>
<p>csv_file = '../data/your_file.csv'
df = pd.read_csv(csv_file)</p>
<p>def calculate_aromatic_rings(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Chem.Lipinski.NumAromaticRings(mol)
    else:
        return None</p>
<p>df['aromatic_rings'] = df['canonical_smiles'].apply(calculate_aromatic_rings)
print(df[['canonical_smiles', 'aromatic_rings']].head())</p>
<h1>3. L·ªçc c√°c h·ª£p ch·∫•t tu√¢n theo quy t·∫Øc 5 c·ªßa Lipinski</h1>
<h1>3. Filter compounds that follow Lipinski's rule of 5</h1>
<p>def lipinski_rule_of_five(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        hbd = Chem.Lipinski.NumHDonors(mol)
        hba = Chem.Lipinski.NumHAcceptors(mol)
        return mw &lt;= 500 and logp &lt;= 5 and hbd &lt;= 5 and hba &lt;= 10
    else:
        return False</p>
<p>df['lipinski_compliant'] = df['canonical_smiles'].apply(lipinski_rule_of_five)
lipinski_compliant_df = df[df['lipinski_compliant']]
print(f"Number of Lipinski-compliant compounds: {len(lipinski_compliant_df)}")</p>
<h1>4. L∆∞u c√°c fingerprints v√†o m·ªôt file</h1>
<h1>4. Save the fingerprints to a file</h1>
<p>from rdkit.Chem import MACCSkeys
import pickle</p>
<p>def calculate_maccs_keys(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return MACCSkeys.GenMACCSKeys(mol)
    else:
        return None</p>
<p>df['maccs_keys'] = df['canonical_smiles'].apply(calculate_maccs_keys)
maccs_keys_list = df['maccs_keys'].tolist()</p>
<p>with open('../data/maccs_keys.pkl', 'wb') as f:
    pickle.dump(maccs_keys_list, f)</p>
<h1>5. T√¨m c√°c c·∫•u tr√∫c con (substructure search)</h1>
<h1>5. Find substructures</h1>
<p>from rdkit.Chem import Draw</p>
<p>substructure_smiles = 'c1ccccc1' # Benzen
substructure = Chem.MolFromSmiles(substructure_smiles)</p>
<p>def has_substructure(smiles, substructure):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return mol.HasSubstructMatch(substructure)
    else:
        return False</p>
<p>df['has_benzene'] = df['canonical_smiles'].apply(lambda x: has_substructure(x, substructure))
benzene_containing_df = df[df['has_benzene']]</p>
<p>print(f"Number of compounds containing benzene: {len(benzene_containing_df)}")
```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng (Important Notes):</strong></p>
<ul>
<li><strong>ƒê∆∞·ªùng d·∫´n file (File Paths):</strong>  ƒê·∫£m b·∫£o r·∫±ng c√°c ƒë∆∞·ªùng d·∫´n ƒë·∫øn file CSV l√† ch√≠nh x√°c. S·ª≠ d·ª•ng <code>os.path.join(base_path, ...)</code> ƒë·ªÉ t·∫°o ƒë∆∞·ªùng d·∫´n m·ªôt c√°ch linh ho·∫°t.</li>
<li><strong>Phi√™n b·∫£n th∆∞ vi·ªán (Library Versions):</strong>  Ki·ªÉm tra v√† c·∫≠p nh·∫≠t c√°c th∆∞ vi·ªán (RDKit, Pandas, Scikit-learn) ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh t∆∞∆°ng th√≠ch v√† t·∫≠n d·ª•ng c√°c t√≠nh nƒÉng m·ªõi nh·∫•t.</li>
<li><strong>X·ª≠ l√Ω l·ªói (Error Handling):</strong>  Th√™m c√°c kh·ªëi <code>try...except</code> ƒë·ªÉ x·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω d·ªØ li·ªáu.</li>
<li><strong>B·ªô nh·ªõ (Memory):</strong> V·ªõi b·ªô d·ªØ li·ªáu l·ªõn, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t nh∆∞ chunking (ƒë·ªçc d·ªØ li·ªáu theo t·ª´ng ph·∫ßn) ƒë·ªÉ gi·∫£m thi·ªÉu vi·ªác s·ª≠ d·ª•ng b·ªô nh·ªõ.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        