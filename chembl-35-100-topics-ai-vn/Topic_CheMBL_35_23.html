
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_23</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Tr√≠ch xu·∫•t h·ª£p ch·∫•t g·∫Øn kinase</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n song ng·ªØ, code m·∫´u v√† c√°c v√≠ d·ª•, ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ gi√∫p b·∫°n tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£ nh·∫•t theo chu·∫©n AIMLOps Template.</p>
<p><strong>1. Ph√¢n t√≠ch M√¥ h√¨nh Ph√¢n t√≠ch (Analysis of the Analysis Model)</strong></p>
<p><strong>M·ª•c ti√™u:</strong></p>
<ul>
<li><strong>X√¢y d·ª±ng t·∫≠p d·ªØ li·ªáu:</strong> T·∫°o m·ªôt t·∫≠p d·ªØ li·ªáu t·ª´ ChEMBL 35 ch·ª©a th√¥ng tin v·ªÅ c·∫•u tr√∫c h√≥a h·ªçc (SMILES), ho·∫°t t√≠nh sinh h·ªçc (IC50, Ki, v.v.) v√† c√°c thu·ªôc t√≠nh li√™n quan kh√°c.</li>
<li><strong>T√≠nh to√°n Descriptors:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ t·ª´ c·∫•u tr√∫c SMILES. C√°c descriptor n√†y ƒë·∫°i di·ªán cho c√°c ƒë·∫∑c ƒëi·ªÉm h√≥a l√Ω c·ªßa ph√¢n t·ª≠.</li>
<li><strong>Ph√¢n t√≠ch T∆∞∆°ng quan:</strong> Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc. ƒêi·ªÅu n√†y gi√∫p x√°c ƒë·ªãnh c√°c ƒë·∫∑c ƒëi·ªÉm c·∫•u tr√∫c quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh.</li>
<li><strong>X√¢y d·ª±ng M√¥ h√¨nh D·ª± ƒëo√°n:</strong> X√¢y d·ª±ng m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc d·ª±a tr√™n c√°c descriptor.</li>
<li><strong>ƒê√°nh gi√° M√¥ h√¨nh:</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh tr√™n t·∫≠p d·ªØ li·ªáu ki·ªÉm tra.</li>
</ul>
<p><strong>C√°c B∆∞·ªõc Ch√≠nh:</strong></p>
<ol>
<li><strong>K·∫øt n·ªëi ƒë·∫øn ChEMBL Database:</strong> S·ª≠ d·ª•ng th√¥ng tin k·∫øt n·ªëi b·∫°n cung c·∫•p ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu.</li>
<li><strong>Truy v·∫•n D·ªØ li·ªáu:</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ c√°c b·∫£ng li√™n quan trong ChEMBL, nh∆∞ <code>activities</code>, <code>molecule_dictionary</code>, <code>compound_structures</code>, v.v.</li>
<li><strong>Ti·ªÅn x·ª≠ l√Ω D·ªØ li·ªáu:</strong> L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu, lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá ho·∫∑c thi·∫øu.</li>
<li><strong>T√≠nh to√°n Descriptors:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ chuy·ªÉn ƒë·ªïi SMILES th√†nh c√°c ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ v√† t√≠nh to√°n c√°c descriptor.</li>
<li><strong>Ph√¢n t√≠ch T∆∞∆°ng quan:</strong> S·ª≠ d·ª•ng c√°c ph∆∞∆°ng ph√°p th·ªëng k√™ ƒë·ªÉ x√°c ƒë·ªãnh m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
<li><strong>X√¢y d·ª±ng M√¥ h√¨nh:</strong> Ch·ªçn m·ªôt thu·∫≠t to√°n h·ªçc m√°y ph√π h·ª£p (v√≠ d·ª•: Random Forest, SVM, Linear Regression) v√† hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p d·ªØ li·ªáu hu·∫•n luy·ªán.</li>
<li><strong>ƒê√°nh gi√° M√¥ h√¨nh:</strong> ƒê√°nh gi√° m√¥ h√¨nh tr√™n t·∫≠p d·ªØ li·ªáu ki·ªÉm tra b·∫±ng c√°c ch·ªâ s·ªë nh∆∞ R-squared, RMSE, MAE.</li>
</ol>
<p><strong>2. H∆∞·ªõng D·∫´n Song Ng·ªØ (Bilingual Guidance)</strong></p>
<p><strong>B∆∞·ªõc 1: K·∫øt n·ªëi ƒë·∫øn ChEMBL Database (Connecting to ChEMBL Database)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng th√¥ng tin k·∫øt n·ªëi (IP, user, pass, database) ƒë·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 tr√™n PostgreSQL.</li>
<li><strong>English:</strong> Use the connection information (IP, user, pass, database) to connect to the ChEMBL 35 database on PostgreSQL.</li>
</ul>
<p><strong>B∆∞·ªõc 2: Truy v·∫•n D·ªØ li·ªáu (Data Query)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc, c·∫•u tr√∫c SMILES v√† c√°c th√¥ng tin li√™n quan kh√°c t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL.</li>
<li><strong>English:</strong> Use SQL to query bioactivity data, SMILES structures, and other relevant information from the ChEMBL database.</li>
</ul>
<p><strong>B∆∞·ªõc 3: Ti·ªÅn X·ª≠ L√Ω D·ªØ Li·ªáu (Data Preprocessing)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> L√†m s·∫°ch d·ªØ li·ªáu, x·ª≠ l√Ω c√°c gi√° tr·ªã thi·∫øu, v√† chu·∫©n h√≥a d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: chuy·ªÉn ƒë·ªïi IC50 sang pIC50).</li>
<li><strong>English:</strong> Clean the data, handle missing values, and standardize bioactivity data (e.g., convert IC50 to pIC50).</li>
</ul>
<p><strong>B∆∞·ªõc 4: T√≠nh To√°n Descriptors (Descriptor Calculation)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ t·ª´ c·∫•u tr√∫c SMILES.</li>
<li><strong>English:</strong> Use RDKit to calculate molecular descriptors from SMILES structures.</li>
</ul>
<p><strong>B∆∞·ªõc 5: Ph√¢n T√≠ch T∆∞∆°ng Quan (Correlation Analysis)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc ƒë·ªÉ x√°c ƒë·ªãnh c√°c y·∫øu t·ªë quan tr·ªçng.</li>
<li><strong>English:</strong> Analyze the correlation between descriptors and bioactivity to identify important factors.</li>
</ul>
<p><strong>B∆∞·ªõc 6: X√¢y D·ª±ng M√¥ H√¨nh (Model Building)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> X√¢y d·ª±ng m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc d·ª±a tr√™n c√°c descriptor.</li>
<li><strong>English:</strong> Build a machine learning model to predict bioactivity based on descriptors.</li>
</ul>
<p><strong>B∆∞·ªõc 7: ƒê√°nh Gi√° M√¥ H√¨nh (Model Evaluation)</strong></p>
<ul>
<li><strong>Ti·∫øng Vi·ªát:</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c ch·ªâ s·ªë ƒë√°nh gi√° ph√π h·ª£p.</li>
<li><strong>English:</strong> Evaluate the performance of the model using appropriate evaluation metrics.</li>
</ul>
<p><strong>3. Code SQL, Python (English)</strong></p>
<p><strong>SQL (to extract 100 rows of data):</strong></p>
<p><code>sql
-- SQL query to extract 100 rows of data
SELECT
    md.chembl_id,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary md ON act.molregno = md.molregno
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND cs.canonical_smiles IS NOT NULL
    AND act.standard_value ~ '^[0-9\.]+$' -- fix error a
LIMIT 100;</code></p>
<p><strong>Python (Jupyter Notebook):</strong></p>
<p>```python
import os
import pandas as pd
import psycopg2
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler</p>
<h1>Database connection details</h1>
<p>ip = '192.168.206.136'
user = 'rd'
password = 'rd'
database = 'chembl_35'</p>
<h1>Base path for AIMLOps template</h1>
<p>base_path = '../data'  # Adjust if needed</p>
<h1>SQL query to extract data</h1>
<p>sql_query = """
SELECT
    md.chembl_id,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary md ON act.molregno = md.molregno
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND cs.canonical_smiles IS NOT NULL
    AND act.standard_value ~ '^[0-9.]+$'
LIMIT 100;
"""</p>
<h1>Function to connect to the database and execute the query</h1>
<p>def fetch_data(ip, user, password, database, query):
    conn = None
    try:
        conn = psycopg2.connect(host=ip, user=user, password=password, database=database)
        df = pd.read_sql_query(query, conn)
        return df
    except psycopg2.Error as e:
        print(f"Error connecting to the database: {e}")
        return None
    finally:
        if conn:
            conn.close()</p>
<h1>Fetch data from the database</h1>
<p>df = fetch_data(ip, user, password, database, sql_query)</p>
<h1>Check if data was fetched successfully</h1>
<p>if df is None or df.empty:
    print("Failed to fetch data from the database.")
    exit()</p>
<h1>Data preprocessing: Convert IC50 to pIC50</h1>
<p>df = df.dropna(subset=['standard_value', 'canonical_smiles'])
df = df[df['standard_value'].astype(str).str.match(r'^[0-9.]+$')]  # Keep only numeric values
df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')
df = df.dropna(subset=['standard_value'])
df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to M and then to pIC50</p>
<h1>RDKit: Calculate molecular descriptors</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    for name, func in Descriptors.descList:
        try:
            descriptors[name] = func(mol)
        except:
            descriptors[name] = None
    return descriptors</p>
<p>df['descriptors'] = df['canonical_smiles'].apply(calculate_descriptors)
df = df.dropna(subset=['descriptors'])</p>
<h1>Convert descriptors to DataFrame</h1>
<p>descriptors_df = pd.DataFrame(df['descriptors'].tolist())
df = pd.concat([df, descriptors_df], axis=1)</p>
<h1>Prepare data for machine learning</h1>
<p>X = df.drop(['chembl_id', 'canonical_smiles', 'standard_type', 'standard_value', 'standard_units', 'pIC50', 'descriptors'], axis=1)
y = df['pIC50']</p>
<h1>Handle missing values by filling with the mean</h1>
<p>X = X.fillna(X.mean())</p>
<h1>Scale the features</h1>
<p>scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)</p>
<h1>Train a Random Forest Regressor model</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")</p>
<h1>Save results to CSV</h1>
<p>output_file = os.path.join(base_path, 'chembl_35_results.csv')
df.to_csv(output_file, index=False)
print(f"Results saved to {output_file}")
```</p>
<p><strong>Gi·∫£i th√≠ch Code:</strong></p>
<ol>
<li><strong>K·∫øt n·ªëi Database:</strong> S·ª≠ d·ª•ng <code>psycopg2</code> ƒë·ªÉ k·∫øt n·ªëi ƒë·∫øn database ChEMBL 35.</li>
<li><strong>Truy V·∫•n SQL:</strong> Truy v·∫•n d·ªØ li·ªáu c·∫ßn thi·∫øt t·ª´ c√°c b·∫£ng <code>activities</code>, <code>molecule_dictionary</code>, v√† <code>compound_structures</code>.</li>
<li><strong>Ti·ªÅn X·ª≠ L√Ω:</strong><ul>
<li>Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50.</li>
<li>Lo·∫°i b·ªè c√°c gi√° tr·ªã thi·∫øu.</li>
</ul>
</li>
<li><strong>T√≠nh To√°n Descriptors:</strong><ul>
<li>S·ª≠ d·ª•ng RDKit ƒë·ªÉ chuy·ªÉn ƒë·ªïi SMILES th√†nh c√°c descriptor ph√¢n t·ª≠.</li>
</ul>
</li>
<li><strong>X√¢y D·ª±ng M√¥ H√¨nh:</strong><ul>
<li>S·ª≠ d·ª•ng <code>RandomForestRegressor</code> t·ª´ <code>sklearn</code>.</li>
<li>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.</li>
<li>Hu·∫•n luy·ªán m√¥ h√¨nh v√† ƒë√°nh gi√° hi·ªáu su·∫•t.</li>
</ul>
</li>
<li><strong>L∆∞u K·∫øt Qu·∫£:</strong> L∆∞u k·∫øt qu·∫£ v√†o file CSV.</li>
</ol>
<p><strong>L∆∞u √Ω:</strong></p>
<ul>
<li>ƒê·∫£m b·∫£o ƒë√£ c√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt: <code>psycopg2</code>, <code>rdkit</code>, <code>pandas</code>, <code>scikit-learn</code>.</li>
<li>ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n <code>base_path</code> cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c c·ªßa b·∫°n.</li>
<li>Phi√™n b·∫£n scikit-learn c≈© c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ <code>squared=False</code> trong <code>mean_squared_error</code>. B·∫°n c√≥ th·ªÉ b·ªè tham s·ªë n√†y n·∫øu g·∫∑p l·ªói.</li>
<li>S·ª≠a l·ªói "ERROR: operator does not exist: numeric ~ unknown" b·∫±ng c√°ch th√™m d√≤ng <code>AND act.standard_value ~ '^[0-9\.]+$'</code> ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ l·∫•y c√°c gi√° tr·ªã s·ªë.</li>
</ul>
<p><strong>4. V√≠ D·ª• Code SQL v√† Python M·∫´u (SQL and Python Code Examples)</strong></p>
<p><strong>V√≠ d·ª• 1: L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã IC50 (Filtering data by IC50 range)</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
SELECT
    md.chembl_id,
    cs.canonical_smiles,
    act.standard_value
FROM
    activities act
JOIN
    molecule_dictionary md ON act.molregno = md.molregno
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value BETWEEN 100 AND 1000 -- IC50 between 100 and 1000 nM
    AND act.standard_value ~ '^[0-9\.]+$'
LIMIT 100;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python</p>
<h1>Add this condition to the SQL query in the Python code</h1>
<p>sql_query = """
SELECT
    md.chembl_id,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    activities act
JOIN
    molecule_dictionary md ON act.molregno = md.molregno
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value BETWEEN 100 AND 1000
    AND act.standard_value ~ '^[0-9.]+$'
LIMIT 100;
"""
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n s·ªë l∆∞·ª£ng c√°c ch·∫•t c√≥ c√πng scaffold (Calculating the number of compounds with the same scaffold)</strong></p>
<ul>
<li><strong>SQL:</strong></li>
</ul>
<p><code>sql
-- Requires a table with pre-calculated scaffolds
-- Assuming you have a 'scaffolds' table with 'molregno' and 'murcko_scaffold' columns
SELECT
    s.murcko_scaffold,
    COUNT(DISTINCT md.chembl_id) AS compound_count
FROM
    scaffolds s
JOIN
    molecule_dictionary md ON s.molregno = md.molregno
GROUP BY
    s.murcko_scaffold
ORDER BY
    compound_count DESC
LIMIT 10;</code></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
from rdkit.Chem import MurckoScaffold</p>
<p>def calculate_murcko_scaffold(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return MurckoScaffold.GetScaffoldForMol(mol).GetSmiles()
    return None</p>
<p>df['murcko_scaffold'] = df['canonical_smiles'].apply(calculate_murcko_scaffold)
scaffold_counts = df['murcko_scaffold'].value_counts().reset_index()
scaffold_counts.columns = ['murcko_scaffold', 'compound_count']
print(scaffold_counts.head(10))
```</p>
<p><strong>V√≠ d·ª• 3: S·ª≠ d·ª•ng c√°c lo·∫°i descriptors kh√°c nhau (Using different types of descriptors)</strong></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
from rdkit.Chem import Crippen, Lipinski</p>
<p>def calculate_more_descriptors(mol):
    if mol is None:
        return {}
    descriptors = {
        "MolLogP": Crippen.MolLogP(mol),
        "NumHAcceptors": Lipinski.NumHAcceptors(mol),
        "NumHDonors": Lipinski.NumHDonors(mol)
    }
    return descriptors</p>
<p>df['additional_descriptors'] = df['canonical_smiles'].apply(lambda x: calculate_more_descriptors(Chem.MolFromSmiles(x)))
additional_descriptors_df = pd.DataFrame(df['additional_descriptors'].tolist())
df = pd.concat([df, additional_descriptors_df], axis=1)
```</p>
<p><strong>V√≠ d·ª• 4: Thay ƒë·ªïi thu·∫≠t to√°n h·ªçc m√°y (Changing the machine learning algorithm)</strong></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
from sklearn.svm import SVR</p>
<h1>Train a Support Vector Regression model</h1>
<p>model = SVR(kernel='rbf')  # You can also try 'linear', 'poly', 'sigmoid'
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>V√≠ d·ª• 5: L∆∞u m√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán (Saving the trained model)</strong></p>
<ul>
<li><strong>Python:</strong></li>
</ul>
<p>```python
import joblib</p>
<h1>Train your model...</h1>
<h1>Save the model</h1>
<p>model_file = os.path.join(base_path, 'chembl_35_model.pkl')
joblib.dump(model, model_file)
print(f"Model saved to {model_file}")</p>
<h1>Load the model later</h1>
<p>loaded_model = joblib.load(model_file)
```</p>
<p>Hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n tri·ªÉn khai d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 m·ªôt c√°ch hi·ªáu qu·∫£. Ch√∫c b·∫°n th√†nh c√¥ng!</p>
        </body>
        </html>
        