
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_74</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: V·∫Ω 3D kh√¥ng gian h√≥a h·ªçc ph√¢n t·ª≠</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i hi·ªÉu r√µ t·∫ßm quan tr·ªçng c·ªßa vi·ªác khai th√°c d·ªØ li·ªáu ChEMBL ƒë·ªÉ t√¨m ki·∫øm c√°c h·ª£p ch·∫•t ti·ªÅm nƒÉng. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n song ng·ªØ, code m·∫´u SQL v√† Python, c√πng v·ªõi c√°c v√≠ d·ª• ƒë·ªÉ b·∫°n b·∫Øt ƒë·∫ßu.</p>
<p><strong>1. Ph√¢n t√≠ch M√¥ h√¨nh Ph√¢n t√≠ch (Analysis of the Analysis Model)</strong></p>
<p>D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35, m·ªôt c∆° s·ªü d·ªØ li·ªáu l·ªõn ch·ª©a th√¥ng tin v·ªÅ c√°c ph√¢n t·ª≠ ho·∫°t t√≠nh sinh h·ªçc. M·ª•c ti√™u l√† s·ª≠ d·ª•ng RDKit ƒë·ªÉ tr√≠ch xu·∫•t c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc t·ª´ c·∫•u tr√∫c ph√¢n t·ª≠ v√† k·∫øt h·ª£p ch√∫ng v·ªõi d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc ƒë·ªÉ x√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n.</p>
<ul>
<li><strong>Data Source (Ngu·ªìn d·ªØ li·ªáu):</strong> ChEMBL 35 database.</li>
<li><strong>Tools (C√¥ng c·ª•):</strong><ul>
<li>psql (PostgreSQL) for database querying.</li>
<li>RDKit for chemical feature extraction.</li>
<li>Jupyter Notebook for code execution and documentation.</li>
<li>Scikit-learn (or other machine learning libraries) for model building.</li>
</ul>
</li>
<li><strong>Steps (C√°c b∆∞·ªõc):</strong><ol>
<li><strong>Data Extraction (Tr√≠ch xu·∫•t d·ªØ li·ªáu):</strong> Use SQL queries to extract relevant data from ChEMBL, such as compound structures (SMILES) and activity data (IC50, Ki, etc.).</li>
<li><strong>Feature Generation (T·∫°o ƒë·∫∑c tr∆∞ng):</strong> Use RDKit to generate molecular descriptors (e.g., fingerprints, physicochemical properties) from the SMILES strings.</li>
<li><strong>Data Preprocessing (Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu):</strong> Clean and prepare the data for modeling. This may involve handling missing values, scaling features, and splitting the data into training and testing sets.</li>
<li><strong>Model Building (X√¢y d·ª±ng m√¥ h√¨nh):</strong> Train a machine learning model to predict activity based on the molecular descriptors. Common models include Random Forest, Support Vector Machines, and Neural Networks.</li>
<li><strong>Model Evaluation (ƒê√°nh gi√° m√¥ h√¨nh):</strong> Evaluate the performance of the model using appropriate metrics (e.g., AUC, RMSE, R-squared).</li>
<li><strong>Analysis and Interpretation (Ph√¢n t√≠ch v√† gi·∫£i th√≠ch):</strong> Analyze the model to identify important features and gain insights into the structure-activity relationship.</li>
</ol>
</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt b·∫±ng c·∫£ ti·∫øng Anh v√† ti·∫øng Vi·ªát:</p>
<ul>
<li>
<p><strong>English:</strong></p>
<ol>
<li><strong>Connect to the ChEMBL database using psql.</strong></li>
<li><strong>Execute SQL queries to extract the desired data (e.g., compound structures and activity data).</strong></li>
<li><strong>Save the extracted data as CSV files in the <code>../data/</code> directory.</strong></li>
<li><strong>Load the CSV files into a Jupyter Notebook.</strong></li>
<li><strong>Use RDKit to generate molecular descriptors from the SMILES strings.</strong></li>
<li><strong>Preprocess the data (handle missing values, scale features, etc.).</strong></li>
<li><strong>Split the data into training and testing sets.</strong></li>
<li><strong>Train a machine learning model to predict activity.</strong></li>
<li><strong>Evaluate the model's performance.</strong></li>
<li><strong>Analyze the model to identify important features and gain insights into the structure-activity relationship.</strong></li>
<li>
<p><strong>Ti·∫øng Vi·ªát:</strong></p>
</li>
<li>
<p><strong>K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL b·∫±ng psql.</strong></p>
</li>
<li><strong>Th·ª±c hi·ªán c√°c truy v·∫•n SQL ƒë·ªÉ tr√≠ch xu·∫•t d·ªØ li·ªáu mong mu·ªën (v√≠ d·ª•: c·∫•u tr√∫c h·ª£p ch·∫•t v√† d·ªØ li·ªáu ho·∫°t t√≠nh).</strong></li>
<li><strong>L∆∞u d·ªØ li·ªáu ƒë√£ tr√≠ch xu·∫•t d∆∞·ªõi d·∫°ng t·ªáp CSV trong th∆∞ m·ª•c <code>../data/</code>.</strong></li>
<li><strong>T·∫£i c√°c t·ªáp CSV v√†o Jupyter Notebook.</strong></li>
<li><strong>S·ª≠ d·ª•ng RDKit ƒë·ªÉ t·∫°o c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ t·ª´ chu·ªói SMILES.</strong></li>
<li><strong>Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (x·ª≠ l√Ω gi√° tr·ªã thi·∫øu, chia t·ª∑ l·ªá ƒë·∫∑c tr∆∞ng, v.v.).</strong></li>
<li><strong>Chia d·ªØ li·ªáu th√†nh c√°c t·∫≠p hu·∫•n luy·ªán v√† ki·ªÉm tra.</strong></li>
<li><strong>Hu·∫•n luy·ªán m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh.</strong></li>
<li><strong>ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh.</strong></li>
<li><strong>Ph√¢n t√≠ch m√¥ h√¨nh ƒë·ªÉ x√°c ƒë·ªãnh c√°c ƒë·∫∑c tr∆∞ng quan tr·ªçng v√† hi·ªÉu r√µ h∆°n v·ªÅ m·ªëi quan h·ªá c·∫•u tr√∫c-ho·∫°t t√≠nh.</strong></li>
</ol>
</li>
</ul>
<p><strong>3. Code SQL v√† Python m·∫´u (Sample SQL and Python Code)</strong></p>
<p><strong>SQL (English):</strong></p>
<p><code>sql
-- Extract 100 compounds with IC50 values for a specific target
SELECT
    molregno,
    compound_structures.canonical_smiles,
    activities.standard_value,
    activities.standard_units
FROM
    compound_structures
JOIN
    activities ON compound_structures.molregno = activities.molregno
JOIN
    target_dictionary ON activities.tid = target_dictionary.tid
WHERE
    target_dictionary.pref_name = 'desired_target_name'  -- Replace with your target
    AND activities.standard_type = 'IC50'
    AND activities.standard_units = 'nM'
    AND act.standard_value ~ '^[0-9\.]+$'  -- Only numeric values
LIMIT 100;</code></p>
<p><strong>SQL (Ti·∫øng Vi·ªát):</strong></p>
<p><code>sql
-- Tr√≠ch xu·∫•t 100 h·ª£p ch·∫•t v·ªõi gi√° tr·ªã IC50 cho m·ªôt m·ª•c ti√™u c·ª• th·ªÉ
SELECT
    molregno,
    compound_structures.canonical_smiles,
    activities.standard_value,
    activities.standard_units
FROM
    compound_structures
JOIN
    activities ON compound_structures.molregno = activities.molregno
JOIN
    target_dictionary ON activities.tid = target_dictionary.tid
WHERE
    target_dictionary.pref_name = 'desired_target_name'  -- Thay th·∫ø b·∫±ng m·ª•c ti√™u c·ªßa b·∫°n
    AND activities.standard_type = 'IC50'
    AND activities.standard_units = 'nM'
    AND act.standard_value ~ '^[0-9\.]+$'  -- Ch·ªâ gi√° tr·ªã s·ªë
LIMIT 100;</code></p>
<p><strong>Python (English):</strong></p>
<p>```python
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Define the base path</h1>
<p>base_path = "../data/"</p>
<h1>Load the data from CSV</h1>
<p>data = pd.read_csv(os.path.join(base_path, "your_data.csv"))  # Replace with your CSV file</p>
<h1>Function to calculate molecular descriptors</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        descriptors = {}
        descriptors['MolLogP'] = Descriptors.MolLogP(mol)
        descriptors['MolWt'] = Descriptors.MolWt(mol)
        descriptors['NumHAcceptors'] = Descriptors.NumHAcceptors(mol)
        descriptors['NumHDonors'] = Descriptors.NumHDonors(mol)
        return descriptors
    else:
        return None</p>
<h1>Apply the function to each SMILES string</h1>
<p>data['descriptors'] = data['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>Handle missing descriptors</h1>
<p>data = data.dropna(subset=['descriptors'])</p>
<h1>Convert descriptors to DataFrame</h1>
<p>descriptors_df = pd.DataFrame(data['descriptors'].tolist())
data = pd.concat([data, descriptors_df], axis=1)</p>
<h1>Prepare data for modeling</h1>
<p>X = data[['MolLogP', 'MolWt', 'NumHAcceptors', 'NumHDonors']]  # Use only available descriptors
y = data['standard_value']</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Train a Random Forest Regressor model</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>Python (Ti·∫øng Vi·ªát):</strong></p>
<p>```python
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n c∆° s·ªü</h1>
<p>base_path = "../data/"</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ t·ªáp CSV</h1>
<p>data = pd.read_csv(os.path.join(base_path, "your_data.csv"))  # Thay th·∫ø b·∫±ng t·ªáp CSV c·ªßa b·∫°n</p>
<h1>H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        descriptors = {}
        descriptors['MolLogP'] = Descriptors.MolLogP(mol)
        descriptors['MolWt'] = Descriptors.MolWt(mol)
        descriptors['NumHAcceptors'] = Descriptors.NumHAcceptors(mol)
        descriptors['NumHDonors'] = Descriptors.NumHDonors(mol)
        return descriptors
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho m·ªói chu·ªói SMILES</h1>
<p>data['descriptors'] = data['canonical_smiles'].apply(calculate_descriptors)</p>
<h1>X·ª≠ l√Ω c√°c descriptor b·ªã thi·∫øu</h1>
<p>data = data.dropna(subset=['descriptors'])</p>
<h1>Chuy·ªÉn ƒë·ªïi descriptors th√†nh DataFrame</h1>
<p>descriptors_df = pd.DataFrame(data['descriptors'].tolist())
data = pd.concat([data, descriptors_df], axis=1)</p>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu cho m√¥ h√¨nh h√≥a</h1>
<p>X = data[['MolLogP', 'MolWt', 'NumHAcceptors', 'NumHDonors']]  # Ch·ªâ s·ª≠ d·ª•ng c√°c descriptor c√≥ s·∫µn
y = data['standard_value']</p>
<h1>Chia d·ªØ li·ªáu th√†nh c√°c t·∫≠p hu·∫•n luy·ªán v√† ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest Regressor</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>D·ª± ƒëo√°n</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```</p>
<p><strong>4. V√≠ d·ª• Code SQL v√† Python (SQL and Python Code Examples)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• v·ªÅ code SQL v√† Python ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>Example 1: Extract compounds with specific activity range</strong></p>
<ul>
<li><strong>SQL (English):</strong></li>
</ul>
<p><code>sql
SELECT molregno, compound_structures.canonical_smiles, activities.standard_value
FROM compound_structures
JOIN activities ON compound_structures.molregno = activities.molregno
WHERE activities.standard_type = 'IC50'
AND activities.standard_units = 'nM'
AND activities.standard_value &gt;= 100 AND activities.standard_value &lt;= 1000
LIMIT 100;</code></p>
<ul>
<li><strong>SQL (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p><code>sql
SELECT molregno, compound_structures.canonical_smiles, activities.standard_value
FROM compound_structures
JOIN activities ON compound_structures.molregno = activities.molregno
WHERE activities.standard_type = 'IC50'
AND activities.standard_units = 'nM'
AND activities.standard_value &gt;= 100 AND activities.standard_value &lt;= 1000
LIMIT 100;</code></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python</p>
<h1>Read the CSV file</h1>
<p>df = pd.read_csv(os.path.join(base_path, "activity_range.csv"))</p>
<h1>Print the number of rows and columns</h1>
<p>print(f"Number of rows: {len(df)}")
print(f"Number of columns: {len(df.columns)}")</p>
<h1>Print the first 5 rows of the DataFrame</h1>
<p>print(df.head())
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python</p>
<h1>ƒê·ªçc file CSV</h1>
<p>df = pd.read_csv(os.path.join(base_path, "activity_range.csv"))</p>
<h1>In s·ªë l∆∞·ª£ng h√†ng v√† c·ªôt</h1>
<p>print(f"S·ªë l∆∞·ª£ng h√†ng: {len(df)}")
print(f"S·ªë l∆∞·ª£ng c·ªôt: {len(df.columns)}")</p>
<h1>In 5 h√†ng ƒë·∫ßu ti√™n c·ªßa DataFrame</h1>
<p>print(df.head())
```</p>
<p><strong>Example 2: Calculate Lipinski's Rule of Five</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
def lipinski_rule_of_five(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        hbd = Descriptors.NumHDonors(mol)
        hba = Descriptors.NumHAcceptors(mol)</p>
<pre><code>    # Check Lipinski's rule of five
    rule_1 = mw &lt;= 500
    rule_2 = logp &lt;= 5
    rule_3 = hbd &lt;= 5
    rule_4 = hba &lt;= 10

    # Count number of rules that fail
    num_failed_rules = sum([not rule_1, not rule_2, not rule_3, not rule_4])
    return num_failed_rules
else:
    return None
</code></pre>
<h1>Apply Lipinski's Rule of Five to each SMILES</h1>
<p>df['Lipinski_Failures'] = df['canonical_smiles'].apply(lipinski_rule_of_five)</p>
<h1>Print the results</h1>
<p>print(df[['canonical_smiles', 'Lipinski_Failures']].head())
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
def lipinski_rule_of_five(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        hbd = Descriptors.NumHDonors(mol)
        hba = Descriptors.NumHAcceptors(mol)</p>
<pre><code>    # Ki·ªÉm tra quy t·∫Øc 5 c·ªßa Lipinski
    rule_1 = mw &lt;= 500
    rule_2 = logp &lt;= 5
    rule_3 = hbd &lt;= 5
    rule_4 = hba &lt;= 10

    # ƒê·∫øm s·ªë l∆∞·ª£ng quy t·∫Øc kh√¥ng ƒë·∫°t
    num_failed_rules = sum([not rule_1, not rule_2, not rule_3, not rule_4])
    return num_failed_rules
else:
    return None
</code></pre>
<h1>√Åp d·ª•ng quy t·∫Øc 5 c·ªßa Lipinski cho m·ªói SMILES</h1>
<p>df['Lipinski_Failures'] = df['canonical_smiles'].apply(lipinski_rule_of_five)</p>
<h1>In k·∫øt qu·∫£</h1>
<p>print(df[['canonical_smiles', 'Lipinski_Failures']].head())
```</p>
<p><strong>Example 3: Extract compounds based on substructure</strong></p>
<ul>
<li><strong>SQL (English):</strong></li>
</ul>
<p><code>sql
SELECT molregno, compound_structures.canonical_smiles
FROM compound_structures
WHERE compound_structures.canonical_smiles LIKE '%C=O%'  -- Example: compounds containing a carbonyl group
LIMIT 100;</code></p>
<ul>
<li><strong>SQL (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p><code>sql
SELECT molregno, compound_structures.canonical_smiles
FROM compound_structures
WHERE compound_structures.canonical_smiles LIKE '%C=O%'  -- V√≠ d·ª•: h·ª£p ch·∫•t ch·ª©a nh√≥m carbonyl
LIMIT 100;</code></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
from rdkit import Chem</p>
<p>def check_substructure(smiles, substructure_smarts):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        substructure = Chem.MolFromSmarts(substructure_smarts)
        if substructure is not None:
            return mol.HasSubstructMatch(substructure)
        else:
            return False
    else:
        return False</p>
<h1>Define substructure SMARTS</h1>
<p>substructure_smarts = "C=O"  # Carbonyl group</p>
<h1>Apply the function to each SMILES</h1>
<p>df['Has_Carbonyl'] = df['canonical_smiles'].apply(lambda x: check_substructure(x, substructure_smarts))</p>
<h1>Print the results</h1>
<p>print(df[['canonical_smiles', 'Has_Carbonyl']].head())
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
from rdkit import Chem</p>
<p>def check_substructure(smiles, substructure_smarts):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        substructure = Chem.MolFromSmarts(substructure_smarts)
        if substructure is not None:
            return mol.HasSubstructMatch(substructure)
        else:
            return False
    else:
        return False</p>
<h1>X√°c ƒë·ªãnh c·∫•u tr√∫c con SMARTS</h1>
<p>substructure_smarts = "C=O"  # Nh√≥m carbonyl</p>
<h1>√Åp d·ª•ng h√†m cho m·ªói SMILES</h1>
<p>df['Has_Carbonyl'] = df['canonical_smiles'].apply(lambda x: check_substructure(x, substructure_smarts))</p>
<h1>In k·∫øt qu·∫£</h1>
<p>print(df[['canonical_smiles', 'Has_Carbonyl']].head())
```</p>
<p><strong>Example 4: Calculate Molecular Weight</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<p>def calculate_molecular_weight(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>Apply the function to each SMILES</h1>
<p>df['Molecular_Weight'] = df['canonical_smiles'].apply(calculate_molecular_weight)</p>
<h1>Print the results</h1>
<p>print(df[['canonical_smiles', 'Molecular_Weight']].head())
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<p>def calculate_molecular_weight(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho m·ªói SMILES</h1>
<p>df['Molecular_Weight'] = df['canonical_smiles'].apply(calculate_molecular_weight)</p>
<h1>In k·∫øt qu·∫£</h1>
<p>print(df[['canonical_smiles', 'Molecular_Weight']].head())
```</p>
<p><strong>Example 5: Visualize Molecules</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw</p>
<p>def visualize_molecule(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        return Draw.MolToImage(mol)
    else:
        return None</p>
<h1>Visualize the first molecule</h1>
<p>img = visualize_molecule(df['canonical_smiles'].iloc[0])
img
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Draw</p>
<p>def visualize_molecule(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        return Draw.MolToImage(mol)
    else:
        return None</p>
<h1>Visualize ph√¢n t·ª≠ ƒë·∫ßu ti√™n</h1>
<p>img = visualize_molecule(df['canonical_smiles'].iloc[0])
img
```</p>
<p><strong>5. Gi·∫£i quy·∫øt l·ªói (Error Resolution)</strong></p>
<ul>
<li>
<p><strong>ERROR: operator does not exist: numeric ~ unknown LINE 12: AND act.standard_value ~ '^[0-9.]+$'</strong></p>
<ul>
<li><strong>Explanation (Gi·∫£i th√≠ch):</strong> L·ªói n√†y x·∫£y ra v√¨ to√°n t·ª≠ <code>~</code> (regex match) kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr·ª±c ti·∫øp tr√™n ki·ªÉu d·ªØ li·ªáu <code>numeric</code> trong PostgreSQL.</li>
<li><strong>Solution (Gi·∫£i ph√°p):</strong> Chuy·ªÉn ƒë·ªïi c·ªôt <code>standard_value</code> sang ki·ªÉu <code>text</code> tr∆∞·ªõc khi so s√°nh v·ªõi bi·ªÉu th·ª©c ch√≠nh quy.</li>
<li><strong>SQL (English):</strong></li>
</ul>
</li>
</ul>
<p><code>sql
SELECT
    molregno,
    compound_structures.canonical_smiles,
    activities.standard_value,
    activities.standard_units
FROM
    compound_structures
JOIN
    activities ON compound_structures.molregno = activities.molregno
JOIN
    target_dictionary ON activities.tid = target_dictionary.tid
WHERE
    target_dictionary.pref_name = 'desired_target_name'  -- Replace with your target
    AND activities.standard_type = 'IC50'
    AND activities.standard_units = 'nM'
    AND CAST(activities.standard_value AS TEXT) ~ '^[0-9\.]+$'  -- Convert to TEXT
LIMIT 100;</code></p>
<pre><code>*   **SQL (Ti·∫øng Vi·ªát):**
</code></pre>
<p><code>sql
SELECT
    molregno,
    compound_structures.canonical_smiles,
    activities.standard_value,
    activities.standard_units
FROM
    compound_structures
JOIN
    activities ON compound_structures.molregno = activities.molregno
JOIN
    target_dictionary ON activities.tid = target_dictionary.tid
WHERE
    target_dictionary.pref_name = 'desired_target_name'  -- Thay th·∫ø b·∫±ng m·ª•c ti√™u c·ªßa b·∫°n
    AND activities.standard_type = 'IC50'
    AND activities.standard_units = 'nM'
    AND CAST(activities.standard_value AS TEXT) ~ '^[0-9\.]+$'  -- Chuy·ªÉn ƒë·ªïi sang TEXT
LIMIT 100;</code></p>
<ul>
<li>
<p><strong>Phi√™n b·∫£n scikit-learn c≈© kh√¥ng h·ªó tr·ª£ tham s·ªë <code>squared=False</code> trong h√†m <code>mean_squared_error</code></strong></p>
<ul>
<li><strong>Explanation (Gi·∫£i th√≠ch):</strong> Tham s·ªë <code>squared=False</code> ƒë∆∞·ª£c th√™m v√†o h√†m <code>mean_squared_error</code> trong c√°c phi√™n b·∫£n scikit-learn m·ªõi h∆°n ƒë·ªÉ tr·∫£ v·ªÅ Root Mean Squared Error (RMSE) thay v√¨ Mean Squared Error (MSE).</li>
<li>
<p><strong>Solution (Gi·∫£i ph√°p):</strong></p>
<ol>
<li><strong>Update scikit-learn (C·∫≠p nh·∫≠t scikit-learn):</strong> N√¢ng c·∫•p phi√™n b·∫£n scikit-learn c·ªßa b·∫°n l√™n phi√™n b·∫£n m·ªõi nh·∫•t b·∫±ng l·ªánh <code>pip install --upgrade scikit-learn</code>.</li>
<li>
<p><strong>Calculate RMSE manually (T√≠nh RMSE th·ªß c√¥ng):</strong> N·∫øu b·∫°n kh√¥ng th·ªÉ n√¢ng c·∫•p scikit-learn, b·∫°n c√≥ th·ªÉ t√≠nh RMSE b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE.</p>
</li>
<li>
<p><strong>Python (English):</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>```python
from sklearn.metrics import mean_squared_error
import numpy as np</p>
<h1>Calculate MSE</h1>
<p>mse = mean_squared_error(y_test, y_pred)</p>
<h1>Calculate RMSE</h1>
<p>rmse = np.sqrt(mse)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
```</p>
<pre><code>    *   **Python (Ti·∫øng Vi·ªát):**
</code></pre>
<p>```python
from sklearn.metrics import mean_squared_error
import numpy as np</p>
<h1>T√≠nh MSE</h1>
<p>mse = mean_squared_error(y_test, y_pred)</p>
<h1>T√≠nh RMSE</h1>
<p>rmse = np.sqrt(mse)</p>
<p>print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
```</p>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li>H√£y thay th·∫ø <code>"your_data.csv"</code> v√† <code>"desired_target_name"</code> b·∫±ng t√™n t·ªáp v√† m·ª•c ti√™u c·ª• th·ªÉ c·ªßa b·∫°n.</li>
<li>ƒê·∫£m b·∫£o r·∫±ng b·∫°n ƒë√£ c√†i ƒë·∫∑t t·∫•t c·∫£ c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt (RDKit, pandas, scikit-learn, etc.) tr∆∞·ªõc khi ch·∫°y code Python.</li>
<li>Khi l√†m vi·ªác v·ªõi d·ªØ li·ªáu l·ªõn, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t t·ªëi ∆∞u h√≥a ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        