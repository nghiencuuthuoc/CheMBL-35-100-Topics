
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_79</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Bi·ªÉu ƒë·ªì radar c·ªßa c√°c ƒëi·ªÉm gi·ªëng thu·ªëc</h1>
<hr />
<p>Tuy·ªát v·ªùi! V·ªõi vai tr√≤ l√† chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 k·∫øt h·ª£p RDKit. D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, ch√∫ng ta s·∫Ω c√πng nhau x√¢y d·ª±ng quy tr√¨nh l√†m vi·ªác hi·ªáu qu·∫£ v√† gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ ph√°t sinh.</p>
<p><strong>T·ªïng quan d·ª± √°n v√† k·∫ø ho·∫°ch th·ª±c hi·ªán:</strong></p>
<p>D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. Quy tr√¨nh l√†m vi·ªác tu√¢n theo chu·∫©n AIMLOps Template, bao g·ªìm:</p>
<ol>
<li><strong>Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ ChEMBL 35 b·∫±ng SQL:</strong> S·ª≠ d·ª•ng pgAdmin ƒë·ªÉ ch·∫°y c√°c truy v·∫•n SQL v√† l∆∞u k·∫øt qu·∫£ v√†o c√°c file CSV trong th∆∞ m·ª•c <code>../data/</code>.</li>
<li><strong>Ph√¢n t√≠ch d·ªØ li·ªáu b·∫±ng Python v√† RDKit:</strong> S·ª≠ d·ª•ng Jupyter Notebook ƒë·ªÉ vi·∫øt code Python, k·∫øt h·ª£p v·ªõi th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω v√† ph√¢n t√≠ch d·ªØ li·ªáu h√≥a h·ªçc.</li>
<li><strong>L∆∞u tr·ªØ code v√† k·∫øt qu·∫£:</strong> L∆∞u c√°c file Jupyter Notebook trong th∆∞ m·ª•c <code>notebook/</code> v·ªõi t√™n file theo ƒë·ªãnh d·∫°ng <code>Topic_CheMBL_35_79_1_*</code> v√† <code>Topic_CheMBL_35_79_2_*</code>.</li>
</ol>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh (Analysis of the model):</strong></p>
<p>M·ª•c ti√™u ch√≠nh c·ªßa b·∫°n l√† kh√°m ph√° c√°c m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c h√≥a h·ªçc v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t trong ChEMBL 35. D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë m√¥ h√¨nh ph√¢n t√≠ch b·∫°n c√≥ th·ªÉ √°p d·ª•ng:</p>
<ul>
<li><strong>Ph√¢n t√≠ch ho·∫°t t√≠nh-c·∫•u tr√∫c (Structure-Activity Relationship - SAR):</strong> X√°c ƒë·ªãnh c√°c nh√≥m ch·ª©c ho·∫∑c c·∫•u tr√∫c con (substructure) quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh c·ªßa h·ª£p ch·∫•t.</li>
<li><strong>M√¥ h√¨nh h√≥a ƒë·ªãnh l∆∞·ª£ng ho·∫°t t√≠nh-c·∫•u tr√∫c (Quantitative Structure-Activity Relationship - QSAR):</strong> X√¢y d·ª±ng m√¥ h√¨nh to√°n h·ªçc d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa h·ª£p ch·∫•t d·ª±a tr√™n c√°c thu·ªôc t√≠nh h√≥a h·ªçc v√† v·∫≠t l√Ω c·ªßa n√≥.</li>
<li><strong>Ph√¢n c·ª•m (Clustering):</strong> Ph√¢n nh√≥m c√°c h·ª£p ch·∫•t c√≥ c·∫•u tr√∫c t∆∞∆°ng t·ª± nhau ƒë·ªÉ t√¨m ra c√°c "scaffold" (khung c·∫•u tr√∫c) ti·ªÅm nƒÉng.</li>
<li><strong>Ph√¢n t√≠ch th√†nh ph·∫ßn ch√≠nh (Principal Component Analysis - PCA):</strong> Gi·∫£m s·ªë chi·ªÅu c·ªßa d·ªØ li·ªáu b·∫±ng c√°ch t√¨m ra c√°c th√†nh ph·∫ßn ch√≠nh (principal components) th·ªÉ hi·ªán s·ª± bi·∫øn ƒë·ªông l·ªõn nh·∫•t trong d·ªØ li·ªáu.</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual instructions):</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt cho t·ª´ng b∆∞·ªõc trong quy tr√¨nh l√†m vi·ªác, k√®m theo code m·∫´u SQL v√† Python:</p>
<p><strong>B∆∞·ªõc 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ ChEMBL 35 b·∫±ng SQL (Step 1: Extract data from ChEMBL 35 using SQL)</strong></p>
<ul>
<li>
<p><strong>K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 (Connect to ChEMBL 35 database):</strong></p>
<p><code>sql
-- Connect to the database using pgAdmin with the provided credentials:
-- Host: 192.168.206.136
-- User: rd
-- Password: rd
-- Database: chembl_35</code></p>
</li>
<li>
<p><strong>Truy v·∫•n d·ªØ li·ªáu v√† l∆∞u v√†o file CSV (Query data and save to CSV file):</strong></p>
<p>V√≠ d·ª•, ƒë·ªÉ l·∫•y th√¥ng tin v·ªÅ c√°c h·ª£p ch·∫•t ·ª©c ch·∫ø enzyme EGFR (Epidermal Growth Factor Receptor):</p>
<p>```sql
-- Select data for compounds inhibiting EGFR
SELECT
    act.molregno,
    cmp.chembl_id,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    act.assay_id
FROM
    activities act
JOIN
    molecule_dictionary cmp ON act.molregno = cmp.molregno
JOIN
    assays ass ON act.assay_id = ass.assay_id
JOIN
    target_dictionary tgt ON ass.tid = tgt.tid
WHERE
    tgt.target_name = 'Epidermal Growth Factor Receptor'
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
LIMIT 100;</p>
<p>-- Save the result to a CSV file (e.g., egfr_inhibitors.csv)
-- You can do this directly in pgAdmin by right-clicking on the query result and selecting "Copy with Headers" then pasting into a text file and saving as CSV.
```</p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li>C√¢u truy v·∫•n n√†y k·∫øt h·ª£p c√°c b·∫£ng <code>activities</code>, <code>molecule_dictionary</code>, <code>assays</code>, v√† <code>target_dictionary</code> ƒë·ªÉ l·∫•y th√¥ng tin v·ªÅ ho·∫°t t√≠nh, c·∫•u tr√∫c, assay v√† m·ª•c ti√™u c·ªßa c√°c h·ª£p ch·∫•t.</li>
<li>ƒêi·ªÅu ki·ªán <code>tgt.target_name = 'Epidermal Growth Factor Receptor'</code> l·ªçc ra c√°c h·ª£p ch·∫•t ·ª©c ch·∫ø enzyme EGFR.</li>
<li><code>act.standard_type = 'IC50'</code> v√† <code>act.standard_units = 'nM'</code> ƒë·∫£m b·∫£o r·∫±ng ch√∫ng ta ch·ªâ l·∫•y c√°c gi√° tr·ªã IC50 ƒë∆∞·ª£c ƒëo b·∫±ng nM.</li>
<li><code>act.standard_value IS NOT NULL</code> lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã IC50 b·ªã thi·∫øu.</li>
<li><code>LIMIT 100</code> gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ l√† 100 d√≤ng.</li>
</ul>
</li>
</ul>
<p><strong>B∆∞·ªõc 2: Ph√¢n t√≠ch d·ªØ li·ªáu b·∫±ng Python v√† RDKit (Step 2: Analyze data using Python and RDKit)</strong></p>
<ul>
<li>
<p><strong>ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV (Read data from CSV file):</strong></p>
<p>```python
import pandas as pd
import os</p>
<p>base_path = "../data"  # ƒê∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c ch·ª©a file CSV
file_name = "egfr_inhibitors.csv"  # T√™n file CSV</p>
<p>file_path = os.path.join(base_path, file_name)</p>
<p>try:
    df = pd.read_csv(file_path)
    print(f"ƒê√£ ƒë·ªçc th√†nh c√¥ng file CSV t·ª´: {file_path}")
    print(df.head())  # In ra 5 d√≤ng ƒë·∫ßu ti√™n c·ªßa DataFrame
except FileNotFoundError:
    print(f"L·ªói: Kh√¥ng t√¨m th·∫•y file CSV t·∫°i ƒë∆∞·ªùng d·∫´n: {file_path}")
except Exception as e:
    print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
```</p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li>ƒêo·∫°n code n√†y s·ª≠ d·ª•ng th∆∞ vi·ªán <code>pandas</code> ƒë·ªÉ ƒë·ªçc file CSV v√†o m·ªôt DataFrame.</li>
<li>H√†m <code>os.path.join()</code> ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°o ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß ƒë·∫øn file CSV.</li>
<li>Kh·ªëi <code>try...except</code> ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh ƒë·ªçc file.</li>
</ul>
</li>
<li>
<p><strong>S·ª≠ d·ª•ng RDKit ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu h√≥a h·ªçc (Use RDKit to process chemical data):</strong></p>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<p>def calculate_molecular_weight(smiles):
    """Calculates the molecular weight of a compound given its SMILES string."""
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>Assuming your DataFrame 'df' has a column named 'smiles'</h1>
<h1>Example: df['smiles'] = ['CCO', 'c1ccccc1']</h1>
<h1>You'll need to replace this with the actual column name containing SMILES strings in your data</h1>
<h1>Create a sample DataFrame if 'df' does not have 'smiles' column</h1>
<p>if 'canonical_smiles' not in df.columns:
    df['canonical_smiles'] = ['CCO', 'c1ccccc1', 'C1=CC=CC=C1C=C1C=CC=CC=1']  # Example SMILES</p>
<h1>Apply the function to create a new column 'molecular_weight'</h1>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_molecular_weight)</p>
<p>print(df[['canonical_smiles', 'molecular_weight']].head())
```</p>
<p><strong>Gi·∫£i th√≠ch (Explanation):</strong></p>
<ul>
<li>ƒêo·∫°n code n√†y s·ª≠ d·ª•ng th∆∞ vi·ªán <code>RDKit</code> ƒë·ªÉ t√≠nh to√°n kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n chu·ªói SMILES c·ªßa ch√∫ng.</li>
<li>H√†m <code>Chem.MolFromSmiles()</code> chuy·ªÉn ƒë·ªïi chu·ªói SMILES th√†nh ƒë·ªëi t∆∞·ª£ng <code>Mol</code> c·ªßa RDKit.</li>
<li>H√†m <code>Descriptors.MolWt()</code> t√≠nh to√°n kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ c·ªßa ƒë·ªëi t∆∞·ª£ng <code>Mol</code>.</li>
<li>H√†m <code>apply()</code> ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ √°p d·ª•ng h√†m <code>calculate_molecular_weight()</code> cho t·ª´ng h√†ng trong c·ªôt 'smiles' c·ªßa DataFrame.</li>
</ul>
</li>
</ul>
<p><strong>3. Gi·∫£i quy·∫øt l·ªói (Error handling):</strong></p>
<ul>
<li>
<p><strong>L·ªói (Error) a:</strong> <code>ERROR: operator does not exist: numeric ~ unknown, LINE 12: AND act.standard_value ~ '^[0-9\.]+$'</code></p>
<p>L·ªói n√†y x·∫£y ra do b·∫°n ƒëang c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ <code>~</code> (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë (<code>numeric</code>). ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c·∫ßn chuy·ªÉn ƒë·ªïi c·ªôt <code>act.standard_value</code> sang ki·ªÉu text tr∆∞·ªõc khi so s√°nh v·ªõi regular expression:</p>
<p><code>sql
SELECT
    act.molregno,
    cmp.chembl_id,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    act.assay_id
FROM
    activities act
JOIN
    molecule_dictionary cmp ON act.molregno = cmp.molregno
JOIN
    assays ass ON act.assay_id = ass.assay_id
JOIN
    target_dictionary tgt ON ass.tid = tgt.tid
WHERE
    tgt.target_name = 'Epidermal Growth Factor Receptor'
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND CAST(act.standard_value AS TEXT) ~ '^[0-9\.]+$' -- Convert to TEXT for regex
LIMIT 100;</code></p>
<p><strong>Explanation:</strong>
* We used <code>CAST(act.standard_value AS TEXT)</code> to explicitly convert the numeric column to text before applying the regex.</p>
</li>
<li>
<p><strong>L·ªói (Error) b:</strong> Phi√™n b·∫£n scikit-learn c≈© kh√¥ng h·ªó tr·ª£ tham s·ªë <code>squared=False</code> trong h√†m <code>mean_squared_error</code></p>
<p>N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, h√£y lo·∫°i b·ªè tham s·ªë <code>squared=False</code> ho·∫∑c n√¢ng c·∫•p l√™n phi√™n b·∫£n m·ªõi h∆°n:</p>
<p>```python
from sklearn.metrics import mean_squared_error</p>
<h1>N·∫øu b·∫°n kh√¥ng th·ªÉ n√¢ng c·∫•p scikit-learn</h1>
<p>mse = mean_squared_error(y_true, y_pred)
rmse = mse**0.5  # T√≠nh cƒÉn b·∫≠c hai ƒë·ªÉ c√≥ RMSE</p>
<h1>Ho·∫∑c n·∫øu b·∫°n c√≥ th·ªÉ n√¢ng c·∫•p scikit-learn</h1>
<h1>rmse = mean_squared_error(y_true, y_pred, squared=False)</h1>
<p>print(f"Root Mean Squared Error (RMSE): {rmse}")
```</p>
</li>
</ul>
<p><strong>4. V√≠ d·ª• code SQL v√† Python m·∫´u (Sample SQL and Python code examples):</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>V√≠ d·ª• 1: L·ªçc c√°c h·ª£p ch·∫•t c√≥ kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠ n·∫±m trong kho·∫£ng nh·∫•t ƒë·ªãnh (Filter compounds by molecular weight range)</strong></p>
<ul>
<li>
<p><strong>SQL:</strong></p>
<p><code>sql
-- Select compounds with molecular weight between 200 and 500
SELECT
    cmp.chembl_id,
    cmp.molecule_structures
FROM
    molecule_dictionary cmp
WHERE
    cmp.molecule_properties-&gt;&gt;'mw_freebase' BETWEEN '200' AND '500'
LIMIT 100;</code></p>
</li>
<li>
<p><strong>Python:</strong></p>
<p>```python
import pandas as pd
import os
from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<p>base_path = "../data"
file_name = "egfr_inhibitors.csv"
file_path = os.path.join(base_path, file_name)</p>
<h1>Sample DataFrame, replace with your actual data loading</h1>
<p>data = {'canonical_smiles': ['CCO', 'c1ccccc1', 'C1=CC=CC=C1C=C1C=CC=CC=1', 'CC(=O)Oc1ccccc1C(=O)O', 'C<a href="O">C@H</a>c1ccccc1']}
df = pd.DataFrame(data)</p>
<p>def calculate_molecular_weight(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_molecular_weight)</p>
<h1>Filter compounds with molecular weight between 100 and 200</h1>
<p>filtered_df = df[(df['molecular_weight'] &gt;= 50) &amp; (df['molecular_weight'] &lt;= 200)]</p>
<p>print(filtered_df)
```</p>
</li>
</ul>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n logP (Partition Coefficient) c·ªßa c√°c h·ª£p ch·∫•t (Calculate LogP of compounds)</strong></p>
<ul>
<li><strong>SQL:</strong> (Kh√¥ng th·ªÉ t√≠nh logP tr·ª±c ti·∫øp b·∫±ng SQL, c·∫ßn s·ª≠ d·ª•ng Python)</li>
<li>
<p><strong>Python:</strong></p>
<p>```python
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Descriptors
import pandas as pd</p>
<h1>Sample DataFrame, replace with your actual data loading</h1>
<p>data = {'canonical_smiles': ['CCO', 'c1ccccc1', 'C1=CC=CC=C1C=C1C=CC=CC=1', 'CC(=O)Oc1ccccc1C(=O)O', 'C<a href="O">C@H</a>c1ccccc1']}
df = pd.DataFrame(data)</p>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolLogP(mol)
    else:
        return None</p>
<p>df['logp'] = df['canonical_smiles'].apply(calculate_logp)
print(df[['canonical_smiles', 'logp']])
```</p>
</li>
</ul>
<p><strong>V√≠ d·ª• 3: T√¨m c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± v·ªõi m·ªôt h·ª£p ch·∫•t cho tr∆∞·ªõc (Find compounds similar to a given compound)</strong></p>
<ul>
<li><strong>SQL:</strong> (Kh√≥ th·ª±c hi·ªán tr·ª±c ti·∫øp b·∫±ng SQL, c·∫ßn s·ª≠ d·ª•ng Python v√† RDKit)</li>
<li>
<p><strong>Python:</strong></p>
<p>```python
from rdkit import Chem
from rdkit.Chem import AllChem
import pandas as pd
import numpy as np</p>
<h1>Sample DataFrame, replace with your actual data loading</h1>
<p>data = {'canonical_smiles': ['CCO', 'c1ccccc1', 'C1=CC=CC=C1C=C1C=CC=CC=1', 'CC(=O)Oc1ccccc1C(=O)O', 'C<a href="O">C@H</a>c1ccccc1']}
df = pd.DataFrame(data)</p>
<p>def calculate_fingerprint(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=2048)
        return fp
    else:
        return None</p>
<p>df['fingerprint'] = df['canonical_smiles'].apply(calculate_fingerprint)</p>
<h1>Define the reference compound (query)</h1>
<p>reference_smiles = 'c1ccccc1'
reference_fp = calculate_fingerprint(reference_smiles)</p>
<h1>Calculate Tanimoto similarity</h1>
<p>def calculate_tanimoto_similarity(fp):
    if fp is None or reference_fp is None:
        return np.nan
    return Chem.DataStructs.TanimotoSimilarity(fp, reference_fp)</p>
<p>df['tanimoto_similarity'] = df['fingerprint'].apply(calculate_tanimoto_similarity)</p>
<h1>Filter compounds with Tanimoto similarity greater than 0.5</h1>
<p>similar_compounds = df[df['tanimoto_similarity'] &gt; 0.5]</p>
<p>print(similar_compounds[['canonical_smiles', 'tanimoto_similarity']])
```</p>
</li>
</ul>
<p><strong>V√≠ d·ª• 4: Th·ªëng k√™ s·ªë l∆∞·ª£ng h·ª£p ch·∫•t cho m·ªói lo·∫°i ho·∫°t t√≠nh (Count compounds for each activity type)</strong></p>
<ul>
<li>
<p><strong>SQL:</strong></p>
<p><code>sql
-- Count the number of compounds for each standard_type
SELECT
    act.standard_type,
    COUNT(DISTINCT act.molregno) AS compound_count
FROM
    activities act
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')
GROUP BY
    act.standard_type
ORDER BY
    compound_count DESC
LIMIT 100;</code></p>
</li>
<li>
<p><strong>Python:</strong></p>
<p>```python
import pandas as pd</p>
<h1>Sample DataFrame, replace with your actual data loading</h1>
<p>data = {'standard_type': ['IC50', 'Ki', 'IC50', 'EC50', 'Ki', 'IC50']}
df = pd.DataFrame(data)</p>
<h1>Count compounds for each standard type</h1>
<p>activity_counts = df['standard_type'].value_counts().reset_index()
activity_counts.columns = ['standard_type', 'compound_count']</p>
<p>print(activity_counts)
```</p>
</li>
</ul>
<p><strong>V√≠ d·ª• 5: T√¨m c√°c m·ª•c ti√™u (targets) li√™n quan ƒë·∫øn m·ªôt h·ª£p ch·∫•t cho tr∆∞·ªõc (Find targets associated with a given compound)</strong></p>
<ul>
<li>
<p><strong>SQL:</strong></p>
<p><code>sql
-- Find targets associated with a given compound (replace 'CHEMBL123' with an actual chembl_id)
SELECT
    tgt.target_name
FROM
    activities act
JOIN
    molecule_dictionary cmp ON act.molregno = cmp.molregno
JOIN
    assays ass ON act.assay_id = ass.assay_id
JOIN
    target_dictionary tgt ON ass.tid = tgt.tid
WHERE
    cmp.chembl_id = 'CHEMBL123'
LIMIT 100;</code></p>
</li>
<li>
<p><strong>Python:</strong> (T∆∞∆°ng t·ª± nh∆∞ SQL, ch·ªß y·∫øu l√† truy v·∫•n d·ªØ li·ªáu)</p>
</li>
</ul>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li>Thay th·∫ø c√°c ƒë∆∞·ªùng d·∫´n file v√† t√™n c·ªôt trong code m·∫´u b·∫±ng c√°c gi√° tr·ªã th·ª±c t·∫ø trong d·ª± √°n c·ªßa b·∫°n.</li>
<li>ƒêi·ªÅu ch·ªânh c√°c tham s·ªë v√† ƒëi·ªÅu ki·ªán l·ªçc trong c√°c truy v·∫•n SQL v√† code Python ƒë·ªÉ ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u c·ªßa b·∫°n.</li>
<li>S·ª≠ d·ª•ng c√°c th∆∞ vi·ªán v√† c√¥ng c·ª• ph√π h·ª£p ƒë·ªÉ tr·ª±c quan h√≥a d·ªØ li·ªáu v√† kh√°m ph√° c√°c m·∫´u (patterns) ti·ªÅm ·∫©n.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        