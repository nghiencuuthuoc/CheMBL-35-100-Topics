
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_34</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Bi·ªÉu ƒë·ªì nhi·ªát v·ªÅ s·ªë l∆∞·ª£ng ligand t∆∞∆°ng t√°c target</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† chuy√™n gia R&amp;D d∆∞·ª£c h·ªçc, t√¥i hi·ªÉu r√µ t·∫ßm quan tr·ªçng c·ªßa vi·ªác khai th√°c d·ªØ li·ªáu ChEMBL ƒë·ªÉ t√¨m ki·∫øm c√°c h·ª£p ch·∫•t ti·ªÅm nƒÉng. Ch√∫ng ta s·∫Ω c√πng nhau x√¢y d·ª±ng quy tr√¨nh ph√¢n t√≠ch hi·ªáu qu·∫£, ƒë·∫£m b·∫£o t√≠nh ch√≠nh x√°c v√† kh·∫£ nƒÉng ·ª©ng d·ª•ng cao.</p>
<p>D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt v√† h∆∞·ªõng d·∫´n song ng·ªØ, c√πng v·ªõi code SQL v√† Python m·∫´u, ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ b·∫°n ƒë√£ n√™u v√† tu√¢n th·ªß theo quy tr√¨nh l√†m vi·ªác c·ªßa b·∫°n:</p>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch (Analysis of the Analysis Model)</strong></p>
<p>M·ª•c ti√™u c·ªßa ch√∫ng ta l√† khai th√°c d·ªØ li·ªáu t·ª´ ChEMBL 35 ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. D∆∞·ªõi ƒë√¢y l√† m√¥ h√¨nh ph√¢n t√≠ch ƒë·ªÅ xu·∫•t:</p>
<ul>
<li><strong>Data Extraction (Tr√≠ch xu·∫•t d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n v√† tr√≠ch xu·∫•t d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 (s·ª≠ d·ª•ng PostgreSQL). D·ªØ li·ªáu n√†y c√≥ th·ªÉ bao g·ªìm th√¥ng tin v·ªÅ c·∫•u tr√∫c h√≥a h·ªçc, ho·∫°t t√≠nh sinh h·ªçc, thu·ªôc t√≠nh d∆∞·ª£c ƒë·ªông h·ªçc, v.v.</li>
<li><strong>Data Preprocessing (Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng RDKit v√† Python ƒë·ªÉ l√†m s·∫°ch, chuy·ªÉn ƒë·ªïi v√† chu·∫©n h√≥a d·ªØ li·ªáu. C√°c b∆∞·ªõc c√≥ th·ªÉ bao g·ªìm:<ul>
<li>Chuy·ªÉn ƒë·ªïi SMILES sang c√°c ƒë·ªãnh d·∫°ng c·∫•u tr√∫c kh√°c (v√≠ d·ª•: Mol).</li>
<li>T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ (v√≠ d·ª•: MW, LogP, TPSA).</li>
<li>X·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu ho·∫∑c kh√¥ng h·ª£p l·ªá.</li>
</ul>
</li>
<li><strong>Exploratory Data Analysis (EDA) (Ph√¢n t√≠ch thƒÉm d√≤ d·ªØ li·ªáu):</strong> S·ª≠ d·ª•ng Python (v·ªõi c√°c th∆∞ vi·ªán nh∆∞ Pandas, Matplotlib, Seaborn) ƒë·ªÉ kh√°m ph√° d·ªØ li·ªáu, t√¨m ki·∫øm c√°c m·∫´u v√† m·ªëi quan h·ªá ti·ªÅm nƒÉng.</li>
<li><strong>Model Building (X√¢y d·ª±ng m√¥ h√¨nh):</strong> X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n (v√≠ d·ª•: m√¥ h√¨nh QSAR/QSPR) ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc ho·∫∑c c√°c thu·ªôc t√≠nh kh√°c c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c c·ªßa ch√∫ng.</li>
<li><strong>Model Validation (X√°c th·ª±c m√¥ h√¨nh):</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c t·∫≠p d·ªØ li·ªáu ki·ªÉm tra v√† c√°c ch·ªâ s·ªë ph√π h·ª£p.</li>
<li><strong>Interpretation and Application (Gi·∫£i th√≠ch v√† ·ª©ng d·ª•ng):</strong> Gi·∫£i th√≠ch k·∫øt qu·∫£ c·ªßa m√¥ h√¨nh v√† s·ª≠ d·ª•ng ch√∫ng ƒë·ªÉ ƒë∆∞a ra c√°c quy·∫øt ƒë·ªãnh s√°ng su·ªët trong qu√° tr√¨nh ph√°t tri·ªÉn thu·ªëc.</li>
</ul>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Guidance)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt cho t·ª´ng b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch, k√®m theo v√≠ d·ª• code SQL v√† Python.</p>
<p><strong>B∆∞·ªõc 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ ChEMBL 35 (Data Extraction from ChEMBL 35)</strong></p>
<ul>
<li><strong>SQL (English):</strong></li>
</ul>
<p><code>sql
-- Select compound properties and activities for a specific target
SELECT
    cmp.chembl_id,
    cmp.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    compound_structures cmp
JOIN
    activities act ON cmp.molregno = act.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.target_name = 'CHEMBL35 Target Name' -- Replace with the actual target name
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND act.standard_value ~ '^[0-9\.]+$' -- Only numeric values
LIMIT 100;</code></p>
<ul>
<li><strong>SQL (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p><code>sql
-- L·ª±a ch·ªçn thu·ªôc t√≠nh h·ª£p ch·∫•t v√† ho·∫°t t√≠nh cho m·ªôt m·ª•c ti√™u c·ª• th·ªÉ
SELECT
    cmp.chembl_id,
    cmp.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    compound_structures cmp
JOIN
    activities act ON cmp.molregno = act.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.target_name = 'T√™n m·ª•c ti√™u CHEMBL35' -- Thay th·∫ø b·∫±ng t√™n m·ª•c ti√™u th·ª±c t·∫ø
    AND act.standard_type = 'IC50'
    AND act.standard_units = 'nM'
    AND act.standard_value IS NOT NULL
    AND act.standard_value ~ '^[0-9\.]+$' -- Ch·ªâ c√°c gi√° tr·ªã s·ªë
LIMIT 100;</code></p>
<p><strong>L∆∞u √Ω:</strong></p>
<ul>
<li>S·ª≠a l·ªói <code>ERROR: operator does not exist: numeric ~ unknown</code>:  ƒê·∫£m b·∫£o c·ªôt <code>act.standard_value</code> l√† ki·ªÉu s·ªë (numeric). N·∫øu kh√¥ng, b·∫°n c·∫ßn chuy·ªÉn ƒë·ªïi n√≥ tr∆∞·ªõc khi so s√°nh.  Tuy nhi√™n, vi·ªác s·ª≠ d·ª•ng <code>~ '^[0-9\.]+$'</code> ƒë·ªÉ l·ªçc gi√° tr·ªã s·ªë l√† kh√¥ng c·∫ßn thi·∫øt n·∫øu c·ªôt ƒë√£ l√† ki·ªÉu s·ªë. B·∫°n ch·ªâ c·∫ßn ƒë·∫£m b·∫£o n√≥ kh√¥ng null.</li>
<li>Thay th·∫ø <code>'CHEMBL35 Target Name'</code> b·∫±ng t√™n m·ª•c ti√™u c·ª• th·ªÉ m√† b·∫°n quan t√¢m.</li>
<li><code>LIMIT 100</code> ƒë·ªÉ ch·ªâ l·∫•y 100 d√≤ng d·ªØ li·ªáu ƒë·∫ßu ti√™n.</li>
</ul>
<p><strong>B∆∞·ªõc 2: Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu b·∫±ng RDKit v√† Python (Data Preprocessing with RDKit and Python)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import os</p>
<h1>Define the base path</h1>
<p>base_path = "../data"  # Adjust as needed</p>
<h1>Load data from CSV</h1>
<p>csv_file_path = os.path.join(base_path, "your_data.csv") # Replace 'your_data.csv'
df = pd.read_csv(csv_file_path)</p>
<h1>Function to calculate molecular weight</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>Apply the function to the 'canonical_smiles' column</h1>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>Handle missing values (example: fill with the mean)</h1>
<p>df['molecular_weight'] = df['molecular_weight'].fillna(df['molecular_weight'].mean())</p>
<p>print(df.head())
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import os</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc</h1>
<p>base_path = "../data"  # ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ file CSV</h1>
<p>csv_file_path = os.path.join(base_path, "your_data.csv") # Thay th·∫ø 'your_data.csv'
df = pd.read_csv(csv_file_path)</p>
<h1>H√†m t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠</h1>
<p>def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None</p>
<h1>√Åp d·ª•ng h√†m cho c·ªôt 'canonical_smiles'</h1>
<p>df['molecular_weight'] = df['canonical_smiles'].apply(calculate_mw)</p>
<h1>X·ª≠ l√Ω gi√° tr·ªã thi·∫øu (v√≠ d·ª•: ƒëi·ªÅn b·∫±ng gi√° tr·ªã trung b√¨nh)</h1>
<p>df['molecular_weight'] = df['molecular_weight'].fillna(df['molecular_weight'].mean())</p>
<p>print(df.head())
```</p>
<p><strong>L∆∞u √Ω:</strong></p>
<ul>
<li>Thay th·∫ø <code>"your_data.csv"</code> b·∫±ng t√™n file CSV th·ª±c t·∫ø c·ªßa b·∫°n.</li>
<li>ƒêi·ªÅu ch·ªânh <code>base_path</code> n·∫øu c·∫ßn thi·∫øt.</li>
<li>ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√†i ƒë·∫∑t RDKit: <code>conda install -c conda-forge rdkit</code></li>
</ul>
<p><strong>B∆∞·ªõc 3: Ph√¢n t√≠ch thƒÉm d√≤ d·ªØ li·ªáu (Exploratory Data Analysis - EDA)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os</p>
<h1>Define the base path</h1>
<p>base_path = "../data"  # Adjust as needed</p>
<h1>Load data from CSV</h1>
<p>csv_file_path = os.path.join(base_path, "your_data.csv") # Replace 'your_data.csv'
df = pd.read_csv(csv_file_path)</p>
<h1>Basic statistics</h1>
<p>print(df.describe())</p>
<h1>Distribution of 'standard_value'</h1>
<p>sns.histplot(df['standard_value'])
plt.title('Distribution of Standard Value')
plt.show()</p>
<h1>Scatter plot of 'molecular_weight' vs. 'standard_value'</h1>
<p>sns.scatterplot(x='molecular_weight', y='standard_value', data=df)
plt.title('Molecular Weight vs. Standard Value')
plt.show()
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os</p>
<h1>ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc</h1>
<p>base_path = "../data"  # ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ file CSV</h1>
<p>csv_file_path = os.path.join(base_path, "your_data.csv") # Thay th·∫ø 'your_data.csv'
df = pd.read_csv(csv_file_path)</p>
<h1>Th·ªëng k√™ c∆° b·∫£n</h1>
<p>print(df.describe())</p>
<h1>Ph√¢n ph·ªëi c·ªßa 'standard_value'</h1>
<p>sns.histplot(df['standard_value'])
plt.title('Ph√¢n ph·ªëi c·ªßa Standard Value')
plt.show()</p>
<h1>Bi·ªÉu ƒë·ªì ph√¢n t√°n c·ªßa 'molecular_weight' so v·ªõi 'standard_value'</h1>
<p>sns.scatterplot(x='molecular_weight', y='standard_value', data=df)
plt.title('Tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ so v·ªõi Standard Value')
plt.show()
```</p>
<p><strong>B∆∞·ªõc 4: X√¢y d·ª±ng v√† x√°c th·ª±c m√¥ h√¨nh (Model Building and Validation - v√≠ d·ª• ƒë∆°n gi·∫£n)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error</p>
<h1>Load data from CSV</h1>
<p>df = pd.read_csv("your_data.csv") # Replace 'your_data.csv'</p>
<h1>Assuming 'molecular_weight' is your feature and 'standard_value' is your target</h1>
<p>X = df[['molecular_weight']].dropna()
y = df['standard_value'].dropna()</p>
<h1>Split data into training and testing sets</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Create a linear regression model</h1>
<p>model = LinearRegression()</p>
<h1>Train the model</h1>
<p>model.fit(X_train, y_train)</p>
<h1>Make predictions</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>Evaluate the model</h1>
<p>mse = mean_squared_error(y_test, y_pred, squared=False) # squared=False for RMSE
print(f"Root Mean Squared Error: {mse}")
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error</p>
<h1>T·∫£i d·ªØ li·ªáu t·ª´ file CSV</h1>
<p>df = pd.read_csv("your_data.csv") # Thay th·∫ø 'your_data.csv'</p>
<h1>Gi·∫£ s·ª≠ 'molecular_weight' l√† ƒë·∫∑c tr∆∞ng v√† 'standard_value' l√† m·ª•c ti√™u</h1>
<p>X = df[['molecular_weight']].dropna()
y = df['standard_value'].dropna()</p>
<h1>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>T·∫°o m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh</h1>
<p>model = LinearRegression()</p>
<h1>Hu·∫•n luy·ªán m√¥ h√¨nh</h1>
<p>model.fit(X_train, y_train)</p>
<h1>D·ª± ƒëo√°n</h1>
<p>y_pred = model.predict(X_test)</p>
<h1>ƒê√°nh gi√° m√¥ h√¨nh</h1>
<p>mse = mean_squared_error(y_test, y_pred, squared=False) # squared=False cho RMSE
print(f"Sai s·ªë b√¨nh ph∆∞∆°ng g·ªëc trung b√¨nh: {mse}")
```</p>
<p><strong>L∆∞u √Ω:</strong></p>
<ul>
<li>S·ª≠a l·ªói <code>squared=False</code>: N·∫øu phi√™n b·∫£n scikit-learn c·ªßa b·∫°n qu√° c≈©, h√£y n√¢ng c·∫•p n√≥: <code>pip install -U scikit-learn</code>.  N·∫øu kh√¥ng th·ªÉ n√¢ng c·∫•p, h√£y t√≠nh cƒÉn b·∫≠c hai c·ªßa MSE: <code>mse = mean_squared_error(y_test, y_pred); rmse = mse**0.5</code>.</li>
<li>ƒê√¢y ch·ªâ l√† m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n.  B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c m√¥ h√¨nh ph·ª©c t·∫°p h∆°n v√† nhi·ªÅu ƒë·∫∑c tr∆∞ng h∆°n.</li>
<li>C·∫ßn th·ª±c hi·ªán cross-validation ƒë·ªÉ ƒë√°nh gi√° m√¥ h√¨nh m·ªôt c√°ch ch√≠nh x√°c.</li>
</ul>
<p><strong>3. 5 V√≠ d·ª• Code SQL v√† Python M·∫´u (5 Sample SQL and Python Code Examples)</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• b·ªï sung ƒë·ªÉ minh h·ªça c√°c thao t√°c kh√°c nhau:</p>
<p><strong>V√≠ d·ª• 1: T√≠nh LogP s·ª≠ d·ª•ng RDKit (Calculate LogP using RDKit)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Crippen
import pandas as pd</p>
<p>def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Crippen.MolLogP(mol)
    else:
        return None</p>
<h1>Example usage with a DataFrame</h1>
<p>df = pd.DataFrame({'smiles': ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1']}) #aspirin, benzene
df['logp'] = df['smiles'].apply(calculate_logp)
print(df)
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Crippen
import pandas as pd</p>
<p>def tinh_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Crippen.MolLogP(mol)
    else:
        return None</p>
<h1>V√≠ d·ª• s·ª≠ d·ª•ng v·ªõi DataFrame</h1>
<p>df = pd.DataFrame({'smiles': ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1']}) #aspirin, benzene
df['logp'] = df['smiles'].apply(tinh_logp)
print(df)
```</p>
<p><strong>V√≠ d·ª• 2: L·ªçc c√°c h·ª£p ch·∫•t c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trong m·ªôt kho·∫£ng nh·∫•t ƒë·ªãnh (Filter compounds by molecular weight range)</strong></p>
<ul>
<li><strong>SQL (English):</strong></li>
</ul>
<p><code>sql
SELECT chembl_id, canonical_smiles
FROM compound_structures
WHERE molregno IN (
    SELECT molregno
    FROM molecule_dictionary
    WHERE rlogp BETWEEN 2 AND 5 -- LogP between 2 and 5
)
LIMIT 100;</code></p>
<ul>
<li><strong>SQL (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p><code>sql
SELECT chembl_id, canonical_smiles
FROM compound_structures
WHERE molregno IN (
    SELECT molregno
    FROM molecule_dictionary
    WHERE rlogp BETWEEN 2 AND 5 -- LogP n·∫±m gi·ªØa 2 v√† 5
)
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 3:  T√≠nh TPSA (Topological Polar Surface Area) (Calculate TPSA)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors
import pandas as pd</p>
<p>def calculate_tpsa(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.TPSA(mol)
    else:
        return None</p>
<h1>Example usage</h1>
<p>df = pd.DataFrame({'smiles': ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1']})
df['tpsa'] = df['smiles'].apply(calculate_tpsa)
print(df)
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
from rdkit import Chem
from rdkit.Chem import Descriptors
import pandas as pd</p>
<p>def tinh_tpsa(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.TPSA(mol)
    else:
        return None</p>
<h1>V√≠ d·ª• s·ª≠ d·ª•ng</h1>
<p>df = pd.DataFrame({'smiles': ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1']})
df['tpsa'] = df['smiles'].apply(tinh_tpsa)
print(df)
```</p>
<p><strong>V√≠ d·ª• 4: L·∫•y c√°c h·ª£p ch·∫•t ho·∫°t ƒë·ªông tr√™n m·ªôt m·ª•c ti√™u c·ª• th·ªÉ (Get active compounds for a specific target)</strong></p>
<ul>
<li><strong>SQL (English):</strong></li>
</ul>
<p><code>sql
SELECT cmp.chembl_id, cmp.canonical_smiles, act.standard_value
FROM compound_structures cmp
JOIN activities act ON cmp.molregno = act.molregno
JOIN target_dictionary td ON act.tid = td.tid
WHERE td.chembl_id = 'CHEMBL205' -- Replace with the target ChEMBL ID
AND act.standard_type = 'IC50'
AND act.standard_value &lt; 100  -- IC50 &lt; 100 nM
LIMIT 100;</code></p>
<ul>
<li><strong>SQL (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p><code>sql
SELECT cmp.chembl_id, cmp.canonical_smiles, act.standard_value
FROM compound_structures cmp
JOIN activities act ON cmp.molregno = act.molregno
JOIN target_dictionary td ON act.tid = td.tid
WHERE td.chembl_id = 'CHEMBL205' -- Thay th·∫ø b·∫±ng ChEMBL ID c·ªßa m·ª•c ti√™u
AND act.standard_type = 'IC50'
AND act.standard_value &lt; 100  -- IC50 &lt; 100 nM
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 5: Chuy·ªÉn ƒë·ªïi IC50 sang pIC50 (Convert IC50 to pIC50)</strong></p>
<ul>
<li><strong>Python (English):</strong></li>
</ul>
<p>```python
import numpy as np
import pandas as pd</p>
<p>def ic50_to_pic50(ic50_nM):
    """Converts IC50 (nM) to pIC50."""
    pIC50 = -np.log10(ic50_nM * 1e-9)  # Convert nM to Molar
    return pIC50</p>
<h1>Example Usage (assuming you have a DataFrame 'df' with an 'standard_value' column representing IC50 in nM)</h1>
<p>df = pd.DataFrame({'standard_value': [10, 100, 1000]})
df['pIC50'] = df['standard_value'].apply(ic50_to_pic50)
print(df)
```</p>
<ul>
<li><strong>Python (Ti·∫øng Vi·ªát):</strong></li>
</ul>
<p>```python
import numpy as np
import pandas as pd</p>
<p>def ic50_sang_pic50(ic50_nM):
    """Chuy·ªÉn ƒë·ªïi IC50 (nM) th√†nh pIC50."""
    pIC50 = -np.log10(ic50_nM * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM th√†nh Molar
    return pIC50</p>
<h1>V√≠ d·ª• s·ª≠ d·ª•ng (gi·∫£ s·ª≠ b·∫°n c√≥ DataFrame 'df' v·ªõi c·ªôt 'standard_value' ƒë·∫°i di·ªán cho IC50 t√≠nh b·∫±ng nM)</h1>
<p>df = pd.DataFrame({'standard_value': [10, 100, 1000]})
df['pIC50'] = df['standard_value'].apply(ic50_sang_pic50)
print(df)
```</p>
<p><strong>K·∫øt lu·∫≠n</strong></p>
<p>Hy v·ªçng r·∫±ng ph√¢n t√≠ch v√† h∆∞·ªõng d·∫´n chi ti·∫øt n√†y s·∫Ω gi√∫p b·∫°n ti·∫øn xa h∆°n trong d·ª± √°n c·ªßa m√¨nh. ƒê·ª´ng ng·∫ßn ng·∫°i h·ªèi n·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o ho·∫∑c c·∫ßn h·ªó tr·ª£ th√™m. Ch√∫c b·∫°n th√†nh c√¥ng!</p>
        </body>
        </html>
        