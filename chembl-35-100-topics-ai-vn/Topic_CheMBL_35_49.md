# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: Ph√¢n t√≠ch thu·ªëc ChEMBL ƒë√£ ƒë∆∞·ª£c FDA ph√™ duy·ªát
---
Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&D d∆∞·ª£c h·ªçc, t√¥i hi·ªÉu r√µ t·∫ßm quan tr·ªçng c·ªßa vi·ªác khai th√°c d·ªØ li·ªáu ChEMBL ƒë·ªÉ t√¨m ki·∫øm c√°c h·ª£p ch·∫•t ti·ªÅm nƒÉng. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n song ng·ªØ v√† c√°c v√≠ d·ª• code ƒë·ªÉ b·∫°n tham kh·∫£o:

**1. Ph√¢n t√≠ch v√† M√¥ h√¨nh Ph√¢n t√≠ch (Analysis and Analytical Model)**

**1.1. M·ª•c ti√™u (Objective)**

*   X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c h√≥a h·ªçc c·ªßa ch√∫ng.
*   Ph√¢n t√≠ch m·ªëi quan h·ªá gi·ªØa c√°c ƒë·∫∑c t√≠nh c·∫•u tr√∫c (descriptors) v√† ho·∫°t t√≠nh sinh h·ªçc.
*   T√¨m ki·∫øm c√°c h·ª£p ch·∫•t ti·ªÅm nƒÉng c√≥ ho·∫°t t√≠nh mong mu·ªën.

**1.2. D·ªØ li·ªáu (Data)**

*   **Ngu·ªìn:** ChEMBL 35 (c∆° s·ªü d·ªØ li·ªáu l·ªõn ch·ª©a th√¥ng tin v·ªÅ c√°c ph√¢n t·ª≠ sinh h·ªçc v√† ho·∫°t t√≠nh c·ªßa ch√∫ng).
*   **B·∫£ng ch√≠nh:**
    *   `activities`: Ch·ª©a th√¥ng tin v·ªÅ ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t (v√≠ d·ª•: IC50, Ki, EC50).
    *   `molecule_dictionary`: Ch·ª©a th√¥ng tin v·ªÅ c·∫•u tr√∫c h√≥a h·ªçc c·ªßa c√°c h·ª£p ch·∫•t (v√≠ d·ª•: SMILES).
    *   `compound_structures`: Ch·ª©a c·∫•u tr√∫c h√≥a h·ªçc c·ªßa c√°c h·ª£p ch·∫•t ·ªü nhi·ªÅu ƒë·ªãnh d·∫°ng.
*   **ƒê·∫∑c tr∆∞ng h√≥a h·ªçc (Chemical descriptors):** S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc t·ª´ c·∫•u tr√∫c SMILES. C√°c ƒë·∫∑c tr∆∞ng n√†y c√≥ th·ªÉ bao g·ªìm:
    *   Molecular Weight (Kh·ªëi l∆∞·ª£ng ph√¢n t·ª≠)
    *   LogP (H·ªá s·ªë ph√¢n v√πng octanol-water)
    *   Hydrogen Bond Donors (S·ªë l∆∞·ª£ng li√™n k·∫øt hydro cho)
    *   Hydrogen Bond Acceptors (S·ªë l∆∞·ª£ng li√™n k·∫øt hydro nh·∫≠n)
    *   Topological Polar Surface Area (Di·ªán t√≠ch b·ªÅ m·∫∑t c·ª±c topo)
    *   S·ªë v√≤ng (Number of rings)
    *   ... v√† nhi·ªÅu ƒë·∫∑c tr∆∞ng kh√°c.

**1.3. M√¥ h√¨nh (Model)**

Ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng nhi·ªÅu m√¥ h√¨nh kh√°c nhau ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc, t√πy thu·ªôc v√†o m·ª•c ti√™u c·ª• th·ªÉ v√† t√≠nh ch·∫•t c·ªßa d·ªØ li·ªáu. D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë l·ª±a ch·ªçn ph·ªï bi·∫øn:

*   **H·ªìi quy tuy·∫øn t√≠nh (Linear Regression):** ƒê∆°n gi·∫£n, d·ªÖ hi·ªÉu, ph√π h·ª£p khi c√≥ m·ªëi quan h·ªá tuy·∫øn t√≠nh gi·ªØa c√°c ƒë·∫∑c tr∆∞ng v√† ho·∫°t t√≠nh.
*   **H·ªìi quy Ridge/Lasso (Ridge/Lasso Regression):** C·∫£i thi·ªán h·ªìi quy tuy·∫øn t√≠nh b·∫±ng c√°ch th√™m c√°c ƒëi·ªÅu ki·ªán r√†ng bu·ªôc ƒë·ªÉ tr√°nh overfitting.
*   **M√°y vector h·ªó tr·ª£ (Support Vector Machines - SVM):** Hi·ªáu qu·∫£ trong kh√¥ng gian ƒë·∫∑c tr∆∞ng cao, c√≥ th·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu phi tuy·∫øn t√≠nh.
*   **R·ª´ng ng·∫´u nhi√™n (Random Forest):** M·∫°nh m·∫Ω, c√≥ kh·∫£ nƒÉng ch·ªëng overfitting, cung c·∫•p th√¥ng tin v·ªÅ t·∫ßm quan tr·ªçng c·ªßa c√°c ƒë·∫∑c tr∆∞ng.
*   **M·∫°ng n∆°-ron (Neural Networks):** Linh ho·∫°t, c√≥ kh·∫£ nƒÉng h·ªçc c√°c m·ªëi quan h·ªá ph·ª©c t·∫°p, nh∆∞ng ƒë√≤i h·ªèi l∆∞·ª£ng d·ªØ li·ªáu l·ªõn v√† ƒëi·ªÅu ch·ªânh c·∫©n th·∫≠n.

**1.4. Quy tr√¨nh (Process)**

1.  **Thu th·∫≠p v√† chu·∫©n b·ªã d·ªØ li·ªáu (Data Collection and Preparation):**
    *   Truy v·∫•n d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL b·∫±ng SQL.
    *   L√†m s·∫°ch v√† ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (x·ª≠ l√Ω gi√° tr·ªã thi·∫øu, lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá).
    *   Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu SMILES th√†nh c√°c ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ RDKit.
    *   T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc b·∫±ng RDKit.
2.  **L·ª±a ch·ªçn ƒë·∫∑c tr∆∞ng (Feature Selection):**
    *   Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng quan tr·ªçng nh·∫•t b·∫±ng c√°c ph∆∞∆°ng ph√°p nh∆∞:
        *   Ph√¢n t√≠ch ph∆∞∆°ng sai (Variance Thresholding)
        *   L·ª±a ch·ªçn ƒë·∫∑c tr∆∞ng ƒë∆°n bi·∫øn (Univariate Feature Selection)
        *   L·ª±a ch·ªçn ƒë·∫∑c tr∆∞ng d·ª±a tr√™n c√¢y (Tree-based Feature Selection)
        *   Lo·∫°i b·ªè ƒë·ªá quy ƒë·∫∑c tr∆∞ng (Recursive Feature Elimination)
3.  **X√¢y d·ª±ng v√† hu·∫•n luy·ªán m√¥ h√¨nh (Model Building and Training):**
    *   Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.
    *   Ch·ªçn m·ªôt m√¥ h√¨nh ph√π h·ª£p v√† hu·∫•n luy·ªán n√≥ tr√™n t·∫≠p hu·∫•n luy·ªán.
4.  **ƒê√°nh gi√° m√¥ h√¨nh (Model Evaluation):**
    *   ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh tr√™n t·∫≠p ki·ªÉm tra b·∫±ng c√°c ƒë·ªô ƒëo ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE, MAE).
5.  **T·ªëi ∆∞u h√≥a m√¥ h√¨nh (Model Optimization):**
    *   ƒêi·ªÅu ch·ªânh c√°c si√™u tham s·ªë c·ªßa m√¥ h√¨nh ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t.
6.  **D·ª± ƒëo√°n v√† ph√¢n t√≠ch (Prediction and Analysis):**
    *   S·ª≠ d·ª•ng m√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t m·ªõi.
    *   Ph√¢n t√≠ch t·∫ßm quan tr·ªçng c·ªßa c√°c ƒë·∫∑c tr∆∞ng ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ m·ªëi quan h·ªá c·∫•u tr√∫c-ho·∫°t t√≠nh.

**2. H∆∞·ªõng d·∫´n Song ng·ªØ (Bilingual Guide)**

| B∆∞·ªõc (Step)                       | Ti·∫øng Anh (English)                                                                                                | Ti·∫øng Vi·ªát (Vietnamese)                                                                                             |
| :--------------------------------- | :------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------- |
| 1. K·∫øt n·ªëi CSDL (Connect DB)     | Connect to the ChEMBL database using the provided credentials.                                                    | K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL b·∫±ng th√¥ng tin ƒëƒÉng nh·∫≠p ƒë∆∞·ª£c cung c·∫•p.                                           |
| 2. Truy v·∫•n d·ªØ li·ªáu (Query data) | Query the `activities`, `molecule_dictionary`, and `compound_structures` tables to retrieve relevant data.            | Truy v·∫•n c√°c b·∫£ng `activities`, `molecule_dictionary` v√† `compound_structures` ƒë·ªÉ l·∫•y d·ªØ li·ªáu li√™n quan.           |
| 3. Ti·ªÅn x·ª≠ l√Ω (Preprocessing)    | Clean and preprocess the data (handle missing values, outliers).                                                    | L√†m s·∫°ch v√† ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (x·ª≠ l√Ω gi√° tr·ªã thi·∫øu, gi√° tr·ªã ngo·∫°i l·ªá).                                              |
| 4. ƒê·∫∑c tr∆∞ng (Feature Eng)      | Calculate chemical descriptors using RDKit from SMILES strings.                                                      | T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng h√≥a h·ªçc b·∫±ng RDKit t·ª´ chu·ªói SMILES.                                                            |
| 5. X√¢y d·ª±ng m√¥ h√¨nh (Model Build) | Build and train a machine learning model to predict biological activity.                                              | X√¢y d·ª±ng v√† hu·∫•n luy·ªán m·ªôt m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc.                                            |
| 6. ƒê√°nh gi√° (Evaluation)          | Evaluate the model's performance using appropriate metrics.                                                          | ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°c ƒë·ªô ƒëo ph√π h·ª£p.                                                                |
| 7. Ph√¢n t√≠ch (Analysis)           | Analyze the results and identify potential lead compounds.                                                           | Ph√¢n t√≠ch k·∫øt qu·∫£ v√† x√°c ƒë·ªãnh c√°c h·ª£p ch·∫•t ti·ªÅm nƒÉng.                                                                |

**3. Code SQL v√† Python (SQL and Python Code)**

**3.1. SQL (v√≠ d·ª• l·∫•y 100 d√≤ng)**

```sql
-- English
-- Select 100 activities with standard_type 'IC50' and valid standard_value
SELECT act.molregno, md.chembl_id, act.standard_value, act.standard_units,md.molecule_structures
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value IS NOT NULL
  AND act.standard_value > 0
  AND act.standard_units = 'nM'
  AND md.molecule_structures IS NOT NULL
  AND md.molecule_structures LIKE '%SMILES%'

LIMIT 100;

-- Vietnamese
-- Ch·ªçn 100 ho·∫°t ƒë·ªông c√≥ standard_type l√† 'IC50' v√† standard_value h·ª£p l·ªá
SELECT act.molregno, md.chembl_id, act.standard_value, act.standard_units,md.molecule_structures
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value IS NOT NULL
  AND act.standard_value > 0
  AND act.standard_units = 'nM'
  AND md.molecule_structures IS NOT NULL
  AND md.molecule_structures LIKE '%SMILES%'
LIMIT 100;
```

**L∆∞u √Ω:** L·ªói `ERROR: operator does not exist: numeric ~ unknown` th∆∞·ªùng x·∫£y ra khi b·∫°n c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ `~` (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ chuy·ªÉn ƒë·ªïi c·ªôt s·ªë th√†nh ki·ªÉu text tr∆∞·ªõc khi so s√°nh:
Kh√¥ng c·∫ßn thi·∫øt v√¨ ƒë√£ l·ªçc `act.standard_value IS NOT NULL AND act.standard_value > 0`

**3.2. Python (v√≠ d·ª• t√≠nh to√°n ƒë·∫∑c tr∆∞ng v√† x√¢y d·ª±ng m√¥ h√¨nh)**

```python
# English
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import numpy as np
# Define the base path
base_path = "../data"

# Load data from CSV
data = pd.read_csv(os.path.join(base_path, "chembl_ic50_data.csv"))

# Function to calculate molecular descriptors
def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        descriptors = {desc[0]: desc[1](mol) for desc in Descriptors.descList}
        return descriptors
    else:
        return None

# Apply descriptor calculation and handle errors
descriptors_list = []
for index, row in data.iterrows():
    try:
        smiles = row['molecule_structures'].split('"')[3]
        descriptors = calculate_descriptors(smiles)
        if descriptors is not None:
            descriptors['molregno'] = row['molregno']  # Keep molregno for merging
            descriptors_list.append(descriptors)
        else:
            print(f"Could not compute descriptors for molregno {row['molregno']}")
    except Exception as e:
        print(f"Error processing molregno {row['molregno']}: {e}")

# Convert list of descriptors to DataFrame
descriptors_df = pd.DataFrame(descriptors_list)

# Merge descriptors with activity data
merged_data = pd.merge(data[['molregno', 'standard_value']], descriptors_df, on='molregno', how='inner')

# Handle missing values by filling with the mean
merged_data.fillna(merged_data.mean(), inplace=True)

# Prepare data for modeling
X = merged_data.drop(['molregno', 'standard_value'], axis=1)
y = merged_data['standard_value']

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a linear regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions and evaluate the model
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")

# --- Vietnamese ---
# Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
# ƒê∆∞·ªùng d·∫´n c∆° s·ªü ƒë·∫øn th∆∞ m·ª•c d·ªØ li·ªáu
# ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV
# H√†m t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠
# √Åp d·ª•ng t√≠nh to√°n ƒë·∫∑c tr∆∞ng v√† x·ª≠ l√Ω l·ªói
# Chuy·ªÉn ƒë·ªïi danh s√°ch c√°c ƒë·∫∑c tr∆∞ng th√†nh DataFrame
# G·ªôp c√°c ƒë·∫∑c tr∆∞ng v·ªõi d·ªØ li·ªáu ho·∫°t t√≠nh
# X·ª≠ l√Ω gi√° tr·ªã thi·∫øu b·∫±ng c√°ch ƒëi·ªÅn b·∫±ng gi√° tr·ªã trung b√¨nh
# Chu·∫©n b·ªã d·ªØ li·ªáu cho m√¥ h√¨nh h√≥a
# Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra
# Hu·∫•n luy·ªán m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh
# D·ª± ƒëo√°n v√† ƒë√°nh gi√° m√¥ h√¨nh
# In ra l·ªói b√¨nh ph∆∞∆°ng trung b√¨nh
```

**L∆∞u √Ω:** N·∫øu b·∫°n g·∫∑p l·ªói li√™n quan ƒë·∫øn phi√™n b·∫£n scikit-learn, h√£y c·∫≠p nh·∫≠t l√™n phi√™n b·∫£n m·ªõi nh·∫•t ho·∫∑c lo·∫°i b·ªè tham s·ªë `squared=False` n·∫øu kh√¥ng c·∫ßn thi·∫øt.

**4. V√≠ d·ª• Code (Code Examples)**

D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:

**V√≠ d·ª• 1: L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh (Filtering data by activity range)**

*   **SQL:**

```sql
-- English
-- Select compounds with IC50 values between 100 and 1000 nM
SELECT md.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value >= 100
  AND act.standard_value <= 1000
LIMIT 100;

-- Vietnamese
-- Ch·ªçn c√°c h·ª£p ch·∫•t c√≥ gi√° tr·ªã IC50 n·∫±m trong kho·∫£ng t·ª´ 100 ƒë·∫øn 1000 nM
SELECT md.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary md ON act.molregno = md.molregno
WHERE act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value >= 100
  AND act.standard_value <= 1000
LIMIT 100;
```

*   **Python:**

```python
# English
# Filter compounds with IC50 values between 100 and 1000 nM
filtered_data = data[(data['standard_value'] >= 100) & (data['standard_value'] <= 1000)]
print(filtered_data.head())

# Vietnamese
# L·ªçc c√°c h·ª£p ch·∫•t c√≥ gi√° tr·ªã IC50 n·∫±m trong kho·∫£ng t·ª´ 100 ƒë·∫øn 1000 nM
filtered_data = data[(data['standard_value'] >= 100) & (data['standard_value'] <= 1000)]
print(filtered_data.head())
```

**V√≠ d·ª• 2: T√≠nh to√°n LogP (Calculating LogP)**

*   **Python:**

```python
# English
# Function to calculate LogP using RDKit
from rdkit.Chem import AllChem
from rdkit import DataStructs

def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        logp = Descriptors.MolLogP(mol)
        return logp
    else:
        return None

# Apply LogP calculation
data['logp'] = data['molecule_structures'].apply(lambda x: calculate_logp(x.split('"')[3]) if isinstance(x, str) else None)
print(data[['molecule_structures', 'logp']].head())

# Vietnamese
# H√†m t√≠nh to√°n LogP s·ª≠ d·ª•ng RDKit
def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        logp = Descriptors.MolLogP(mol)
        return logp
    else:
        return None

# √Åp d·ª•ng t√≠nh to√°n LogP
data['logp'] = data['molecule_structures'].apply(lambda x: calculate_logp(x.split('"')[3]) if isinstance(x, str) else None)
print(data[['molecule_structures', 'logp']].head())
```

**V√≠ d·ª• 3: S·ª≠ d·ª•ng Random Forest ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh (Using Random Forest for activity prediction)**

*   **Python:**

```python
# English
# Use Random Forest to predict activity
from sklearn.ensemble import RandomForestRegressor

# Prepare data (assuming X and y are already defined)
X = merged_data.drop(['molregno', 'standard_value'], axis=1)
y = merged_data['standard_value']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a Random Forest model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)

# Make predictions and evaluate the model
y_pred = rf_model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error (Random Forest): {mse}")

# Vietnamese
# S·ª≠ d·ª•ng Random Forest ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh
# Chu·∫©n b·ªã d·ªØ li·ªáu (gi·∫£ s·ª≠ X v√† y ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a)
# Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest
# D·ª± ƒëo√°n v√† ƒë√°nh gi√° m√¥ h√¨nh
```

**V√≠ d·ª• 4: Ph√¢n t√≠ch t·∫ßm quan tr·ªçng c·ªßa ƒë·∫∑c tr∆∞ng (Feature importance analysis)**

*   **Python:**

```python
# English
# Analyze feature importance
import matplotlib.pyplot as plt

importances = rf_model.feature_importances_
feature_names = X.columns
feature_importances = pd.DataFrame({'feature': feature_names, 'importance': importances})
feature_importances = feature_importances.sort_values('importance', ascending=False)

plt.figure(figsize=(10, 6))
plt.bar(feature_importances['feature'], feature_importances['importance'])
plt.xticks(rotation=90)
plt.xlabel('Features')
plt.ylabel('Importance')
plt.title('Feature Importance')
plt.tight_layout()
plt.show()

# Vietnamese
# Ph√¢n t√≠ch t·∫ßm quan tr·ªçng c·ªßa ƒë·∫∑c tr∆∞ng
# L·∫•y t·∫ßm quan tr·ªçng c·ªßa c√°c ƒë·∫∑c tr∆∞ng t·ª´ m√¥ h√¨nh
# V·∫Ω bi·ªÉu ƒë·ªì t·∫ßm quan tr·ªçng c·ªßa c√°c ƒë·∫∑c tr∆∞ng
```

**V√≠ d·ª• 5: L∆∞u k·∫øt qu·∫£ d·ª± ƒëo√°n (Saving prediction results)**

*   **Python:**

```python
# English
# Save prediction results
predictions = pd.DataFrame({'actual': y_test, 'predicted': y_pred})
predictions.to_csv(os.path.join(base_path, "predictions.csv"), index=False)
print("Predictions saved to predictions.csv")

# Vietnamese
# L∆∞u k·∫øt qu·∫£ d·ª± ƒëo√°n
# T·∫°o DataFrame ch·ª©a gi√° tr·ªã th·ª±c t·∫ø v√† gi√° tr·ªã d·ª± ƒëo√°n
# L∆∞u DataFrame v√†o file CSV
```

Hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n ti·∫øn xa h∆°n trong d·ª± √°n c·ªßa m√¨nh. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi!
