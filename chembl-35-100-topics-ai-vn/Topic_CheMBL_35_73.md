# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: ·ª®ng d·ª•ng t√¨m ki·∫øm t∆∞∆°ng ƒë·ªìng t∆∞∆°ng t√°c
---
Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&D d∆∞·ª£c h·ªçc, t√¥i s·∫Ω gi√∫p b·∫°n x√¢y d·ª±ng quy tr√¨nh ph√¢n t√≠ch hi·ªáu qu·∫£, kh·∫Øc ph·ª•c c√°c l·ªói v√† ƒë∆∞a ra c√°c v√≠ d·ª• c·ª• th·ªÉ ƒë·ªÉ b·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu ngay.

**Ph√¢n t√≠ch T·ªïng quan v√† M√¥ h√¨nh Ph√¢n t√≠ch (Overview and Analysis Model)**

D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, s·ª≠ d·ª•ng RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc v√† PostgreSQL ƒë·ªÉ qu·∫£n l√Ω d·ªØ li·ªáu. M·ª•c ti√™u l√† h·ªó tr·ª£ c√°c nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. D∆∞·ªõi ƒë√¢y l√† m√¥ h√¨nh ph√¢n t√≠ch t·ªïng quan m√† ch√∫ng ta c√≥ th·ªÉ √°p d·ª•ng:

1.  **Data Extraction and Preparation (Tr√≠ch xu·∫•t v√† Chu·∫©n b·ªã D·ªØ li·ªáu):**
    *   S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ ChEMBL 35, t·∫≠p trung v√†o c√°c b·∫£ng ch·ª©a th√¥ng tin v·ªÅ ho·∫°t t√≠nh sinh h·ªçc (bioactivity), c·∫•u tr√∫c h√≥a h·ªçc, v√† c√°c thu·ªôc t√≠nh li√™n quan.
    *   L∆∞u d·ªØ li·ªáu tr√≠ch xu·∫•t v√†o c√°c file CSV ƒë·ªÉ d·ªÖ d√†ng x·ª≠ l√Ω b·∫±ng Python.
    *   S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ (v√≠ d·ª•: tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠, logP, s·ªë l∆∞·ª£ng v√≤ng) t·ª´ c·∫•u tr√∫c SMILES.
2.  **Data Cleaning and Preprocessing (L√†m s·∫°ch v√† Ti·ªÅn x·ª≠ l√Ω D·ªØ li·ªáu):**
    *   X·ª≠ l√Ω c√°c gi√° tr·ªã thi·∫øu (missing values) v√† ngo·∫°i l·ªá (outliers).
    *   Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n.
    *   Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªãnh t√≠nh th√†nh ƒë·ªãnh l∆∞·ª£ng n·∫øu c·∫ßn thi·∫øt.
3.  **Exploratory Data Analysis (EDA) (Ph√¢n t√≠ch Kh√°m ph√° D·ªØ li·ªáu):**
    *   S·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t th·ªëng k√™ v√† tr·ª±c quan h√≥a ƒë·ªÉ kh√°m ph√° c√°c xu h∆∞·ªõng v√† m·ªëi quan h·ªá trong d·ªØ li·ªáu.
    *   V√≠ d·ª•: ph√¢n ph·ªëi c·ªßa c√°c gi√° tr·ªã ho·∫°t t√≠nh, m·ªëi t∆∞∆°ng quan gi·ªØa c√°c descriptor ph√¢n t·ª≠ v√† ho·∫°t t√≠nh.
4.  **Model Building and Evaluation (X√¢y d·ª±ng v√† ƒê√°nh gi√° M√¥ h√¨nh):**
    *   X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, random forest, m·∫°ng n∆°-ron) d·ª±a tr√™n c√°c descriptor ph√¢n t·ª≠.
    *   ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh b·∫±ng c√°c ch·ªâ s·ªë ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE, AUC).
5.  **Interpretation and Application (Gi·∫£i th√≠ch v√† ·ª®ng d·ª•ng):**
    *   Gi·∫£i th√≠ch c√°c k·∫øt qu·∫£ m√¥ h√¨nh ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c v√† ho·∫°t t√≠nh.
    *   ·ª®ng d·ª•ng m√¥ h√¨nh ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh c·ªßa c√°c h·ª£p ch·∫•t m·ªõi, s√†ng l·ªçc ·∫£o (virtual screening), v√† t·ªëi ∆∞u h√≥a c·∫•u tr√∫c thu·ªëc.

**H∆∞·ªõng d·∫´n Song ng·ªØ v√† M√£ (Bilingual Guide and Code)**

D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt v√† m√£ m·∫´u cho t·ª´ng b∆∞·ªõc, k√®m theo gi·∫£i th√≠ch b·∫±ng c·∫£ ti·∫øng Anh v√† ti·∫øng Vi·ªát:

**1. Data Extraction (Tr√≠ch xu·∫•t D·ªØ li·ªáu)**

**SQL Code (Ti·∫øng Anh):**

```sql
-- Extract bioactivity data and molecule structures from ChEMBL
-- L·∫•y d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc v√† c·∫•u tr√∫c ph√¢n t·ª≠ t·ª´ ChEMBL
SELECT
    act.molregno,
    mol.chembl_id,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    mol.molsmiles
FROM
    activities act
JOIN
    molecule_dictionary mol ON act.molregno = mol.molregno
WHERE
    act.standard_type = 'IC50'  -- You can change this to other activity types like Ki, EC50, etc.
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value > 0
    AND act.standard_value < 10000 -- Filter out very high IC50 values
    AND act.standard_units = 'nM'
LIMIT 100; -- Limit to 100 rows for testing

-- Save the result as a CSV file (e.g., chembl_ic50_data.csv)
-- L∆∞u k·∫øt qu·∫£ v√†o file CSV (v√≠ d·ª•: chembl_ic50_data.csv)
```

**SQL Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):**

```sql
-- L·∫•y d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc v√† c·∫•u tr√∫c ph√¢n t·ª≠ t·ª´ ChEMBL
SELECT
    act.molregno,  -- M√£ s·ªë ph√¢n t·ª≠ (molecule registry number)
    mol.chembl_id, -- M√£ ChEMBL c·ªßa ph√¢n t·ª≠
    act.standard_type, -- Lo·∫°i ho·∫°t t√≠nh (v√≠ d·ª•: IC50, Ki)
    act.standard_value, -- Gi√° tr·ªã ho·∫°t t√≠nh
    act.standard_units, -- ƒê∆°n v·ªã c·ªßa gi√° tr·ªã ho·∫°t t√≠nh
    mol.molsmiles -- C·∫•u tr√∫c SMILES c·ªßa ph√¢n t·ª≠
FROM
    activities act  -- B·∫£ng ch·ª©a th√¥ng tin ho·∫°t t√≠nh
JOIN
    molecule_dictionary mol ON act.molregno = mol.molregno  -- B·∫£ng ch·ª©a th√¥ng tin ph√¢n t·ª≠, k·∫øt n·ªëi qua molregno
WHERE
    act.standard_type = 'IC50'  -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh lo·∫°i IC50 (c√≥ th·ªÉ thay ƒë·ªïi)
    AND act.standard_relation = '=' -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh c√≥ quan h·ªá "=" (b·∫±ng)
    AND act.standard_value IS NOT NULL -- L·ªçc b·ªè c√°c gi√° tr·ªã ho·∫°t t√≠nh b·ªã thi·∫øu
    AND act.standard_value > 0 -- L·ªçc b·ªè c√°c gi√° tr·ªã ho·∫°t t√≠nh √¢m ho·∫∑c b·∫±ng 0
    AND act.standard_value < 10000 -- L·ªçc b·ªè c√°c gi√° tr·ªã IC50 qu√° cao (l·ªõn h∆°n 10000 nM)
    AND act.standard_units = 'nM' -- L·ªçc ch·ªâ l·∫•y c√°c ho·∫°t t√≠nh c√≥ ƒë∆°n v·ªã l√† nM (nanomolar)
LIMIT 100; -- Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng k·∫øt qu·∫£ tr·∫£ v·ªÅ l√† 100 d√≤ng (cho m·ª•c ƒë√≠ch th·ª≠ nghi·ªám)

-- L∆∞u k·∫øt qu·∫£ v√†o file CSV (v√≠ d·ª•: chembl_ic50_data.csv)
```

**L∆∞u √Ω v·ªÅ l·ªói "operator does not exist: numeric ~ unknown":**

L·ªói n√†y th∆∞·ªùng x·∫£y ra khi b·∫°n c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ `~` (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë (numeric). ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ chuy·ªÉn ƒë·ªïi c·ªôt s·ªë th√†nh ki·ªÉu chu·ªói (text) tr∆∞·ªõc khi s·ª≠ d·ª•ng to√°n t·ª≠ `~`. Tuy nhi√™n, trong tr∆∞·ªùng h·ª£p n√†y, b·∫°n kh√¥ng c·∫ßn s·ª≠ d·ª•ng regular expression ƒë·ªÉ l·ªçc c√°c gi√° tr·ªã s·ªë. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c to√°n t·ª≠ so s√°nh tr·ª±c ti·∫øp nh∆∞ `>` v√† `<`.

**2. Data Loading and Processing with RDKit (T·∫£i v√† X·ª≠ l√Ω D·ªØ li·ªáu v·ªõi RDKit)**

**Python Code (Ti·∫øng Anh):**

```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import os

# Define the base path for your project
# ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n
base_path = '.'  # Adjust this to your actual base path

# Load the CSV file containing ChEMBL data
# T·∫£i file CSV ch·ª©a d·ªØ li·ªáu ChEMBL
data_path = os.path.join(base_path, 'data', 'chembl_ic50_data.csv')  # Adjust the file name accordingly
df = pd.read_csv(data_path)

# Function to calculate molecular descriptors using RDKit
# H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ b·∫±ng RDKit
def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {
        "MW": Descriptors.MolWt(mol),
        "LogP": Descriptors.MolLogP(mol),
        "HBA": Descriptors.NumHAcceptors(mol),
        "HBD": Descriptors.NumHDonors(mol),
        "TPSA": Descriptors.TPSA(mol)
    }
    return descriptors

# Apply the function to each SMILES string in the dataframe
# √Åp d·ª•ng h√†m cho m·ªói chu·ªói SMILES trong dataframe
df['descriptors'] = df['molsmiles'].apply(calculate_descriptors)

# Expand the descriptor dictionary into separate columns
# M·ªü r·ªông t·ª´ ƒëi·ªÉn descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát
df = pd.concat([df, df['descriptors'].apply(pd.Series)], axis=1)

# Drop rows with missing descriptors
# Lo·∫°i b·ªè c√°c h√†ng c√≥ descriptor b·ªã thi·∫øu
df = df.dropna(subset=['MW', 'LogP', 'HBA', 'HBD', 'TPSA'])

# Convert IC50 values to pIC50 (optional)
# Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50 (t√πy ch·ªçn)
df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Convert nM to Molar

# Display the first few rows of the processed dataframe
# Hi·ªÉn th·ªã m·ªôt v√†i h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe ƒë√£ x·ª≠ l√Ω
print(df.head())
```

**Python Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):**

```python
import pandas as pd  # Th∆∞ vi·ªán ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu d·∫°ng b·∫£ng
from rdkit import Chem  # Th∆∞ vi·ªán RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc
from rdkit.Chem import Descriptors  # C√°c module con c·ªßa RDKit ƒë·ªÉ t√≠nh to√°n descriptor
import os  # Th∆∞ vi·ªán ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi h·ªá ƒëi·ªÅu h√†nh

# ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc c·ªßa d·ª± √°n
base_path = '.'  # ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n n√†y cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c c·ªßa b·∫°n

# T·∫£i file CSV ch·ª©a d·ªØ li·ªáu ChEMBL
data_path = os.path.join(base_path, 'data', 'chembl_ic50_data.csv')  # ƒêi·ªÅu ch·ªânh t√™n file cho ph√π h·ª£p
df = pd.read_csv(data_path)  # ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV v√†o m·ªôt dataframe

# H√†m t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ b·∫±ng RDKit
def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)  # Chuy·ªÉn ƒë·ªïi chu·ªói SMILES th√†nh ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠ c·ªßa RDKit
    if mol is None:  # Ki·ªÉm tra xem chuy·ªÉn ƒë·ªïi c√≥ th√†nh c√¥ng kh√¥ng
        return None  # Tr·∫£ v·ªÅ None n·∫øu kh√¥ng th√†nh c√¥ng (v√≠ d·ª•: SMILES kh√¥ng h·ª£p l·ªá)
    descriptors = {  # T·∫°o m·ªôt t·ª´ ƒëi·ªÉn ƒë·ªÉ l∆∞u tr·ªØ c√°c descriptor
        "MW": Descriptors.MolWt(mol),  # Tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Molecular Weight)
        "LogP": Descriptors.MolLogP(mol),  # H·ªá s·ªë ph√¢n v√πng octanol-n∆∞·ªõc (LogP)
        "HBA": Descriptors.NumHAcceptors(mol),  # S·ªë l∆∞·ª£ng ch·∫•t nh·∫≠n li√™n k·∫øt hydro (Hydrogen Bond Acceptors)
        "HBD": Descriptors.NumHDonors(mol),  # S·ªë l∆∞·ª£ng ch·∫•t cho li√™n k·∫øt hydro (Hydrogen Bond Donors)
        "TPSA": Descriptors.TPSA(mol)  # Di·ªán t√≠ch b·ªÅ m·∫∑t ph√¢n c·ª±c (Topological Polar Surface Area)
    }
    return descriptors  # Tr·∫£ v·ªÅ t·ª´ ƒëi·ªÉn ch·ª©a c√°c descriptor

# √Åp d·ª•ng h√†m cho m·ªói chu·ªói SMILES trong dataframe
df['descriptors'] = df['molsmiles'].apply(calculate_descriptors)  # T·∫°o m·ªôt c·ªôt m·ªõi 'descriptors' ch·ª©a k·∫øt qu·∫£

# M·ªü r·ªông t·ª´ ƒëi·ªÉn descriptor th√†nh c√°c c·ªôt ri√™ng bi·ªát
df = pd.concat([df, df['descriptors'].apply(pd.Series)], axis=1)  # T·∫°o c√°c c·ªôt m·ªõi t·ª´ t·ª´ ƒëi·ªÉn descriptor

# Lo·∫°i b·ªè c√°c h√†ng c√≥ descriptor b·ªã thi·∫øu
df = df.dropna(subset=['MW', 'LogP', 'HBA', 'HBD', 'TPSA'])  # Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã NaN trong c√°c c·ªôt descriptor

# Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50 (t√πy ch·ªçn)
df['pIC50'] = -np.log10(df['standard_value'] * 1e-9)  # Chuy·ªÉn ƒë·ªïi nM sang Molar v√† t√≠nh pIC50

# Hi·ªÉn th·ªã m·ªôt v√†i h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe ƒë√£ x·ª≠ l√Ω
print(df.head())  # In ra 5 h√†ng ƒë·∫ßu ti√™n c·ªßa dataframe
```

**3. Model Building (X√¢y d·ª±ng M√¥ h√¨nh)**

**Python Code (Ti·∫øng Anh):**

```python
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Prepare the data for modeling
# Chu·∫©n b·ªã d·ªØ li·ªáu cho vi·ªác x√¢y d·ª±ng m√¥ h√¨nh
X = df[['MW', 'LogP', 'HBA', 'HBD', 'TPSA']]  # Features
y = df['pIC50']  # Target variable

# Split the data into training and testing sets
# Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a Random Forest Regressor model
# T·∫°o m·ªôt m√¥ h√¨nh Random Forest Regressor
model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
# Hu·∫•n luy·ªán m√¥ h√¨nh
model.fit(X_train, y_train)

# Make predictions on the test set
# D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra
y_pred = model.predict(X_test)

# Evaluate the model
# ƒê√°nh gi√° m√¥ h√¨nh
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```

**Python Code (Ti·∫øng Vi·ªát - Gi·∫£i th√≠ch):**

```python
from sklearn.model_selection import train_test_split  # H√†m ƒë·ªÉ chia d·ªØ li·ªáu
from sklearn.ensemble import RandomForestRegressor  # M√¥ h√¨nh Random Forest
from sklearn.metrics import mean_squared_error, r2_score  # C√°c ch·ªâ s·ªë ƒë√°nh gi√° m√¥ h√¨nh

# Chu·∫©n b·ªã d·ªØ li·ªáu cho vi·ªác x√¢y d·ª±ng m√¥ h√¨nh
X = df[['MW', 'LogP', 'HBA', 'HBD', 'TPSA']]  # C√°c bi·∫øn ƒë·ªôc l·∫≠p (features)
y = df['pIC50']  # Bi·∫øn ph·ª• thu·ªôc (target variable)

# Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # 80% cho hu·∫•n luy·ªán, 20% cho ki·ªÉm tra

# T·∫°o m·ªôt m√¥ h√¨nh Random Forest Regressor
model = RandomForestRegressor(n_estimators=100, random_state=42)  # S·ªë l∆∞·ª£ng c√¢y trong r·ª´ng l√† 100

# Hu·∫•n luy·ªán m√¥ h√¨nh
model.fit(X_train, y_train)  # S·ª≠ d·ª•ng t·∫≠p hu·∫•n luy·ªán ƒë·ªÉ "d·∫°y" m√¥ h√¨nh

# D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra
y_pred = model.predict(X_test)  # S·ª≠ d·ª•ng m√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán ƒë·ªÉ d·ª± ƒëo√°n gi√° tr·ªã pIC50 tr√™n t·∫≠p ki·ªÉm tra

# ƒê√°nh gi√° m√¥ h√¨nh
mse = mean_squared_error(y_test, y_pred)  # T√≠nh sai s·ªë b√¨nh ph∆∞∆°ng trung b√¨nh (Mean Squared Error)
r2 = r2_score(y_test, y_pred)  # T√≠nh h·ªá s·ªë x√°c ƒë·ªãnh (R-squared)

print(f"Mean Squared Error: {mse}")  # In ra gi√° tr·ªã MSE
print(f"R-squared: {r2}")  # In ra gi√° tr·ªã R-squared
```

**L∆∞u √Ω v·ªÅ l·ªói "squared=False trong h√†m mean_squared_error":**

Tham s·ªë `squared=False` ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†m `mean_squared_error` trong c√°c phi√™n b·∫£n scikit-learn m·ªõi h∆°n ƒë·ªÉ tr·∫£ v·ªÅ Root Mean Squared Error (RMSE) thay v√¨ MSE. N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, b·∫°n s·∫Ω g·∫∑p l·ªói khi s·ª≠ d·ª•ng tham s·ªë n√†y. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ n√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t ho·∫∑c t√≠nh RMSE th·ªß c√¥ng b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE:

```python
mse = mean_squared_error(y_test, y_pred)
rmse = mse**0.5
print(f"Root Mean Squared Error: {rmse}")
```

**4. V√≠ d·ª• M√£ (Code Examples)**

D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• m√£ SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:

**V√≠ d·ª• 1: L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh (Filtering Data by Activity Range)**

**SQL:**

```sql
SELECT mol.chembl_id, act.standard_value
FROM activities act
JOIN molecule_dictionary mol ON act.molregno = mol.molregno
WHERE act.standard_type = 'IC50' AND act.standard_value BETWEEN 100 AND 1000;
```

**Python:**

```python
df_filtered = df[(df['standard_value'] >= 100) & (df['standard_value'] <= 1000)]
print(df_filtered.head())
```

**V√≠ d·ª• 2: T√≠nh to√°n s·ªë l∆∞·ª£ng ph√¢n t·ª≠ c√≥ m·ªôt s·ªë l∆∞·ª£ng v√≤ng nh·∫•t ƒë·ªãnh (Calculating Number of Molecules with Specific Ring Count)**

**SQL (C·∫ßn th√™m th√¥ng tin v·ªÅ s·ªë l∆∞·ª£ng v√≤ng v√†o b·∫£ng):**

```sql
-- This requires a table with ring count information
-- ƒêi·ªÅu n√†y y√™u c·∫ßu m·ªôt b·∫£ng c√≥ th√¥ng tin v·ªÅ s·ªë l∆∞·ª£ng v√≤ng
-- Example: molecule_properties table with 'num_rings' column
-- V√≠ d·ª•: b·∫£ng molecule_properties c√≥ c·ªôt 'num_rings'
SELECT mol.chembl_id
FROM molecule_dictionary mol
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE mp.num_rings = 3;
```

**Python:**

```python
from rdkit.Chem import RingInfo

def get_ring_count(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        ring_info = mol.GetRingInfo()
        return ring_info.NumRings()
    return None

df['ring_count'] = df['molsmiles'].apply(get_ring_count)
print(df['ring_count'].value_counts())
```

**V√≠ d·ª• 3: T√¨m c√°c ph√¢n t·ª≠ c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trong m·ªôt kho·∫£ng nh·∫•t ƒë·ªãnh (Finding Molecules with Molecular Weight in a Specific Range)**

**SQL:**

```sql
-- Assuming you have a table with molecular weights
-- Gi·∫£ s·ª≠ b·∫°n c√≥ m·ªôt b·∫£ng v·ªõi tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠
-- Example: molecule_properties table with 'molecular_weight' column
-- V√≠ d·ª•: b·∫£ng molecule_properties c√≥ c·ªôt 'molecular_weight'
SELECT mol.chembl_id
FROM molecule_dictionary mol
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE mp.molecular_weight BETWEEN 200 AND 400;
```

**Python:**

```python
df_mw_filtered = df[(df['MW'] >= 200) & (df['MW'] <= 400)]
print(df_mw_filtered.head())
```

**V√≠ d·ª• 4: Ph√¢n t√≠ch m·ªëi t∆∞∆°ng quan gi·ªØa LogP v√† pIC50 (Analyzing Correlation between LogP and pIC50)**

**SQL (Kh√¥ng th·ªÉ t√≠nh t∆∞∆°ng quan tr·ª±c ti·∫øp trong SQL ƒë∆°n gi·∫£n):**

```sql
-- SQL can't directly calculate correlation easily, use Python
-- SQL kh√¥ng th·ªÉ t√≠nh t∆∞∆°ng quan tr·ª±c ti·∫øp m·ªôt c√°ch d·ªÖ d√†ng, h√£y s·ª≠ d·ª•ng Python
SELECT mol.chembl_id, act.standard_value, mp.logp
FROM activities act
JOIN molecule_dictionary mol ON act.molregno = mol.molregno
JOIN molecule_properties mp ON mol.molregno = mp.molregno
WHERE act.standard_type = 'IC50';
```

**Python:**

```python
correlation = df['LogP'].corr(df['pIC50'])
print(f"Correlation between LogP and pIC50: {correlation}")
```

**V√≠ d·ª• 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng scatter plot (Data Visualization using Scatter Plot)**

**Python:**

```python
import matplotlib.pyplot as plt

plt.scatter(df['LogP'], df['pIC50'])
plt.xlabel('LogP')
plt.ylabel('pIC50')
plt.title('LogP vs pIC50')
plt.show()
```

**L∆∞u √Ω Quan tr·ªçng:**

*   **ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n:** H√£y ch·∫Øc ch·∫Øn r·∫±ng b·∫°n ƒë√£ ƒëi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n file v√† t√™n file trong code cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c v√† t√™n file th·ª±c t·∫ø c·ªßa b·∫°n.
*   **C√†i ƒë·∫∑t th∆∞ vi·ªán:** ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√†i ƒë·∫∑t t·∫•t c·∫£ c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt (v√≠ d·ª•: pandas, rdkit, scikit-learn, matplotlib) tr∆∞·ªõc khi ch·∫°y code Python.
*   **X·ª≠ l√Ω l·ªói:** Lu√¥n ki·ªÉm tra v√† x·ª≠ l√Ω c√°c l·ªói c√≥ th·ªÉ x·∫£y ra trong qu√° tr√¨nh ch·∫°y code.
*   **Gi·ªõi h·∫°n d·ªØ li·ªáu:** V√¨ l√Ω do hi·ªáu su·∫•t, ch√∫ng ta ƒëang gi·ªõi h·∫°n s·ªë l∆∞·ª£ng d·ªØ li·ªáu ƒë∆∞·ª£c tr√≠ch xu·∫•t v√† x·ª≠ l√Ω. B·∫°n c√≥ th·ªÉ tƒÉng gi·ªõi h·∫°n n√†y khi c·∫ßn thi·∫øt, nh∆∞ng h√£y c·∫©n th·∫≠n v·ªõi t√†i nguy√™n m√°y t√≠nh c·ªßa b·∫°n.

Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.
