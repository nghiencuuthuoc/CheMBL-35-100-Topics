
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_84</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: Li√™n k·∫øt ChEMBL v·ªõi d·ªØ li·ªáu nh√£n FDA</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 n√†y. V·ªõi vai tr√≤ l√† chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i s·∫Ω gi√∫p b·∫°n x√¢y d·ª±ng quy tr√¨nh ph√¢n t√≠ch hi·ªáu qu·∫£, gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ k·ªπ thu·∫≠t v√† cung c·∫•p c√°c v√≠ d·ª• code ƒë·ªÉ b·∫°n tham kh·∫£o.</p>
<p><strong>T·ªïng quan d·ª± √°n:</strong></p>
<p>D·ª± √°n n√†y t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, m·ªôt ngu·ªìn th√¥ng tin phong ph√∫ v·ªÅ c√°c h·ª£p ch·∫•t h√≥a h·ªçc v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng. S·ª≠ d·ª•ng RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc v√† Python ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu, b·∫°n c√≥ th·ªÉ kh√°m ph√° c√°c m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c ph√¢n t·ª≠ v√† ho·∫°t t√≠nh, t·ª´ ƒë√≥ h·ªó tr·ª£ qu√° tr√¨nh thi·∫øt k·∫ø v√† ph√°t tri·ªÉn thu·ªëc.</p>
<p><strong>Ph√¢n t√≠ch v√† H∆∞·ªõng d·∫´n:</strong></p>
<p>Ch√∫ng ta s·∫Ω t·∫≠p trung v√†o ch·ªß ƒë·ªÅ <code>Topic_CheMBL_35_84</code>. ƒê·ªÉ b·∫Øt ƒë·∫ßu, ch√∫ng ta c·∫ßn x√°c ƒë·ªãnh m·ª•c ti√™u c·ª• th·ªÉ c·ªßa ch·ªß ƒë·ªÅ n√†y. V√≠ d·ª•:</p>
<ul>
<li><strong>M·ª•c ti√™u:</strong> X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh ·ª©c ch·∫ø enzyme (v√≠ d·ª•: IC50) d·ª±a tr√™n c·∫•u tr√∫c ph√¢n t·ª≠ c·ªßa c√°c h·ª£p ch·∫•t.</li>
<li><strong>M√¥ h√¨nh ph√¢n t√≠ch:</strong><ol>
<li><strong>Chu·∫©n b·ªã d·ªØ li·ªáu:</strong><ul>
<li>K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.</li>
<li>L·ªçc d·ªØ li·ªáu theo enzyme m·ª•c ti√™u (target).</li>
<li>L√†m s·∫°ch d·ªØ li·ªáu ho·∫°t t√≠nh (activity data), lo·∫°i b·ªè c√°c gi√° tr·ªã kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng ƒë·∫ßy ƒë·ªß.</li>
<li>T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ (molecular descriptors) b·∫±ng RDKit.</li>
</ul>
</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh:</strong><ul>
<li>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán (training set) v√† t·∫≠p ki·ªÉm tra (test set).</li>
<li>Ch·ªçn thu·∫≠t to√°n h·ªçc m√°y ph√π h·ª£p (v√≠ d·ª•: Random Forest, Support Vector Machine).</li>
<li>Hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p hu·∫•n luy·ªán.</li>
<li>ƒê√°nh gi√° hi·ªáu nƒÉng c·ªßa m√¥ h√¨nh tr√™n t·∫≠p ki·ªÉm tra.</li>
</ul>
</li>
<li><strong>Di·ªÖn gi·∫£i k·∫øt qu·∫£:</strong><ul>
<li>X√°c ƒë·ªãnh c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh.</li>
<li>ƒê·ªÅ xu·∫•t c√°c c·∫£i ti·∫øn c·∫•u tr√∫c ƒë·ªÉ tƒÉng c∆∞·ªùng ho·∫°t t√≠nh.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>H∆∞·ªõng d·∫´n song ng·ªØ:</strong></p>
<p><strong>1. Data Preparation (Chu·∫©n b·ªã d·ªØ li·ªáu):</strong></p>
<ul>
<li><strong>SQL:</strong> Extract relevant data from ChEMBL database.</li>
<li><strong>SQL:</strong> Tr√≠ch xu·∫•t d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL.</li>
<li><strong>Python:</strong> Calculate molecular descriptors using RDKit.</li>
<li><strong>Python:</strong> T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ b·∫±ng RDKit.</li>
</ul>
<p><strong>2. Model Building (X√¢y d·ª±ng m√¥ h√¨nh):</strong></p>
<ul>
<li><strong>Python:</strong> Train a machine learning model to predict activity.</li>
<li><strong>Python:</strong> Hu·∫•n luy·ªán m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh.</li>
<li><strong>Python:</strong> Evaluate model performance using appropriate metrics.</li>
<li><strong>Python:</strong> ƒê√°nh gi√° hi·ªáu nƒÉng c·ªßa m√¥ h√¨nh b·∫±ng c√°c ƒë·ªô ƒëo ph√π h·ª£p.</li>
</ul>
<p><strong>3. Interpretation (Di·ªÖn gi·∫£i):</strong></p>
<ul>
<li><strong>Python:</strong> Identify key molecular features influencing activity.</li>
<li><strong>Python:</strong> X√°c ƒë·ªãnh c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ quan tr·ªçng ·∫£nh h∆∞·ªüng ƒë·∫øn ho·∫°t t√≠nh.</li>
<li>**Based on the model, propose structural modifications to improve activity.</li>
<li>D·ª±a tr√™n m√¥ h√¨nh, ƒë·ªÅ xu·∫•t c√°c c·∫£i ti·∫øn c·∫•u tr√∫c ƒë·ªÉ tƒÉng c∆∞·ªùng ho·∫°t t√≠nh.</li>
</ul>
<p><strong>Code SQL:</strong></p>
<p>```sql
-- L·∫•y 100 h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh tr√™n m·ªôt m·ª•c ti√™u c·ª• th·ªÉ (v√≠ d·ª•: CHEMBL205)
SELECT DISTINCT mol.molregno,
                md.chembl_id,
                act.standard_value,
                act.standard_units
FROM molecule_dictionary mol
    JOIN activities act ON mol.molregno = act.molregno
    JOIN assay_xref ax ON act.assay_id = ax.assay_id
    JOIN target_dictionary td ON ax.tid = td.tid
    JOIN compound_structures cs ON mol.molregno = cs.molregno
WHERE td.chembl_id = 'CHEMBL205'
  AND act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value IS NOT NULL
LIMIT 100;</p>
<p>-- S·ª≠a l·ªói li√™n quan ƒë·∫øn ki·ªÉu d·ªØ li·ªáu trong ƒëi·ªÅu ki·ªán l·ªçc
-- Chuy·ªÉn ƒë·ªïi gi√° tr·ªã standard_value sang ki·ªÉu numeric tr∆∞·ªõc khi so s√°nh
SELECT DISTINCT mol.molregno,
                md.chembl_id,
                act.standard_value,
                act.standard_units
FROM molecule_dictionary mol
    JOIN activities act ON mol.molregno = act.molregno
    JOIN assay_xref ax ON act.assay_id = ax.assay_id
    JOIN target_dictionary td ON ax.tid = td.tid
    JOIN compound_structures cs ON mol.molregno = cs.molregno
WHERE td.chembl_id = 'CHEMBL205'
  AND act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value IS NOT NULL
  AND act.standard_value::TEXT ~ '^[0-9.]+$' -- Ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë
LIMIT 100;
```</p>
<p><strong>Code Python:</strong></p>
<p>```python
import os
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n</h1>
<p>base_path = os.getcwd()  # ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n
data_path = os.path.join(base_path, 'data')
notebook_path = os.path.join(base_path, 'notebooks')</p>
<h1>ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV</h1>
<p>data = pd.read_csv(os.path.join(data_path, 'chembl_data.csv'))</p>
<h1>H√†m t√≠nh to√°n ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠</h1>
<p>def calculate_descriptors(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    descriptors['MolLogP'] = Descriptors.MolLogP(mol)
    descriptors['MolWt'] = Descriptors.MolWt(mol)
    descriptors['NumHAcceptors'] = Descriptors.NumHAcceptors(mol)
    descriptors['NumHDonors'] = Descriptors.NumHDonors(mol)
    return descriptors</p>
<h1>√Åp d·ª•ng h√†m t√≠nh to√°n ƒë·∫∑c tr∆∞ng</h1>
<p>data['descriptors'] = data['canonical_smiles'].apply(calculate_descriptors)
data = data.dropna(subset=['descriptors'])</p>
<h1>Chuy·ªÉn ƒë·ªïi ƒë·∫∑c tr∆∞ng th√†nh DataFrame</h1>
<p>descriptors_df = pd.DataFrame(data['descriptors'].tolist())
data = pd.concat([data, descriptors_df], axis=1)</p>
<h1>Chu·∫©n b·ªã d·ªØ li·ªáu cho m√¥ h√¨nh</h1>
<p>X = data[['MolLogP', 'MolWt', 'NumHAcceptors', 'NumHDonors']]
y = data['standard_value']</p>
<h1>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>X√¢y d·ª±ng m√¥ h√¨nh Random Forest</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>D·ª± ƒëo√°n v√† ƒë√°nh gi√° m√¥ h√¨nh</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f'Mean Squared Error: {mse}')
print(f'R2 Score: {r2}')
```</p>
<p><strong>Gi·∫£i th√≠ch code:</strong></p>
<ol>
<li><strong>Import th∆∞ vi·ªán:</strong> Nh·∫≠p c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt nh∆∞ <code>os</code>, <code>pandas</code>, <code>rdkit</code>, v√† <code>sklearn</code>.</li>
<li><strong>C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n:</strong> X√°c ƒë·ªãnh ƒë∆∞·ªùng d·∫´n ƒë·∫øn c√°c th∆∞ m·ª•c ch·ª©a d·ªØ li·ªáu v√† notebook.</li>
<li><strong>ƒê·ªçc d·ªØ li·ªáu:</strong> ƒê·ªçc d·ªØ li·ªáu t·ª´ file CSV v√†o DataFrame.</li>
<li><strong>T√≠nh to√°n ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠:</strong><ul>
<li>ƒê·ªãnh nghƒ©a h√†m <code>calculate_descriptors</code> ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ t·ª´ SMILES.</li>
<li>√Åp d·ª•ng h√†m n√†y cho c·ªôt <code>canonical_smiles</code> trong DataFrame.</li>
</ul>
</li>
<li><strong>Chu·∫©n b·ªã d·ªØ li·ªáu:</strong><ul>
<li>Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ l√†m bi·∫øn ƒë·ªôc l·∫≠p (X) v√† gi√° tr·ªã ho·∫°t t√≠nh (IC50) l√†m bi·∫øn ph·ª• thu·ªôc (y).</li>
<li>Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.</li>
</ul>
</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh:</strong><ul>
<li>Kh·ªüi t·∫°o m√¥ h√¨nh Random Forest.</li>
<li>Hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p hu·∫•n luy·ªán.</li>
</ul>
</li>
<li><strong>ƒê√°nh gi√° m√¥ h√¨nh:</strong><ul>
<li>D·ª± ƒëo√°n gi√° tr·ªã ho·∫°t t√≠nh tr√™n t·∫≠p ki·ªÉm tra.</li>
<li>T√≠nh to√°n Mean Squared Error (MSE) v√† R2 Score ƒë·ªÉ ƒë√°nh gi√° hi·ªáu nƒÉng c·ªßa m√¥ h√¨nh.</li>
</ul>
</li>
</ol>
<p><strong>V√≠ d·ª• code b·ªï sung:</strong></p>
<p><strong>V√≠ d·ª• 1: L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh:</strong></p>
<p><code>sql
-- L·∫•y c√°c h·ª£p ch·∫•t c√≥ IC50 t·ª´ 100 nM ƒë·∫øn 1000 nM
SELECT DISTINCT mol.molregno,
                md.chembl_id,
                act.standard_value,
                act.standard_units
FROM molecule_dictionary mol
    JOIN activities act ON mol.molregno = act.molregno
    JOIN assay_xref ax ON act.assay_id = ax.assay_id
    JOIN target_dictionary td ON ax.tid = td.tid
WHERE td.chembl_id = 'CHEMBL205'
  AND act.standard_type = 'IC50'
  AND act.standard_relation = '='
  AND act.standard_value BETWEEN 100 AND 1000
  AND act.standard_units = 'nM'
LIMIT 100;</code></p>
<p>```python</p>
<h1>L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh</h1>
<p>data_filtered = data[(data['standard_value'] &gt;= 100) &amp; (data['standard_value'] &lt;= 1000)]
```</p>
<p><strong>V√≠ d·ª• 2: T√≠nh to√°n TPSA b·∫±ng RDKit:</strong></p>
<p>```python
from rdkit.Chem import rdMolDescriptors</p>
<p>def calculate_tpsa(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    tpsa = rdMolDescriptors.CalcTPSA(mol)
    return tpsa</p>
<p>data['tpsa'] = data['canonical_smiles'].apply(calculate_tpsa)
```</p>
<p><strong>V√≠ d·ª• 3: S·ª≠ d·ª•ng Support Vector Machine (SVM) cho m√¥ h√¨nh h√≥a:</strong></p>
<p>```python
from sklearn.svm import SVR</p>
<h1>Kh·ªüi t·∫°o m√¥ h√¨nh SVM</h1>
<p>model = SVR(kernel='rbf')
model.fit(X_train, y_train)</p>
<h1>D·ª± ƒëo√°n v√† ƒë√°nh gi√° m√¥ h√¨nh</h1>
<p>y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)</p>
<p>print(f'Mean Squared Error: {mse}')
print(f'R2 Score: {r2}')
```</p>
<p><strong>V√≠ d·ª• 4: L∆∞u tr·ªØ k·∫øt qu·∫£ v√†o file CSV:</strong></p>
<p><code>python
results = pd.DataFrame({'actual': y_test, 'predicted': y_pred})
results.to_csv(os.path.join(data_path, 'predictions.csv'), index=False)</code></p>
<p><strong>V√≠ d·ª• 5: S·ª≠ d·ª•ng PCA ƒë·ªÉ gi·∫£m chi·ªÅu d·ªØ li·ªáu:</strong></p>
<p>```python
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler</p>
<h1>Chu·∫©n h√≥a d·ªØ li·ªáu</h1>
<p>scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)</p>
<h1>Gi·∫£m chi·ªÅu d·ªØ li·ªáu xu·ªëng 2 chi·ªÅu</h1>
<p>pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)</p>
<h1>T·∫°o DataFrame t·ª´ d·ªØ li·ªáu PCA</h1>
<p>X_pca_df = pd.DataFrame(data=X_pca, columns=['PC1', 'PC2'])
```</p>
<p><strong>L∆∞u √Ω v·ªÅ l·ªói:</strong></p>
<ul>
<li><strong>L·ªói SQL:</strong> L·ªói <code>operator does not exist: numeric ~ unknown</code> x·∫£y ra do b·∫°n ƒëang c·ªë g·∫Øng so s√°nh m·ªôt gi√° tr·ªã s·ªë (<code>act.standard_value</code>) v·ªõi m·ªôt chu·ªói (<code>'^[0-9\.]+$'</code>). ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c·∫ßn ƒë·∫£m b·∫£o r·∫±ng c·∫£ hai v·∫ø c·ªßa ph√©p so s√°nh ƒë·ªÅu c√≥ c√πng ki·ªÉu d·ªØ li·ªáu. Trong tr∆∞·ªùng h·ª£p n√†y, b·∫°n c√≥ th·ªÉ chuy·ªÉn ƒë·ªïi <code>act.standard_value</code> sang ki·ªÉu chu·ªói b·∫±ng c√°ch s·ª≠ d·ª•ng <code>act.standard_value::TEXT</code>.</li>
<li><strong>L·ªói scikit-learn:</strong> N·∫øu b·∫°n g·∫∑p l·ªói <code>squared=False</code> kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, h√£y n√¢ng c·∫•p phi√™n b·∫£n scikit-learn c·ªßa b·∫°n l√™n phi√™n b·∫£n m·ªõi nh·∫•t.</li>
</ul>
<p><strong>K·∫øt lu·∫≠n:</strong></p>
<p>Hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n b·∫Øt ƒë·∫ßu d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 m·ªôt c√°ch hi·ªáu qu·∫£. H√£y nh·ªõ r·∫±ng, vi·ªác th·ª≠ nghi·ªám v√† ƒëi·ªÅu ch·ªânh m√¥ h√¨nh l√† r·∫•t quan tr·ªçng ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c k·∫øt qu·∫£ t·ªët nh·∫•t. Ch√∫c b·∫°n th√†nh c√¥ng!</p>
        </body>
        </html>
        