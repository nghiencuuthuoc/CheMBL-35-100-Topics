
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Topic_CheMBL_35_21</title>
            <style>
                body {
                    font-family: "Georgia", serif;
                    max-width: 800px;
                    margin: 40px auto;
                    padding: 20px;
                    line-height: 1.6;
                    background-color: #ffffff;
                    color: #333;
                }
                h1, h2, h3 {
                    color: #1a1a1a;
                }
                code {
                    background-color: #f5f5f5;
                    padding: 2px 4px;
                    border-radius: 4px;
                }
                pre {
                    background-color: #f5f5f5;
                    padding: 10px;
                    overflow-x: auto;
                    border-radius: 6px;
                }
            </style>
        </head>
        <body>
        <h1>PharmApp Suite</h1>
<h2>üß† AI for Drug Discovery and Development üß™</h2>
<p>| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.comlus | Zalo: +84888999311 |</p>
<h1>üß© Topic: 50 protein m·ª•c ti√™u c√≥ nhi·ªÅu ho·∫°t t√≠nh nh·∫•t</h1>
<hr />
<p>Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&amp;D d∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n h∆∞·ªõng d·∫´n chi ti·∫øt, m√£ SQL v√† Python m·∫´u, c√πng v·ªõi c√°c gi·∫£i th√≠ch ƒë·ªÉ b·∫°n c√≥ th·ªÉ th·ª±c hi·ªán d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.</p>
<p><strong>T·ªïng quan d·ª± √°n</strong></p>
<p>M·ª•c ti√™u c·ªßa d·ª± √°n n√†y l√† khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, k·∫øt h·ª£p v·ªõi c√°c c√¥ng c·ª• tin h·ªçc h√≥a h·ªçc (chemoinformatics) nh∆∞ RDKit, ƒë·ªÉ h·ªó tr·ª£ qu√° tr√¨nh nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. C·ª• th·ªÉ, ch√∫ng ta s·∫Ω t·∫≠p trung v√†o vi·ªác:</p>
<ol>
<li><strong>Tr√≠ch xu·∫•t d·ªØ li·ªáu:</strong> S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n v√† tr√≠ch xu·∫•t th√¥ng tin li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.</li>
<li><strong>X·ª≠ l√Ω v√† l√†m s·∫°ch d·ªØ li·ªáu:</strong> S·ª≠ d·ª•ng Python v√† RDKit ƒë·ªÉ x·ª≠ l√Ω, l√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu, bao g·ªìm c·∫£ vi·ªác chuy·ªÉn ƒë·ªïi SMILES th√†nh fingerprint ph√¢n t·ª≠.</li>
<li><strong>Ph√¢n t√≠ch d·ªØ li·ªáu:</strong> √Åp d·ª•ng c√°c k·ªπ thu·∫≠t ph√¢n t√≠ch d·ªØ li·ªáu v√† h·ªçc m√°y ƒë·ªÉ kh√°m ph√° c√°c m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c ph√¢n t·ª≠ v√† ho·∫°t t√≠nh sinh h·ªçc.</li>
<li><strong>X√¢y d·ª±ng m√¥ h√¨nh:</strong> X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc d·ª±a tr√™n c·∫•u tr√∫c ph√¢n t·ª≠.</li>
</ol>
<p><strong>1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch</strong></p>
<p>M√¥ h√¨nh ph√¢n t√≠ch c·ªßa ch√∫ng ta s·∫Ω tu√¢n theo quy tr√¨nh sau:</p>
<ol>
<li><strong>Data Extraction (Tr√≠ch xu·∫•t d·ªØ li·ªáu):</strong><ul>
<li><strong>SQL Queries:</strong> S·ª≠ d·ª•ng c√°c truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35. D·ªØ li·ªáu n√†y c√≥ th·ªÉ bao g·ªìm th√¥ng tin v·ªÅ c√°c h·ª£p ch·∫•t, ho·∫°t t√≠nh sinh h·ªçc, m·ª•c ti√™u, v.v.</li>
<li><strong>Data Export:</strong> L∆∞u d·ªØ li·ªáu tr√≠ch xu·∫•t v√†o c√°c file CSV ƒë·ªÉ s·ª≠ d·ª•ng trong c√°c b∆∞·ªõc ti·∫øp theo.</li>
</ul>
</li>
<li><strong>Data Preprocessing (Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu):</strong><ul>
<li><strong>Data Cleaning:</strong> Lo·∫°i b·ªè c√°c gi√° tr·ªã thi·∫øu, x·ª≠ l√Ω c√°c gi√° tr·ªã ngo·∫°i l·ªá v√† chu·∫©n h√≥a d·ªØ li·ªáu.</li>
<li><strong>Feature Engineering:</strong> S·ª≠ d·ª•ng RDKit ƒë·ªÉ t·∫°o ra c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ (molecular features) t·ª´ c·∫•u tr√∫c SMILES, nh∆∞ fingerprints, descriptors, v.v.</li>
</ul>
</li>
<li><strong>Data Analysis and Modeling (Ph√¢n t√≠ch d·ªØ li·ªáu v√† x√¢y d·ª±ng m√¥ h√¨nh):</strong><ul>
<li><strong>Exploratory Data Analysis (EDA):</strong> Th·ª±c hi·ªán ph√¢n t√≠ch kh√°m ph√° d·ªØ li·ªáu ƒë·ªÉ hi·ªÉu r√µ h∆°n v·ªÅ d·ªØ li·ªáu, t√¨m ki·∫øm c√°c m·ªëi quan h·ªá v√† xu h∆∞·ªõng.</li>
<li><strong>Model Building:</strong> X√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc d·ª±a tr√™n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠. C√°c m√¥ h√¨nh c√≥ th·ªÉ bao g·ªìm:<ul>
<li>Linear Regression</li>
<li>Random Forest</li>
<li>Support Vector Machines (SVM)</li>
<li>Neural Networks</li>
</ul>
</li>
<li><strong>Model Evaluation:</strong> ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa c√°c m√¥ h√¨nh b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c metrics ph√π h·ª£p, nh∆∞ RMSE, R-squared, AUC, v.v.</li>
</ul>
</li>
</ol>
<p><strong>2. H∆∞·ªõng d·∫´n song ng·ªØ</strong></p>
<p><strong>2.1. SQL (Structured Query Language)</strong></p>
<ul>
<li><strong>Purpose:</strong> To extract data from the ChEMBL 35 database.</li>
<li><strong>M·ª•c ƒë√≠ch:</strong> Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.</li>
</ul>
<p><strong>Example:</strong></p>
<p><code>sql
-- English: Select compound structures and bioactivity data for a specific target.
-- Ti·∫øng Vi·ªát: Ch·ªçn c·∫•u tr√∫c h·ª£p ch·∫•t v√† d·ªØ li·ªáu ho·∫°t t√≠nh sinh h·ªçc cho m·ªôt m·ª•c ti√™u c·ª• th·ªÉ.
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.pref_name = 'Acetylcholinesterase'
    AND act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value &gt; 0
    AND act.standard_units = 'nM'
LIMIT 100;</code></p>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>SELECT</code>: Specifies the columns to retrieve.</li>
<li><code>FROM</code>: Specifies the tables to retrieve data from.</li>
<li><code>JOIN</code>: Combines rows from different tables based on a related column.</li>
<li><code>WHERE</code>: Filters the rows based on specified conditions.</li>
<li><code>LIMIT</code>: gi·ªõi h·∫°n s·ªë d√≤ng tr·∫£ v·ªÅ</li>
<li><code>md.molregno</code>: Molecular Registry Number (S·ªë ƒëƒÉng k√Ω ph√¢n t·ª≠)</li>
<li><code>cs.canonical_smiles</code>: SMILES string ƒë·∫°i di·ªán cho c·∫•u tr√∫c ph√¢n t·ª≠</li>
<li><code>act.standard_type</code>: Lo·∫°i ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: IC50, Ki)</li>
<li><code>act.standard_value</code>: Gi√° tr·ªã ho·∫°t t√≠nh sinh h·ªçc</li>
<li><code>act.standard_units</code>: ƒê∆°n v·ªã c·ªßa gi√° tr·ªã ho·∫°t t√≠nh sinh h·ªçc</li>
<li><code>td.pref_name</code>: T√™n m·ª•c ti√™u (v√≠ d·ª•: Acetylcholinesterase)</li>
</ul>
<p><strong>2.2. Python</strong></p>
<ul>
<li><strong>Purpose:</strong> To process data, generate molecular features, and build predictive models.</li>
<li><strong>M·ª•c ƒë√≠ch:</strong> X·ª≠ l√Ω d·ªØ li·ªáu, t·∫°o ra c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ v√† x√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n.</li>
</ul>
<p><strong>Example:</strong></p>
<p>```python</p>
<h1>English: Import libraries and load data.</h1>
<h1>Ti·∫øng Vi·ªát: Nh·∫≠p c√°c th∆∞ vi·ªán v√† t·∫£i d·ªØ li·ªáu.</h1>
<p>import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import os</p>
<h1>Define base path</h1>
<p>base_path = ".." # Assuming the notebook is one level deep</p>
<h1>Load data</h1>
<p>data_path = os.path.join(base_path, "data", "acetylcholinesterase_ic50_100.csv") # Replace with your CSV file
df = pd.read_csv(data_path)</p>
<h1>English: Convert SMILES to molecular fingerprints.</h1>
<h1>Ti·∫øng Vi·ªát: Chuy·ªÉn ƒë·ªïi SMILES th√†nh fingerprint ph√¢n t·ª≠.</h1>
<p>def generate_fingerprint(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
        return np.array(fp)
    else:
        return None</p>
<p>df['fingerprint'] = df['canonical_smiles'].apply(generate_fingerprint)
df = df.loc[(df['fingerprint'].notnull())]</p>
<h1>English: Prepare data for modeling.</h1>
<h1>Ti·∫øng Vi·ªát: Chu·∫©n b·ªã d·ªØ li·ªáu cho vi·ªác x√¢y d·ª±ng m√¥ h√¨nh.</h1>
<p>X = np.array(list(df['fingerprint']))
y = df['standard_value'].astype(float)  # Convert to float</p>
<h1>English: Split data into training and test sets.</h1>
<h1>Ti·∫øng Vi·ªát: Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>English: Train a Random Forest model.</h1>
<h1>Ti·∫øng Vi·ªát: Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest.</h1>
<p>model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)</p>
<h1>English: Make predictions and evaluate the model.</h1>
<h1>Ti·∫øng Vi·ªát: D·ª± ƒëo√°n v√† ƒë√°nh gi√° m√¥ h√¨nh.</h1>
<p>y_pred = model.predict(X_test)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"RMSE: {rmse}")
print(f"R^2: {r2}")
```</p>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>pandas</code>: For data manipulation and analysis.</li>
<li><code>rdkit</code>: For chemoinformatics tasks, such as converting SMILES to molecular fingerprints.</li>
<li><code>scikit-learn</code>: For building and evaluating machine learning models.</li>
<li><code>train_test_split</code>: Splits the data into training and testing sets.</li>
<li><code>RandomForestRegressor</code>: A machine learning model for regression tasks.</li>
<li><code>mean_squared_error</code>: Calculates the mean squared error between the predicted and actual values.</li>
<li><code>r2_score</code>: Calculates the R-squared value, which represents the proportion of variance in the dependent variable that is predictable from the independent variables.</li>
<li>The function <code>generate_fingerprint</code> converts SMILES strings to molecular fingerprints using RDKit.</li>
<li>The code trains a Random Forest model on the training data and evaluates its performance on the test data.</li>
</ul>
<p><strong>3. V√≠ d·ª• code SQL v√† Python m·∫´u</strong></p>
<p>D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:</p>
<p><strong>V√≠ d·ª• 1: L·ªçc c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh IC50 v·ªõi m·ªôt protein m·ª•c ti√™u c·ª• th·ªÉ (SQL)</strong></p>
<p><code>sql
-- English: Select compounds with IC50 values for a specific target protein.
-- Ti·∫øng Vi·ªát: Ch·ªçn c√°c h·ª£p ch·∫•t c√≥ gi√° tr·ªã IC50 cho m·ªôt protein m·ª•c ti√™u c·ª• th·ªÉ.
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_value
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
JOIN
    target_dictionary td ON act.tid = td.tid
WHERE
    td.pref_name = 'HIV-1 reverse transcriptase'
    AND act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_units = 'nM'
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 1: T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ c∆° b·∫£n (Python)</strong></p>
<p>```python</p>
<h1>English: Calculate basic molecular properties using RDKit.</h1>
<h1>Ti·∫øng Vi·ªát: T√≠nh to√°n c√°c thu·ªôc t√≠nh ph√¢n t·ª≠ c∆° b·∫£n b·∫±ng RDKit.</h1>
<p>from rdkit import Chem
from rdkit.Chem import Descriptors</p>
<p>def calculate_molecular_properties(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        mw = Descriptors.MolWt(mol)
        logp = Descriptors.MolLogP(mol)
        hbd = Descriptors.NumHDonors(mol)
        hba = Descriptors.NumHAcceptors(mol)
        return mw, logp, hbd, hba
    else:
        return None, None, None, None</p>
<p>df[['mol_weight', 'logp', 'hbd', 'hba']] = df['canonical_smiles'].apply(lambda x: pd.Series(calculate_molecular_properties(x)))
```</p>
<p><strong>V√≠ d·ª• 2: L·ªçc c√°c h·ª£p ch·∫•t d·ª±a tr√™n kho·∫£ng gi√° tr·ªã ho·∫°t t√≠nh (SQL)</strong></p>
<p><code>sql
-- English: Select compounds with activity values within a specific range.
-- Ti·∫øng Vi·ªát: Ch·ªçn c√°c h·ª£p ch·∫•t c√≥ gi√° tr·ªã ho·∫°t t√≠nh trong m·ªôt kho·∫£ng c·ª• th·ªÉ.
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_value
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value BETWEEN 100 AND 1000
    AND act.standard_units = 'nM'
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 2: X√¢y d·ª±ng m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh (Python)</strong></p>
<p>```python</p>
<h1>English: Build a linear regression model.</h1>
<h1>Ti·∫øng Vi·ªát: X√¢y d·ª±ng m√¥ h√¨nh h·ªìi quy tuy·∫øn t√≠nh.</h1>
<p>from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score</p>
<h1>Assuming X and y are already defined</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<p>model = LinearRegression()
model.fit(X_train, y_train)</p>
<p>y_pred = model.predict(X_test)</p>
<p>rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"RMSE: {rmse}")
print(f"R^2: {r2}")
```</p>
<p><strong>V√≠ d·ª• 3: Truy v·∫•n d·ªØ li·ªáu m·ª•c ti√™u v√† th√†nh ph·∫ßn (SQL)</strong></p>
<p><code>sql
-- English: Retrieve target and component information.
-- Ti·∫øng Vi·ªát: Truy xu·∫•t th√¥ng tin m·ª•c ti√™u v√† th√†nh ph·∫ßn.
SELECT
    td.tid,
    td.pref_name,
    cmp.component_id,
    cmp.component_type
FROM
    target_dictionary td
JOIN
    target_components tc ON td.tid = tc.tid
JOIN
    component_sequences cmp ON tc.component_id = cmp.component_id
WHERE
    td.target_type = 'SINGLE PROTEIN'
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 3: S·ª≠ d·ª•ng PCA ƒë·ªÉ gi·∫£m s·ªë chi·ªÅu d·ªØ li·ªáu (Python)</strong></p>
<p>```python</p>
<h1>English: Use PCA for dimensionality reduction.</h1>
<h1>Ti·∫øng Vi·ªát: S·ª≠ d·ª•ng PCA ƒë·ªÉ gi·∫£m s·ªë chi·ªÅu d·ªØ li·ªáu.</h1>
<p>from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler</p>
<h1>Assuming X is already defined</h1>
<p>scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)</p>
<p>pca = PCA(n_components=100)  # Reduce to 100 components
X_pca = pca.fit_transform(X_scaled)</p>
<p>print(f"Original shape: {X.shape}")
print(f"PCA shape: {X_pca.shape}")
```</p>
<p><strong>V√≠ d·ª• 4: Truy v·∫•n c√°c ho·∫°t ch·∫•t d·ª±a tr√™n s·ªë l∆∞·ª£ng v√≤ng (SQL)</strong></p>
<p><code>sql
-- English: Retrieve active compounds based on the number of rings.
-- Ti·∫øng Vi·ªát: Truy xu·∫•t c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh d·ª±a tr√™n s·ªë l∆∞·ª£ng v√≤ng.
SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    md.num_rings &gt;= 3
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 4: Hu·∫•n luy·ªán m√¥ h√¨nh SVM (Python)</strong></p>
<p>```python</p>
<h1>English: Train a Support Vector Machine (SVM) model.</h1>
<h1>Ti·∫øng Vi·ªát: Hu·∫•n luy·ªán m√¥ h√¨nh Support Vector Machine (SVM).</h1>
<p>from sklearn.svm import SVR
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler</p>
<h1>Assuming X and y are already defined</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)</p>
<h1>Standardize the features</h1>
<p>scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)</p>
<p>model = SVR(kernel='rbf')  # You can also try 'linear', 'poly', 'sigmoid'
model.fit(X_train_scaled, y_train)</p>
<p>y_pred = model.predict(X_test_scaled)</p>
<p>rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)</p>
<p>print(f"RMSE: {rmse}")
print(f"R^2: {r2}")
```</p>
<p><strong>V√≠ d·ª• 5: T√¨m ki·∫øm c√°c h·ª£p ch·∫•t c√≥ khung ph√¢n t·ª≠ t∆∞∆°ng t·ª± (SQL)</strong></p>
<p><code>sql
-- English: Find compounds with similar molecular frameworks.
-- Ti·∫øng Vi·ªát: T√¨m c√°c h·ª£p ch·∫•t c√≥ khung ph√¢n t·ª≠ t∆∞∆°ng t·ª±.
SELECT
    md1.molregno,
    cs1.canonical_smiles,
    md2.molregno,
    cs2.canonical_smiles
FROM
    molecule_dictionary md1
JOIN
    compound_structures cs1 ON md1.molregno = cs1.molregno
JOIN
    molecule_dictionary md2 ON md1.molregno != md2.molregno  -- Avoid self-comparison
JOIN
    compound_structures cs2 ON md2.molregno = cs2.molregno
WHERE
    cs1.standard_inchi_key LIKE cs2.standard_inchi_key || '%'  -- Check for similar InChI keys
LIMIT 100;</code></p>
<p><strong>V√≠ d·ª• 5: S·ª≠ d·ª•ng T-SNE ƒë·ªÉ tr·ª±c quan h√≥a d·ªØ li·ªáu (Python)</strong></p>
<p>```python</p>
<h1>English: Use T-SNE for data visualization.</h1>
<h1>Ti·∫øng Vi·ªát: S·ª≠ d·ª•ng T-SNE ƒë·ªÉ tr·ª±c quan h√≥a d·ªØ li·ªáu.</h1>
<p>from sklearn.manifold import TSNE
import matplotlib.pyplot as plt</p>
<h1>Assuming X is already defined</h1>
<p>tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X)</p>
<p>plt.scatter(X_tsne[:, 0], X_tsne[:, 1])
plt.title('T-SNE Visualization')
plt.xlabel('Dimension 1')
plt.ylabel('Dimension 2')
plt.show()
```</p>
<p><strong>L∆∞u √Ω v·ªÅ c√°c l·ªói b·∫°n ƒë√£ ƒë·ªÅ c·∫≠p:</strong></p>
<ul>
<li>
<p><strong>L·ªói SQL "operator does not exist: numeric ~ unknown"</strong>: L·ªói n√†y x·∫£y ra khi b·∫°n c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ <code>~</code> (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c√≥ th·ªÉ √©p ki·ªÉu c·ªôt <code>act.standard_value</code> v·ªÅ ki·ªÉu text tr∆∞·ªõc khi so s√°nh, ho·∫∑c s·ª≠ d·ª•ng c√°c h√†m s·ªë h·ªçc ƒë·ªÉ l·ªçc d·ªØ li·ªáu.</p>
<p><code>sql
-- Example: √âp ki·ªÉu c·ªôt standard_value v·ªÅ text
AND CAST(act.standard_value AS TEXT) ~ '^[0-9\.]+$'</code></p>
</li>
<li>
<p><strong>L·ªói Python "squared=False"</strong>: N·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn c≈©, b·∫°n c√≥ th·ªÉ lo·∫°i b·ªè tham s·ªë <code>squared=False</code> kh·ªèi h√†m <code>mean_squared_error</code>. N·∫øu kh√¥ng, h√£y n√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t.</p>
</li>
</ul>
<p><strong>L∆∞u √Ω quan tr·ªçng:</strong></p>
<ul>
<li><strong>ƒê∆∞·ªùng d·∫´n:</strong> H√£y ƒë·∫£m b·∫£o r·∫±ng b·∫°n s·ª≠ d·ª•ng <code>os.path.join(base_path, ...)</code> ƒë·ªÉ x√¢y d·ª±ng ƒë∆∞·ªùng d·∫´n ƒë·∫øn c√°c file d·ªØ li·ªáu v√† c√°c file kh√°c trong d·ª± √°n.</li>
<li><strong>Gi·ªõi h·∫°n d·ªØ li·ªáu:</strong> ƒê·ªÉ tr√°nh t√¨nh tr·∫°ng qu√° t·∫£i m√°y t√≠nh, b·∫°n n√™n b·∫Øt ƒë·∫ßu v·ªõi m·ªôt t·∫≠p d·ªØ li·ªáu nh·ªè (v√≠ d·ª•: 100 d√≤ng) v√† tƒÉng d·∫ßn k√≠ch th∆∞·ªõc khi c·∫ßn thi·∫øt.</li>
<li><strong>M√¥ h√¨nh h√≥a:</strong> H√£y th·ª≠ nghi·ªám v·ªõi nhi·ªÅu m√¥ h√¨nh h·ªçc m√°y kh√°c nhau v√† ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa ch√∫ng b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c metrics ph√π h·ª£p.</li>
<li><strong>Gi·∫£i th√≠ch:</strong> H√£y gi·∫£i th√≠ch r√µ r√†ng c√°c b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch c·ªßa b·∫°n v√† k·∫øt qu·∫£ b·∫°n thu ƒë∆∞·ª£c.</li>
<li><strong>T√†i li·ªáu:</strong> H√£y tham kh·∫£o t√†i li·ªáu c·ªßa RDKit v√† scikit-learn ƒë·ªÉ bi·∫øt th√™m th√¥ng tin chi ti·∫øt v·ªÅ c√°c h√†m v√† l·ªõp b·∫°n ƒëang s·ª≠ d·ª•ng.</li>
</ul>
<p>Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.</p>
        </body>
        </html>
        