# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: D√≤ng th·ªùi gian v·ªÅ ng√†y ph√™ duy·ªát thu·ªëc
---
Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 b·∫±ng RDKit. V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia R&D d∆∞·ª£c h·ªçc, t√¥i hi·ªÉu r√µ t·∫ßm quan tr·ªçng c·ªßa vi·ªác khai th√°c d·ªØ li·ªáu l·ªõn ƒë·ªÉ ƒë·∫©y nhanh qu√° tr√¨nh ph√°t tri·ªÉn thu·ªëc. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt, h∆∞·ªõng d·∫´n song ng·ªØ, code m·∫´u SQL v√† Python ƒë·ªÉ b·∫°n tham kh·∫£o:

**1. Ph√¢n t√≠ch M√¥ h√¨nh Ph√¢n t√≠ch (Analysis of Analytical Model)**

D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, t√¥i h√¨nh dung quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu c·ªßa b·∫°n nh∆∞ sau:

*   **Giai ƒëo·∫°n 1: Tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ ChEMBL 35 (Data Extraction from ChEMBL 35)**

    *   S·ª≠ d·ª•ng PostgreSQL (psql) v√† pgAdmin ƒë·ªÉ truy v·∫•n c∆° s·ªü d·ªØ li·ªáu ChEMBL 35.
    *   Vi·∫øt c√°c c√¢u l·ªánh SQL ƒë·ªÉ l·ªçc, ch·ªçn v√† k·∫øt h·ª£p d·ªØ li·ªáu c·∫ßn thi·∫øt (v√≠ d·ª•: c·∫•u tr√∫c h√≥a h·ªçc, ho·∫°t t√≠nh sinh h·ªçc, th√¥ng tin v·ªÅ protein m·ª•c ti√™u).
    *   L∆∞u k·∫øt qu·∫£ truy v·∫•n v√†o c√°c file CSV (Comma Separated Values) ƒë·ªÉ d·ªÖ d√†ng x·ª≠ l√Ω b·∫±ng Python.
*   **Giai ƒëo·∫°n 2: Ti·ªÅn x·ª≠ l√Ω v√† Ph√¢n t√≠ch D·ªØ li·ªáu b·∫±ng RDKit v√† scikit-learn (Data Preprocessing and Analysis using RDKit and scikit-learn)**

    *   S·ª≠ d·ª•ng RDKit ƒë·ªÉ x·ª≠ l√Ω c·∫•u tr√∫c h√≥a h·ªçc (v√≠ d·ª•: t√≠nh to√°n descriptor ph√¢n t·ª≠, chuy·ªÉn ƒë·ªïi SMILES sang c√°c ƒë·ªãnh d·∫°ng kh√°c).
    *   S·ª≠ d·ª•ng scikit-learn ƒë·ªÉ x√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y (v√≠ d·ª•: d·ª± ƒëo√°n ho·∫°t t√≠nh, ph√¢n lo·∫°i h·ª£p ch·∫•t).
    *   S·ª≠ d·ª•ng Jupyter Notebook ƒë·ªÉ vi·∫øt v√† ch·∫°y code Python, tr·ª±c quan h√≥a k·∫øt qu·∫£.

**M√¥ h√¨nh ph√¢n t√≠ch chi ti·∫øt h∆°n:**

1.  **Data Acquisition:** Connect to the ChEMBL database using SQL queries to extract relevant information about compounds and their bioactivity. This includes compound structures (SMILES strings), activity values (IC50, Ki, etc.), and target information.
2.  **Data Cleaning and Preprocessing:** Handle missing data, convert activity values to a consistent unit (e.g., pIC50), and filter out irrelevant or unreliable data points. Address the error related to the `numeric ~ unknown` operator by ensuring consistent data types and proper casting.
3.  **Feature Engineering:** Use RDKit to generate molecular descriptors from SMILES strings. These descriptors represent various physicochemical properties of the molecules, such as molecular weight, LogP, hydrogen bond donors/acceptors, etc.
4.  **Model Building and Evaluation:** Train machine learning models (e.g., regression, classification) using the generated features and activity data. Evaluate the models using appropriate metrics (e.g., RMSE, R-squared for regression; accuracy, precision, recall for classification).  Address the `squared=False` error by updating scikit-learn or using `squared=True` if necessary.
5.  **Interpretation and Visualization:** Analyze the model results to identify important features that contribute to bioactivity. Visualize the data and model predictions to gain insights into structure-activity relationships (SAR).

**2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)**

**English:**

This guide provides step-by-step instructions for analyzing ChEMBL 35 data using RDKit and scikit-learn. It covers data extraction, preprocessing, feature engineering, model building, and evaluation. Code examples in both SQL and Python are provided.

**Ti·∫øng Vi·ªát:**

H∆∞·ªõng d·∫´n n√†y cung c·∫•p c√°c b∆∞·ªõc chi ti·∫øt ƒë·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 b·∫±ng RDKit v√† scikit-learn. N√≥ bao g·ªìm tr√≠ch xu·∫•t d·ªØ li·ªáu, ti·ªÅn x·ª≠ l√Ω, tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng, x√¢y d·ª±ng m√¥ h√¨nh v√† ƒë√°nh gi√°. C√°c v√≠ d·ª• m√£ b·∫±ng c·∫£ SQL v√† Python ƒë∆∞·ª£c cung c·∫•p.

**3. Code m·∫´u SQL v√† Python (SQL and Python Code Examples)**

**SQL (V√≠ d·ª• 1: L·∫•y th√¥ng tin c∆° b·∫£n v·ªÅ h·ª£p ch·∫•t v√† ho·∫°t t√≠nh)**

```sql
-- L·∫•y 100 h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh tr√™n m·ªôt m·ª•c ti√™u c·ª• th·ªÉ (v√≠ d·ª•: CHEMBL205 - Tyrosine-protein kinase)
-- Get 100 compounds with activity against a specific target (e.g., CHEMBL205 - Tyrosine-protein kinase)
SELECT
    cmp.chembl_id,
    act.standard_type,
    act.standard_value,
    act.standard_units,
    mol.molfile
FROM
    compound_structures cmp
JOIN
    activities act ON cmp.molregno = act.molregno
JOIN
    molecule_dictionary mol ON cmp.molregno = mol.molregno
WHERE
    act.target_chembl_id = 'CHEMBL205'
    AND act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_units = 'nM'
LIMIT 100;
```

**SQL (V√≠ d·ª• 2: L·ªçc c√°c gi√° tr·ªã ho·∫°t t√≠nh s·ªë)**

```sql
-- L·ªçc c√°c ho·∫°t ƒë·ªông ch·ªâ v·ªõi c√°c gi√° tr·ªã s·ªë
-- Filter activities with only numeric values
SELECT
    act.molregno,
    act.standard_value
FROM
    activities act
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value ~ '^[0-9\.]+$' -- S·ª≠a l·ªói: ƒê·∫£m b·∫£o gi√° tr·ªã l√† s·ªë
LIMIT 100;
```

**Kh·∫Øc ph·ª•c l·ªói "operator does not exist: numeric ~ unknown"**: L·ªói n√†y x·∫£y ra do b·∫°n ƒëang c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ `~` (regular expression match) tr√™n m·ªôt c·ªôt ki·ªÉu `numeric`. ƒê·ªÉ kh·∫Øc ph·ª•c, b·∫°n c·∫ßn ƒë·∫£m b·∫£o c·ªôt `act.standard_value` ƒë∆∞·ª£c √©p ki·ªÉu v·ªÅ `text` tr∆∞·ªõc khi so s√°nh v·ªõi regular expression. Tuy nhi√™n, c√°ch t·ªët nh·∫•t l√† ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë b·∫±ng c√°c h√†m s·ªë h·ªçc c·ªßa SQL.

**SQL (V√≠ d·ª• 3: S·ª≠a l·ªói "operator does not exist")**

```sql
-- L·ªçc c√°c ho·∫°t ƒë·ªông ch·ªâ v·ªõi c√°c gi√° tr·ªã s·ªë (s·ª≠a l·ªói)
-- Filter activities with only numeric values (error fixed)
SELECT
    act.molregno,
    act.standard_value
FROM
    activities act
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value::text ~ '^[0-9\.]+$'  -- √âp ki·ªÉu v·ªÅ text tr∆∞·ªõc khi so s√°nh
LIMIT 100;
```

Ho·∫∑c, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng m·ªôt c√°ch ti·∫øp c·∫≠n kh√°c ƒë·ªÉ ki·ªÉm tra xem gi√° tr·ªã c√≥ ph·∫£i l√† s·ªë m√† kh√¥ng c·∫ßn s·ª≠ d·ª•ng regular expression:

```sql
-- L·ªçc c√°c ho·∫°t ƒë·ªông ch·ªâ v·ªõi c√°c gi√° tr·ªã s·ªë (c√°ch kh√°c)
-- Filter activities with only numeric values (alternative approach)
SELECT
    act.molregno,
    act.standard_value
FROM
    activities act
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value > 0  -- ƒê·∫£m b·∫£o gi√° tr·ªã l·ªõn h∆°n 0 (gi·∫£ ƒë·ªãnh IC50 lu√¥n d∆∞∆°ng)
LIMIT 100;
```

**Python (V√≠ d·ª• 1: ƒê·ªçc d·ªØ li·ªáu CSV v√† t√≠nh to√°n descriptor)**

```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import os

# ƒê∆∞·ªùng d·∫´n c∆° s·ªü c·ªßa d·ª± √°n (thay ƒë·ªïi n·∫øu c·∫ßn)
# Base path of the project (change if needed)
base_path = "../data"  # Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu c·∫ßn / Change the path if needed

# ƒê·ªçc file CSV (v√≠ d·ª•)
# Read CSV file (example)
csv_file = os.path.join(base_path, "chembl_data.csv")  # Thay ƒë·ªïi t√™n file n·∫øu c·∫ßn / Change the filename if needed
df = pd.read_csv(csv_file)

# H√†m t√≠nh to√°n Molecular Weight
# Function to calculate Molecular Weight
def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None

# √Åp d·ª•ng h√†m t√≠nh to√°n MW cho c·ªôt 'smiles' (gi·∫£ s·ª≠ c·ªôt n√†y ch·ª©a SMILES)
# Apply the MW calculation function to the 'smiles' column (assuming this column contains SMILES)
df['molecular_weight'] = df['smiles'].apply(calculate_mw)

print(df.head())
```

**Python (V√≠ d·ª• 2: X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh)**

```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import os

# ƒê∆∞·ªùng d·∫´n c∆° s·ªü c·ªßa d·ª± √°n (thay ƒë·ªïi n·∫øu c·∫ßn)
# Base path of the project (change if needed)
base_path = "../data"  # Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu c·∫ßn / Change the path if needed

# ƒê·ªçc file CSV (v√≠ d·ª•)
# Read CSV file (example)
csv_file = os.path.join(base_path, "chembl_data.csv")  # Thay ƒë·ªïi t√™n file n·∫øu c·∫ßn / Change the filename if needed
df = pd.read_csv(csv_file)

# Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (v√≠ d·ª•: chuy·ªÉn ƒë·ªïi IC50 sang pIC50)
# Data preprocessing (e.g., convert IC50 to pIC50)
df = df.dropna(subset=['standard_value']) # Lo·∫°i b·ªè c√°c h√†ng c√≥ gi√° tr·ªã 'standard_value' b·ªã thi·∫øu / Remove rows with missing 'standard_value'

# Define pIC50 transformation function
def pIC50(IC50_nM):
    pIC50 = -np.log10(IC50_nM*(10**-9))
    return pIC50

df['pIC50'] = df['standard_value'].apply(pIC50) # Apply pIC50 transformation function
df = df.replace([np.inf, -np.inf], np.nan) # Replace infinity values with NaN
df = df.dropna(subset=['pIC50']) # Drop rows with NaN values

# H√†m t√≠nh to√°n descriptor (v√≠ d·ª•: Molecular Weight)
# Function to calculate descriptors (e.g., Molecular Weight)
def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors.MolWt(mol)
    else:
        return None

df['molecular_weight'] = df['smiles'].apply(calculate_mw) # Calculate molecular weight
df = df.dropna(subset=['molecular_weight']) # Drop rows with missing MW

# Ch·ªçn features v√† target
# Select features and target
X = df[['molecular_weight']]  # V√≠ d·ª•: ch·ªâ s·ª≠ d·ª•ng MW l√†m feature / Example: use only MW as a feature
y = df['pIC50']

# Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra
# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# X√¢y d·ª±ng m√¥ h√¨nh Linear Regression
# Build Linear Regression model
model = LinearRegression()
model.fit(X_train, y_train)

# D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra
# Predict on the test set
y_pred = model.predict(X_test)

# ƒê√°nh gi√° m√¥ h√¨nh
# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```

**Kh·∫Øc ph·ª•c l·ªói "squared=False"**: N·∫øu b·∫°n g·∫∑p l·ªói n√†y, h√£y ƒë·∫£m b·∫£o r·∫±ng b·∫°n ƒëang s·ª≠ d·ª•ng phi√™n b·∫£n scikit-learn m·ªõi nh·∫•t. N·∫øu kh√¥ng th·ªÉ n√¢ng c·∫•p, b·∫°n c√≥ th·ªÉ b·ªè tham s·ªë `squared=False` (n√≥ ch·ªâ ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác tr·∫£ v·ªÅ MSE hay RMSE).

**4. Th√™m 3 v√≠ d·ª• code SQL v√† Python m·∫´u (3 More SQL and Python Code Examples)**

**SQL (V√≠ d·ª• 4: L·∫•y s·ªë l∆∞·ª£ng h·ª£p ch·∫•t cho m·ªói target)**

```sql
-- L·∫•y s·ªë l∆∞·ª£ng h·ª£p ch·∫•t c√≥ trong m·ªói m·ª•c ti√™u
-- Get the number of compounds for each target
SELECT
    act.target_chembl_id,
    COUNT(DISTINCT cmp.molregno) AS num_compounds
FROM
    activities act
JOIN
    compound_structures cmp ON act.molregno = cmp.molregno
GROUP BY
    act.target_chembl_id
ORDER BY
    num_compounds DESC
LIMIT 100;
```

**SQL (V√≠ d·ª• 5: T√¨m c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh tr√™n nhi·ªÅu m·ª•c ti√™u)**

```sql
-- T√¨m c√°c h·ª£p ch·∫•t c√≥ ho·∫°t t√≠nh tr√™n nhi·ªÅu m·ª•c ti√™u
-- Find compounds that are active against multiple targets
SELECT
    cmp.chembl_id,
    COUNT(DISTINCT act.target_chembl_id) AS num_targets
FROM
    compound_structures cmp
JOIN
    activities act ON cmp.molregno = act.molregno
GROUP BY
    cmp.chembl_id
HAVING
    COUNT(DISTINCT act.target_chembl_id) > 1
ORDER BY
    num_targets DESC
LIMIT 100;
```

**Python (V√≠ d·ª• 3: T√≠nh to√°n LogP b·∫±ng RDKit)**

```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from rdkit.Chem import Crippen
import os

# ƒê∆∞·ªùng d·∫´n c∆° s·ªü c·ªßa d·ª± √°n (thay ƒë·ªïi n·∫øu c·∫ßn)
# Base path of the project (change if needed)
base_path = "../data"  # Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu c·∫ßn / Change the path if needed

# ƒê·ªçc file CSV (v√≠ d·ª•)
# Read CSV file (example)
csv_file = os.path.join(base_path, "chembl_data.csv")  # Thay ƒë·ªïi t√™n file n·∫øu c·∫ßn / Change the filename if needed
df = pd.read_csv(csv_file)

# H√†m t√≠nh to√°n LogP
# Function to calculate LogP
def calculate_logp(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Crippen.MolLogP(mol)
    else:
        return None

# √Åp d·ª•ng h√†m t√≠nh to√°n LogP cho c·ªôt 'smiles'
# Apply the LogP calculation function to the 'smiles' column
df['logp'] = df['smiles'].apply(calculate_logp)

print(df.head())
```

**Python (V√≠ d·ª• 4: Tr·ª±c quan h√≥a k·∫øt qu·∫£ v·ªõi matplotlib)**

```python
import pandas as pd
import matplotlib.pyplot as plt
import os

# ƒê∆∞·ªùng d·∫´n c∆° s·ªü c·ªßa d·ª± √°n (thay ƒë·ªïi n·∫øu c·∫ßn)
# Base path of the project (change if needed)
base_path = "../data"  # Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu c·∫ßn / Change the path if needed

# ƒê·ªçc file CSV (v√≠ d·ª•)
# Read CSV file (example)
csv_file = os.path.join(base_path, "chembl_data.csv")  # Thay ƒë·ªïi t√™n file n·∫øu c·∫ßn / Change the filename if needed
df = pd.read_csv(csv_file)

# V·∫Ω bi·ªÉu ƒë·ªì scatter gi·ªØa Molecular Weight v√† pIC50 (v√≠ d·ª•)
# Create a scatter plot between Molecular Weight and pIC50 (example)
plt.scatter(df['molecular_weight'], df['pIC50'])
plt.xlabel('Molecular Weight')
plt.ylabel('pIC50')
plt.title('Molecular Weight vs pIC50')
plt.show()
```

**Python (V√≠ d·ª• 5: T√≠nh to√°n TPSA - Topological Polar Surface Area)**

```python
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors3D
import os

# ƒê∆∞·ªùng d·∫´n c∆° s·ªü c·ªßa d·ª± √°n (thay ƒë·ªïi n·∫øu c·∫ßn)
# Base path of the project (change if needed)
base_path = "../data"  # Thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n n·∫øu c·∫ßn / Change the path if needed

# ƒê·ªçc file CSV (v√≠ d·ª•)
# Read CSV file (example)
csv_file = os.path.join(base_path, "chembl_data.csv")  # Thay ƒë·ªïi t√™n file n·∫øu c·∫ßn / Change the filename if needed
df = pd.read_csv(csv_file)

# H√†m t√≠nh to√°n TPSA
# Function to calculate TPSA
def calculate_tpsa(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Descriptors3D.TPSA(mol)
    else:
        return None

# √Åp d·ª•ng h√†m t√≠nh to√°n TPSA cho c·ªôt 'smiles'
# Apply the TPSA calculation function to the 'smiles' column
df['tpsa'] = df['smiles'].apply(calculate_tpsa)

print(df.head())
```

**L∆∞u √Ω quan tr·ªçng:**

*   H√£y nh·ªõ thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n file v√† t√™n file CSV cho ph√π h·ª£p v·ªõi c·∫•u tr√∫c th∆∞ m·ª•c v√† d·ªØ li·ªáu c·ªßa b·∫°n.
*   C√°c v√≠ d·ª• tr√™n ch·ªâ l√† ƒëi·ªÉm kh·ªüi ƒë·∫ßu. B·∫°n c·∫ßn ƒëi·ªÅu ch·ªânh code cho ph√π h·ª£p v·ªõi m·ª•c ti√™u nghi√™n c·ª©u c·ª• th·ªÉ c·ªßa m√¨nh.
*   H√£y lu√¥n ki·ªÉm tra v√† l√†m s·∫°ch d·ªØ li·ªáu tr∆∞·ªõc khi ph√¢n t√≠ch ƒë·ªÉ ƒë·∫£m b·∫£o k·∫øt qu·∫£ ch√≠nh x√°c.
*   N·∫øu b·∫°n g·∫∑p b·∫•t k·ª≥ v·∫•n ƒë·ªÅ n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi!

Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh!