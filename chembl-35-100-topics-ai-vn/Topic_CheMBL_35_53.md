# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: Ph√¢n t·ª≠ kh√°ng virus t∆∞∆°ng ·ª©ng v·ªõi ƒë√≠ch COVID-19
---
Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. V·ªõi vai tr√≤ l√† chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p cho b·∫°n nh·ªØng ph√¢n t√≠ch, h∆∞·ªõng d·∫´n v√† m√£ ngu·ªìn m·∫´u ƒë·ªÉ b·∫°n c√≥ th·ªÉ ti·∫øn h√†nh d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.

**Ph√¢n t√≠ch t·ªïng quan**

D·ª± √°n c·ªßa b·∫°n t·∫≠p trung v√†o vi·ªác khai th√°c d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, m·ªôt ngu·ªìn t√†i nguy√™n v√¥ gi√° trong lƒ©nh v·ª±c ph√°t tri·ªÉn thu·ªëc. Vi·ªác k·∫øt h·ª£p ChEMBL v·ªõi RDKit, m·ªôt b·ªô c√¥ng c·ª• h√≥a tin h·ªçc m·∫°nh m·∫Ω, cho ph√©p b·∫°n th·ª±c hi·ªán c√°c ph√¢n t√≠ch s√¢u s·∫Øc v·ªÅ c·∫•u tr√∫c ph√¢n t·ª≠, t√≠nh ch·∫•t h√≥a l√Ω v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t.

**M·ª•c ti√™u c·ªßa d·ª± √°n:**

*   **Thu th·∫≠p d·ªØ li·ªáu:** L·∫•y d·ªØ li·ªáu li√™n quan t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 b·∫±ng c√°c truy v·∫•n SQL.
*   **Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu:** L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu, lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá v√† x·ª≠ l√Ω c√°c gi√° tr·ªã thi·∫øu.
*   **T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠:** S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠, m√¥ t·∫£ c√°c ƒë·∫∑c t√≠nh c·∫•u tr√∫c v√† h√≥a l√Ω c·ªßa c√°c h·ª£p ch·∫•t.
*   **Ph√¢n t√≠ch d·ªØ li·ªáu:** √Åp d·ª•ng c√°c k·ªπ thu·∫≠t th·ªëng k√™ v√† h·ªçc m√°y ƒë·ªÉ kh√°m ph√° c√°c m·ªëi quan h·ªá gi·ªØa c·∫•u tr√∫c ph√¢n t·ª≠, t√≠nh ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc.
*   **X√¢y d·ª±ng m√¥ h√¨nh:** X√¢y d·ª±ng c√°c m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c·∫•u tr√∫c c·ªßa ch√∫ng.
*   **Tr·ª±c quan h√≥a d·ªØ li·ªáu:** S·ª≠ d·ª•ng c√°c c√¥ng c·ª• tr·ª±c quan h√≥a ƒë·ªÉ tr√¨nh b√†y k·∫øt qu·∫£ ph√¢n t√≠ch m·ªôt c√°ch r√µ r√†ng v√† d·ªÖ hi·ªÉu.

**1. Ph√¢n t√≠ch v√† m√¥ h√¨nh ph√¢n t√≠ch**

Ch√∫ng ta s·∫Ω t·∫≠p trung v√†o vi·ªác x√¢y d·ª±ng m·ªôt quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t. D∆∞·ªõi ƒë√¢y l√† m√¥ h√¨nh ph√¢n t√≠ch chi ti·∫øt:

**B∆∞·ªõc 1: Thu th·∫≠p d·ªØ li·ªáu (Data Acquisition)**

*   **M·ª•c ti√™u:** L·∫•y d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35, bao g·ªìm th√¥ng tin v·ªÅ c·∫•u tr√∫c ph√¢n t·ª≠ (SMILES), ho·∫°t t√≠nh sinh h·ªçc (IC50, Ki, EC50, v.v.) v√† c√°c thu·ªôc t√≠nh li√™n quan kh√°c.
*   **C√¥ng c·ª•:** SQL, psycopg2 (Python library for PostgreSQL).
*   **ƒê·∫ßu ra:** M·ªôt t·∫≠p d·ªØ li·ªáu ch·ª©a th√¥ng tin v·ªÅ c√°c h·ª£p ch·∫•t v√† ho·∫°t t√≠nh sinh h·ªçc c·ªßa ch√∫ng.

**B∆∞·ªõc 2: Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing)**

*   **M·ª•c ti√™u:** L√†m s·∫°ch v√† chu·∫©n h√≥a d·ªØ li·ªáu ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng v√† t√≠nh nh·∫•t qu√°n.
*   **C√¥ng c·ª•:** Pandas (Python library for data manipulation), RDKit.
*   **C√°c b∆∞·ªõc:**
    *   Lo·∫°i b·ªè c√°c h·ª£p ch·∫•t tr√πng l·∫∑p.
    *   Chu·∫©n h√≥a chu·ªói SMILES.
    *   X·ª≠ l√Ω c√°c gi√° tr·ªã ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: chuy·ªÉn ƒë·ªïi IC50 sang pIC50).
    *   Lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá ho·∫∑c kh√¥ng h·ª£p l·ªá.

**B∆∞·ªõc 3: T√≠nh to√°n descriptor ph√¢n t·ª≠ (Molecular Descriptor Calculation)**

*   **M·ª•c ti√™u:** T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ t·ª´ c·∫•u tr√∫c c·ªßa c√°c h·ª£p ch·∫•t.
*   **C√¥ng c·ª•:** RDKit.
*   **C√°c descriptor:**
    *   C√°c descriptor 2D: Molecular Weight, LogP, Topological Polar Surface Area (TPSA).
    *   C√°c descriptor d·ª±a tr√™n fragments: Murcko Fragments.
    *   C√°c descriptor kh√°c: S·ªë l∆∞·ª£ng v√≤ng, s·ªë l∆∞·ª£ng nguy√™n t·ª≠, v.v.

**B∆∞·ªõc 4: Ph√¢n t√≠ch d·ªØ li·ªáu v√† x√¢y d·ª±ng m√¥ h√¨nh (Data Analysis and Model Building)**

*   **M·ª•c ti√™u:** X√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc c·ªßa c√°c h·ª£p ch·∫•t d·ª±a tr√™n c√°c descriptor ph√¢n t·ª≠.
*   **C√¥ng c·ª•:** Scikit-learn (Python library for machine learning).
*   **C√°c thu·∫≠t to√°n:**
    *   H·ªìi quy tuy·∫øn t√≠nh (Linear Regression).
    *   M√°y vector h·ªó tr·ª£ (Support Vector Machine - SVM).
    *   R·ª´ng ng·∫´u nhi√™n (Random Forest).
    *   M·∫°ng n∆°-ron (Neural Networks).
*   **ƒê√°nh gi√° m√¥ h√¨nh:** S·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t ƒë√°nh gi√° m√¥ h√¨nh ph√π h·ª£p (v√≠ d·ª•: cross-validation, R-squared, RMSE) ƒë·ªÉ ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa c√°c m√¥ h√¨nh.

**B∆∞·ªõc 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu (Data Visualization)**

*   **M·ª•c ti√™u:** Tr√¨nh b√†y k·∫øt qu·∫£ ph√¢n t√≠ch m·ªôt c√°ch r√µ r√†ng v√† d·ªÖ hi·ªÉu.
*   **C√¥ng c·ª•:** Matplotlib, Seaborn (Python libraries for data visualization).
*   **C√°c lo·∫°i bi·ªÉu ƒë·ªì:**
    *   Bi·ªÉu ƒë·ªì ph√¢n t√°n (Scatter plots) ƒë·ªÉ hi·ªÉn th·ªã m·ªëi quan h·ªá gi·ªØa c√°c descriptor v√† ho·∫°t t√≠nh sinh h·ªçc.
    *   Bi·ªÉu ƒë·ªì h·ªôp (Box plots) ƒë·ªÉ so s√°nh ph√¢n ph·ªëi c·ªßa c√°c descriptor gi·ªØa c√°c nh√≥m h·ª£p ch·∫•t kh√°c nhau.
    *   Bi·ªÉu ƒë·ªì quan tr·ªçng t√≠nh nƒÉng (Feature importance plots) ƒë·ªÉ x√°c ƒë·ªãnh c√°c descriptor quan tr·ªçng nh·∫•t trong m√¥ h√¨nh.

**2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Instructions)**

D∆∞·ªõi ƒë√¢y l√† h∆∞·ªõng d·∫´n chi ti·∫øt b·∫±ng c·∫£ ti·∫øng Anh v√† ti·∫øng Vi·ªát cho t·ª´ng b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch:

**B∆∞·ªõc 1: Thu th·∫≠p d·ªØ li·ªáu (Data Acquisition)**

*   **English:**
    1.  Connect to the ChEMBL 35 database using `psycopg2`.
    2.  Execute SQL queries to retrieve the necessary data (e.g., compound structures, activity data).
    3.  Save the data to a CSV file.
*   **Ti·∫øng Vi·ªát:**
    1.  K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 b·∫±ng `psycopg2`.
    2.  Th·ª±c thi c√°c truy v·∫•n SQL ƒë·ªÉ l·∫•y d·ªØ li·ªáu c·∫ßn thi·∫øt (v√≠ d·ª•: c·∫•u tr√∫c h·ª£p ch·∫•t, d·ªØ li·ªáu ho·∫°t t√≠nh).
    3.  L∆∞u d·ªØ li·ªáu v√†o m·ªôt file CSV.

**B∆∞·ªõc 2: Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (Data Preprocessing)**

*   **English:**
    1.  Load the CSV file into a Pandas DataFrame.
    2.  Remove duplicate compounds.
    3.  Standardize SMILES strings using RDKit.
    4.  Convert activity values (e.g., IC50) to pIC50.
    5.  Remove outliers or invalid values.
*   **Ti·∫øng Vi·ªát:**
    1.  T·∫£i file CSV v√†o m·ªôt Pandas DataFrame.
    2.  Lo·∫°i b·ªè c√°c h·ª£p ch·∫•t tr√πng l·∫∑p.
    3.  Chu·∫©n h√≥a chu·ªói SMILES b·∫±ng RDKit.
    4.  Chuy·ªÉn ƒë·ªïi gi√° tr·ªã ho·∫°t t√≠nh (v√≠ d·ª•: IC50) sang pIC50.
    5.  Lo·∫°i b·ªè c√°c gi√° tr·ªã ngo·∫°i l·ªá ho·∫∑c kh√¥ng h·ª£p l·ªá.

**B∆∞·ªõc 3: T√≠nh to√°n descriptor ph√¢n t·ª≠ (Molecular Descriptor Calculation)**

*   **English:**
    1.  Use RDKit to calculate molecular descriptors for each compound.
    2.  Calculate 2D descriptors (e.g., Molecular Weight, LogP, TPSA).
    3.  Calculate fragment-based descriptors (e.g., Murcko Fragments).
    4.  Add the descriptors to the Pandas DataFrame.
*   **Ti·∫øng Vi·ªát:**
    1.  S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ cho m·ªói h·ª£p ch·∫•t.
    2.  T√≠nh to√°n c√°c descriptor 2D (v√≠ d·ª•: Molecular Weight, LogP, TPSA).
    3.  T√≠nh to√°n c√°c descriptor d·ª±a tr√™n fragments (v√≠ d·ª•: Murcko Fragments).
    4.  Th√™m c√°c descriptor v√†o Pandas DataFrame.

**B∆∞·ªõc 4: Ph√¢n t√≠ch d·ªØ li·ªáu v√† x√¢y d·ª±ng m√¥ h√¨nh (Data Analysis and Model Building)**

*   **English:**
    1.  Split the data into training and testing sets.
    2.  Train a machine learning model (e.g., Linear Regression, SVM, Random Forest) using the training data.
    3.  Evaluate the model's performance on the testing data.
*   **Ti·∫øng Vi·ªát:**
    1.  Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.
    2.  Hu·∫•n luy·ªán m·ªôt m√¥ h√¨nh h·ªçc m√°y (v√≠ d·ª•: Linear Regression, SVM, Random Forest) s·ª≠ d·ª•ng d·ªØ li·ªáu hu·∫•n luy·ªán.
    3.  ƒê√°nh gi√° hi·ªáu su·∫•t c·ªßa m√¥ h√¨nh tr√™n d·ªØ li·ªáu ki·ªÉm tra.

**B∆∞·ªõc 5: Tr·ª±c quan h√≥a d·ªØ li·ªáu (Data Visualization)**

*   **English:**
    1.  Use Matplotlib and Seaborn to create visualizations of the data and model results.
    2.  Create scatter plots, box plots, and feature importance plots.
*   **Ti·∫øng Vi·ªát:**
    1.  S·ª≠ d·ª•ng Matplotlib v√† Seaborn ƒë·ªÉ t·∫°o c√°c h√¨nh ·∫£nh tr·ª±c quan v·ªÅ d·ªØ li·ªáu v√† k·∫øt qu·∫£ m√¥ h√¨nh.
    2.  T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n, bi·ªÉu ƒë·ªì h·ªôp v√† bi·ªÉu ƒë·ªì quan tr·ªçng t√≠nh nƒÉng.

**3. Code SQL v√† Python (SQL and Python Code)**

D∆∞·ªõi ƒë√¢y l√† c√°c v√≠ d·ª• v·ªÅ code SQL v√† Python ƒë·ªÉ th·ª±c hi·ªán c√°c b∆∞·ªõc trong quy tr√¨nh ph√¢n t√≠ch. T√¥i s·∫Ω t·∫≠p trung v√†o vi·ªác kh·∫Øc ph·ª•c c√°c l·ªói b·∫°n ƒë√£ ƒë·ªÅ c·∫≠p.

**a. SQL Code (Data Acquisition)**

```sql
-- English
-- Select 100 compounds with activity data
SELECT DISTINCT ON (molregno)
    md.molregno,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'  -- You can change this to other activity types
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value::text ~ '^[0-9\.]+$'  -- Corrected line
ORDER BY molregno
LIMIT 100;

-- Vietnamese
-- Ch·ªçn 100 h·ª£p ch·∫•t c√≥ d·ªØ li·ªáu ho·∫°t t√≠nh
SELECT DISTINCT ON (molregno)
    md.molregno,
    cs.canonical_smiles,
    act.standard_type,
    act.standard_value,
    act.standard_units
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'  -- B·∫°n c√≥ th·ªÉ thay ƒë·ªïi th√†nh lo·∫°i ho·∫°t t√≠nh kh√°c
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_value::text ~ '^[0-9\.]+$'  -- D√≤ng ƒë√£ s·ª≠a
ORDER BY molregno
LIMIT 100;
```

**Gi·∫£i th√≠ch l·ªói v√† c√°ch s·ª≠a:**

*   **L·ªói:** `ERROR: operator does not exist: numeric ~ unknown, LINE 12: AND act.standard_value ~ '^[0-9\.]+$'`
*   **Nguy√™n nh√¢n:** To√°n t·ª≠ `~` trong PostgreSQL ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ so s√°nh m·ªôt chu·ªói v·ªõi m·ªôt regular expression. Trong tr∆∞·ªùng h·ª£p n√†y, `act.standard_value` c√≥ ki·ªÉu d·ªØ li·ªáu l√† `numeric`, kh√¥ng ph·∫£i l√† `text`.
*   **C√°ch s·ª≠a:** √âp ki·ªÉu `act.standard_value` v·ªÅ `text` b·∫±ng c√°ch s·ª≠ d·ª•ng `act.standard_value::text`.

**b. Python Code (Data Preprocessing and Descriptor Calculation)**

```python
# English
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
import os

base_path = "../data"  # Adjust as needed

def calculate_descriptors(smiles):
    """Calculates molecular descriptors using RDKit."""
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    descriptors['Molecular Weight'] = Descriptors.MolWt(mol)
    descriptors['LogP'] = Chem.Crippen.MolLogP(mol)
    descriptors['TPSA'] = Chem.rdMolDescriptors.CalcTPSA(mol)
    return descriptors

# Load data
data = pd.read_csv(os.path.join(base_path, "chembl_data.csv"))  # Replace with your CSV file

# Handle missing SMILES
data = data.dropna(subset=['canonical_smiles'])

# Calculate descriptors
data['descriptors'] = data['canonical_smiles'].apply(calculate_descriptors)
data = data.dropna(subset=['descriptors'])
data = data[data['descriptors'].notna()]

# Convert descriptors to columns
data = pd.concat([data.drop(['descriptors'], axis=1), data['descriptors'].apply(pd.Series)], axis=1)

# Convert IC50 to pIC50
def ic50_to_pic50(ic50):
    """Converts IC50 to pIC50."""
    if pd.isna(ic50):
        return np.nan
    ic50 = float(ic50)
    if ic50 <= 0:
        return np.nan
    pIC50 = -np.log10(ic50 / 1e9)
    return pIC50

data['pIC50'] = data['standard_value'].apply(ic50_to_pic50)

# Display the first few rows
print(data.head())


# Vietnamese
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import numpy as np
import os

base_path = "../data"  # ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn

def tinh_toan_descriptor(smiles):
    """T√≠nh to√°n c√°c descriptor ph√¢n t·ª≠ s·ª≠ d·ª•ng RDKit."""
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return None
    descriptors = {}
    descriptors['Molecular Weight'] = Descriptors.MolWt(mol)
    descriptors['LogP'] = Chem.Crippen.MolLogP(mol)
    descriptors['TPSA'] = Chem.rdMolDescriptors.CalcTPSA(mol)
    return descriptors

# T·∫£i d·ªØ li·ªáu
data = pd.read_csv(os.path.join(base_path, "chembl_data.csv"))  # Thay th·∫ø b·∫±ng file CSV c·ªßa b·∫°n

# X·ª≠ l√Ω SMILES b·ªã thi·∫øu
data = data.dropna(subset=['canonical_smiles'])

# T√≠nh to√°n c√°c descriptor
data['descriptors'] = data['canonical_smiles'].apply(tinh_toan_descriptor)
data = data.dropna(subset=['descriptors'])
data = data[data['descriptors'].notna()]

# Chuy·ªÉn descriptor th√†nh c√°c c·ªôt
data = pd.concat([data.drop(['descriptors'], axis=1), data['descriptors'].apply(pd.Series)], axis=1)


# Chuy·ªÉn ƒë·ªïi IC50 sang pIC50
def ic50_sang_pic50(ic50):
    """Chuy·ªÉn ƒë·ªïi IC50 sang pIC50."""
    if pd.isna(ic50):
        return np.nan
    ic50 = float(ic50)
    if ic50 <= 0:
        return np.nan
    pIC50 = -np.log10(ic50 / 1e9)
    return pIC50

data['pIC50'] = data['standard_value'].apply(ic50_sang_pic50)

# Hi·ªÉn th·ªã m·ªôt v√†i d√≤ng ƒë·∫ßu ti√™n
print(data.head())
```

**c. Python Code (Model Building)**

```python
# English
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler

# Select features and target
features = ['Molecular Weight', 'LogP', 'TPSA']  # Add more features as needed
target = 'pIC50'

# Handle missing values
data = data.dropna(subset=features + [target])

# Scale features
scaler = StandardScaler()
X = scaler.fit_transform(data[features])
y = data[target]

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train model
model = LinearRegression()
model.fit(X_train, y_train)

# Evaluate model
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

# Vietnamese
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler

# Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng v√† m·ª•c ti√™u
features = ['Molecular Weight', 'LogP', 'TPSA']  # Th√™m c√°c ƒë·∫∑c tr∆∞ng kh√°c n·∫øu c·∫ßn
target = 'pIC50'

# X·ª≠ l√Ω c√°c gi√° tr·ªã b·ªã thi·∫øu
data = data.dropna(subset=features + [target])

# Chu·∫©n h√≥a c√°c ƒë·∫∑c tr∆∞ng
scaler = StandardScaler()
X = scaler.fit_transform(data[features])
y = data[target]

# Chia d·ªØ li·ªáu
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Hu·∫•n luy·ªán m√¥ h√¨nh
model = LinearRegression()
model.fit(X_train, y_train)

# ƒê√°nh gi√° m√¥ h√¨nh
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```

**Gi·∫£i th√≠ch l·ªói v√† c√°ch s·ª≠a:**

*   **L·ªói:** `ValueError: `squared` is deprecated and will be removed in scikit-learn 1.4. Use `squared=False` if you want to calculate the root mean squared error.
*   **Nguy√™n nh√¢n:** Phi√™n b·∫£n scikit-learn c·ªßa b·∫°n c≈© v√† kh√¥ng h·ªó tr·ª£ tham s·ªë `squared=False` trong h√†m `mean_squared_error`.
*   **C√°ch s·ª≠a:** N√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t b·∫±ng l·ªánh `pip install -U scikit-learn`. N·∫øu kh√¥ng th·ªÉ n√¢ng c·∫•p, b·∫°n c√≥ th·ªÉ t√≠nh RMSE b·∫±ng c√°ch l·∫•y cƒÉn b·∫≠c hai c·ªßa MSE: `rmse = mean_squared_error(y_test, y_pred, squared=False)`. Tuy nhi√™n, t√¥i khuy·∫øn kh√≠ch b·∫°n n√¢ng c·∫•p scikit-learn ƒë·ªÉ t·∫≠n d·ª•ng c√°c t√≠nh nƒÉng m·ªõi nh·∫•t v√† s·ª≠a l·ªói.

**4. V√≠ d·ª• Code SQL v√† Python m·∫´u**

D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• kh√°c nhau v·ªÅ code SQL v√† Python ƒë·ªÉ b·∫°n tham kh·∫£o:

**V√≠ d·ª• 1: L·ªçc c√°c h·ª£p ch·∫•t d·ª±a tr√™n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ (Filtering compounds based on molecular weight)**

*   **SQL:**

```sql
-- English
SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    md.mw_freebase BETWEEN 200 AND 400
LIMIT 100;

-- Vietnamese
SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    md.mw_freebase BETWEEN 200 AND 400
LIMIT 100;
```

*   **Python:**

```python
# English
import pandas as pd
from rdkit import Chem

# Load data (replace with your actual loading method)
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# Function to calculate molecular weight using RDKit
def calculate_mw(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Chem.Descriptors.MolWt(mol)
    return None

# Apply the function to calculate molecular weight
data['MW'] = data['canonical_smiles'].apply(calculate_mw)

# Filter compounds with MW between 200 and 400
filtered_data = data[(data['MW'] >= 200) & (data['MW'] <= 400)]

print(filtered_data.head())


# Vietnamese
import pandas as pd
from rdkit import Chem

# T·∫£i d·ªØ li·ªáu (thay th·∫ø b·∫±ng ph∆∞∆°ng ph√°p t·∫£i d·ªØ li·ªáu th·ª±c t·∫ø c·ªßa b·∫°n)
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# H√†m t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ b·∫±ng RDKit
def tinh_trong_luong_phan_tu(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return Chem.Descriptors.MolWt(mol)
    return None

# √Åp d·ª•ng h√†m ƒë·ªÉ t√≠nh to√°n tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠
data['MW'] = data['canonical_smiles'].apply(tinh_trong_luong_phan_tu)

# L·ªçc c√°c h·ª£p ch·∫•t c√≥ MW trong kho·∫£ng 200 v√† 400
filtered_data = data[(data['MW'] >= 200) & (data['MW'] <= 400)]

print(filtered_data.head())
```

**V√≠ d·ª• 2: T√≠nh to√°n s·ªë l∆∞·ª£ng v√≤ng (Calculating the number of rings)**

*   **SQL:** (Kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp trong SQL, c·∫ßn s·ª≠ d·ª•ng Python)
*   **Python:**

```python
# English
import pandas as pd
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

# Load data
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# Function to calculate the number of rings
def calculate_num_rings(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return rdMolDescriptors.CalcNumRings(mol)
    return None

# Apply the function
data['NumRings'] = data['canonical_smiles'].apply(calculate_num_rings)

print(data.head())


# Vietnamese
import pandas as pd
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors

# T·∫£i d·ªØ li·ªáu
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# H√†m t√≠nh to√°n s·ªë l∆∞·ª£ng v√≤ng
def tinh_so_luong_vong(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        return rdMolDescriptors.CalcNumRings(mol)
    return None

# √Åp d·ª•ng h√†m
data['NumRings'] = data['canonical_smiles'].apply(tinh_so_luong_vong)

print(data.head())
```

**V√≠ d·ª• 3: Ph√¢n t√≠ch ho·∫°t t√≠nh sinh h·ªçc (Analyzing activity data)**

*   **SQL:**

```sql
-- English
SELECT
    act.standard_type,
    AVG(act.standard_value) AS average_value,
    COUNT(*) AS num_measurements
FROM
    activities act
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')
    AND act.standard_value IS NOT NULL
GROUP BY
    act.standard_type;

-- Vietnamese
SELECT
    act.standard_type,
    AVG(act.standard_value) AS average_value,
    COUNT(*) AS num_measurements
FROM
    activities act
WHERE
    act.standard_type IN ('IC50', 'Ki', 'EC50')
    AND act.standard_value IS NOT NULL
GROUP BY
    act.standard_type;
```

*   **Python:** (C√≥ th·ªÉ d√πng ƒë·ªÉ tr·ª±c quan h√≥a k·∫øt qu·∫£)

```python
# English
import pandas as pd
import matplotlib.pyplot as plt

# Load data (assuming you have activity data in a CSV)
data = pd.read_csv("chembl_data.csv")

# Group by standard_type and calculate the mean standard_value
activity_summary = data.groupby('standard_type')['standard_value'].mean()

# Plot the activity summary
activity_summary.plot(kind='bar')
plt.title('Average Activity Values by Standard Type')
plt.xlabel('Standard Type')
plt.ylabel('Average Standard Value')
plt.show()


# Vietnamese
import pandas as pd
import matplotlib.pyplot as plt

# T·∫£i d·ªØ li·ªáu (gi·∫£ s·ª≠ b·∫°n c√≥ d·ªØ li·ªáu ho·∫°t t√≠nh trong m·ªôt file CSV)
data = pd.read_csv("chembl_data.csv")

# Nh√≥m theo standard_type v√† t√≠nh gi√° tr·ªã trung b√¨nh c·ªßa standard_value
activity_summary = data.groupby('standard_type')['standard_value'].mean()

# V·∫Ω bi·ªÉu ƒë·ªì t√≥m t·∫Øt ho·∫°t t√≠nh
activity_summary.plot(kind='bar')
plt.title('Gi√° tr·ªã Ho·∫°t t√≠nh Trung b√¨nh theo Lo·∫°i Ti√™u chu·∫©n')
plt.xlabel('Lo·∫°i Ti√™u chu·∫©n')
plt.ylabel('Gi√° tr·ªã Ti√™u chu·∫©n Trung b√¨nh')
plt.show()
```

**V√≠ d·ª• 4: S·ª≠ d·ª•ng Random Forest ƒë·ªÉ d·ª± ƒëo√°n ho·∫°t t√≠nh (Using Random Forest for activity prediction)**

*   **Python:**

```python
# English
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Load data and calculate descriptors (as shown in previous examples)
# Assuming 'data' DataFrame is already prepared

# Prepare data
features = ['Molecular Weight', 'LogP', 'TPSA']  # Adjust based on your available descriptors
target = 'pIC50'

data = data.dropna(subset=features + [target])

X = data[features]
y = data[target]

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train Random Forest model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate model
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

# Vietnamese
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# T·∫£i d·ªØ li·ªáu v√† t√≠nh to√°n descriptor (nh∆∞ trong c√°c v√≠ d·ª• tr∆∞·ªõc)
# Gi·∫£ s·ª≠ DataFrame 'data' ƒë√£ ƒë∆∞·ª£c chu·∫©n b·ªã

# Chu·∫©n b·ªã d·ªØ li·ªáu
features = ['Molecular Weight', 'LogP', 'TPSA']  # ƒêi·ªÅu ch·ªânh d·ª±a tr√™n c√°c descriptor c√≥ s·∫µn
target = 'pIC50'

data = data.dropna(subset=features + [target])

X = data[features]
y = data[target]

# Chia d·ªØ li·ªáu
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# ƒê√°nh gi√° m√¥ h√¨nh
y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```

**V√≠ d·ª• 5: T√≠nh to√°n Murcko Fragments (Calculating Murcko Fragments)**

*   **Python:**

```python
# English
import pandas as pd
from rdkit import Chem
from rdkit.Chem import MurckoFragment

# Load data
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# Function to calculate Murcko Fragment
def calculate_murcko(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        core = MurckoFragment.GetMurckoFragment(mol)
        return Chem.MolToSmiles(core)
    return None

# Apply the function
data['MurckoFragment'] = data['canonical_smiles'].apply(calculate_murcko)

print(data.head())

# Vietnamese
import pandas as pd
from rdkit import Chem
from rdkit.Chem import MurckoFragment

# T·∫£i d·ªØ li·ªáu
data = pd.read_csv("chembl_data.csv")
data = data.dropna(subset=['canonical_smiles'])

# H√†m t√≠nh to√°n Murcko Fragment
def tinh_murcko(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        core = MurckoFragment.GetMurckoFragment(mol)
        return Chem.MolToSmiles(core)
    return None

# √Åp d·ª•ng h√†m
data['MurckoFragment'] = data['canonical_smiles'].apply(tinh_murcko)

print(data.head())
```

**L∆∞u √Ω quan tr·ªçng:**

*   ƒê·∫£m b·∫£o b·∫°n ƒë√£ c√†i ƒë·∫∑t t·∫•t c·∫£ c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt (RDKit, Pandas, Scikit-learn, Matplotlib, Seaborn). B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng `pip install rdkit pandas scikit-learn matplotlib seaborn` ƒë·ªÉ c√†i ƒë·∫∑t ch√∫ng.
*   ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n file v√† t√™n c·ªôt cho ph√π h·ª£p v·ªõi d·ªØ li·ªáu c·ªßa b·∫°n.
*   C√°c v√≠ d·ª• tr√™n ch·ªâ l√† ƒëi·ªÉm kh·ªüi ƒë·∫ßu. B·∫°n c√≥ th·ªÉ t√πy ch·ªânh v√† m·ªü r·ªông ch√∫ng ƒë·ªÉ ph√π h·ª£p v·ªõi nhu c·∫ßu c·ª• th·ªÉ c·ªßa d·ª± √°n.

T√¥i hy v·ªçng nh·ªØng h∆∞·ªõng d·∫´n v√† v√≠ d·ª• n√†y s·∫Ω gi√∫p b·∫°n ti·∫øn h√†nh d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 m·ªôt c√°ch hi·ªáu qu·∫£. N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi! Ch√∫c b·∫°n th√†nh c√¥ng!
