# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: B·∫£n ƒë·ªì kh√¥ng gian h√≥a h·ªçc c·ªßa c√°c ph√¢n t·ª≠ ChEMBL
---
Tuy·ªát v·ªùi! T√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35 n√†y. V·ªõi vai tr√≤ l√† Chuy√™n gia R&D D∆∞·ª£c h·ªçc, t√¥i s·∫Ω cung c·∫•p h∆∞·ªõng d·∫´n chi ti·∫øt, code m·∫´u v√† gi·∫£i th√≠ch r√µ r√†ng ƒë·ªÉ b·∫°n c√≥ th·ªÉ tri·ªÉn khai d·ª± √°n m·ªôt c√°ch hi·ªáu qu·∫£.

**1. Ph√¢n T√≠ch M√¥ H√¨nh Ph√¢n T√≠ch (Analysis of the Analysis Model)**

D·ª±a tr√™n y√™u c·∫ßu c·ªßa b·∫°n, ch√∫ng ta s·∫Ω x√¢y d·ª±ng m·ªôt quy tr√¨nh ph√¢n t√≠ch d·ªØ li·ªáu Chembl 35 k·∫øt h·ª£p RDKit ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. M√¥ h√¨nh n√†y bao g·ªìm c√°c b∆∞·ªõc ch√≠nh sau:

*   **Thu th·∫≠p v√† Chu·∫©n b·ªã D·ªØ li·ªáu (Data Acquisition and Preparation):**
    *   S·ª≠ d·ª•ng SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu t·ª´ database Chembl 35 (tr√™n PostgreSQL).
    *   L·ªçc v√† ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu (v√≠ d·ª•: lo·∫°i b·ªè c√°c gi√° tr·ªã kh√¥ng h·ª£p l·ªá, chu·∫©n h√≥a d·ªØ li·ªáu).
    *   L∆∞u d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω v√†o file CSV.
*   **T√≠nh To√°n ƒê·∫∑c Tr∆∞ng Ph√¢n T·ª≠ (Molecular Feature Calculation):**
    *   S·ª≠ d·ª•ng RDKit ƒë·ªÉ t√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ (molecular descriptors) t·ª´ SMILES strings. C√°c ƒë·∫∑c tr∆∞ng n√†y c√≥ th·ªÉ bao g·ªìm:
        *   T√≠nh ch·∫•t v·∫≠t l√Ω h√≥a h·ªçc (physicochemical properties): LogP, Molecular Weight, Topological Polar Surface Area (TPSA).
        *   ƒê·∫∑c tr∆∞ng c·∫•u tr√∫c (structural features): s·ªë l∆∞·ª£ng v√≤ng, s·ªë l∆∞·ª£ng nguy√™n t·ª≠, s·ªë l∆∞·ª£ng li√™n k·∫øt.
        *   Fingerprints: Morgan fingerprints, MACCS keys.
*   **Ph√¢n T√≠ch Th·ªëng K√™ v√† Tr·ª±c Quan H√≥a (Statistical Analysis and Visualization):**
    *   S·ª≠ d·ª•ng Python (v·ªõi c√°c th∆∞ vi·ªán nh∆∞ pandas, numpy, matplotlib, seaborn) ƒë·ªÉ th·ª±c hi·ªán ph√¢n t√≠ch th·ªëng k√™ m√¥ t·∫£ (descriptive statistics) v√† tr·ª±c quan h√≥a d·ªØ li·ªáu.
    *   V√≠ d·ª•: v·∫Ω bi·ªÉu ƒë·ªì ph√¢n ph·ªëi c·ªßa c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠, bi·ªÉu ƒë·ªì scatter ƒë·ªÉ t√¨m m·ªëi t∆∞∆°ng quan gi·ªØa c√°c ƒë·∫∑c tr∆∞ng v√† ho·∫°t t√≠nh sinh h·ªçc.
*   **X√¢y D·ª±ng M√¥ H√¨nh H·ªçc M√°y (Machine Learning Model Building):**
    *   S·ª≠ d·ª•ng scikit-learn ƒë·ªÉ x√¢y d·ª±ng c√°c m√¥ h√¨nh h·ªçc m√°y d·ª± ƒëo√°n ho·∫°t t√≠nh sinh h·ªçc (v√≠ d·ª•: h·ªìi quy tuy·∫øn t√≠nh, random forest, support vector machines).
    *   S·ª≠ d·ª•ng c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ l√†m ƒë·∫ßu v√†o cho m√¥ h√¨nh.
    *   ƒê√°nh gi√° hi·ªáu su·∫•t m√¥ h√¨nh b·∫±ng c√°c metrics ph√π h·ª£p (v√≠ d·ª•: R-squared, RMSE, AUC).

**2. H∆∞·ªõng D·∫´n Song Ng·ªØ (Bilingual Instructions)**

**2.1. K·∫øt N·ªëi C∆° S·ªü D·ªØ Li·ªáu v√† Truy V·∫•n SQL (Database Connection and SQL Queries)**

**Ti·∫øng Vi·ªát:**

1.  S·ª≠ d·ª•ng pgAdmin ƒë·ªÉ k·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu PostgreSQL c·ªßa b·∫°n.
2.  T·∫°o m·ªôt query m·ªõi v√† vi·∫øt c√°c c√¢u l·ªánh SQL ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu mong mu·ªën t·ª´ Chembl 35.
3.  L∆∞u k·∫øt qu·∫£ truy v·∫•n v√†o file CSV (v√≠ d·ª•: `../data/chembl_data.csv`).

**English:**

1.  Use pgAdmin to connect to your PostgreSQL database.
2.  Create a new query and write SQL statements to retrieve the desired data from Chembl 35.
3.  Save the query results to a CSV file (e.g., `../data/chembl_data.csv`).

**2.2. T√≠nh To√°n ƒê·∫∑c Tr∆∞ng Ph√¢n T·ª≠ v·ªõi RDKit (Molecular Feature Calculation with RDKit)**

**Ti·∫øng Vi·ªát:**

1.  Trong Jupyter Notebook, import th∆∞ vi·ªán RDKit.
2.  ƒê·ªçc file CSV ch·ª©a d·ªØ li·ªáu Chembl.
3.  S·ª≠ d·ª•ng RDKit ƒë·ªÉ chuy·ªÉn ƒë·ªïi SMILES strings th√†nh c√°c ƒë·ªëi t∆∞·ª£ng ph√¢n t·ª≠.
4.  T√≠nh to√°n c√°c ƒë·∫∑c tr∆∞ng ph√¢n t·ª≠ mong mu·ªën (v√≠ d·ª•: LogP, Molecular Weight).
5.  L∆∞u c√°c ƒë·∫∑c tr∆∞ng n√†y v√†o DataFrame.

**English:**

1.  In a Jupyter Notebook, import the RDKit library.
2.  Read the CSV file containing Chembl data.
3.  Use RDKit to convert SMILES strings into molecule objects.
4.  Calculate the desired molecular features (e.g., LogP, Molecular Weight).
5.  Store these features in a DataFrame.

**2.3. X√¢y D·ª±ng M√¥ H√¨nh H·ªçc M√°y (Machine Learning Model Building)**

**Ti·∫øng Vi·ªát:**

1.  Chu·∫©n b·ªã d·ªØ li·ªáu: t√°ch features (ƒë·∫∑c tr∆∞ng) v√† target (bi·∫øn m·ª•c ti√™u).
2.  Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra.
3.  Ch·ªçn m·ªôt m√¥ h√¨nh h·ªçc m√°y (v√≠ d·ª•: Random Forest).
4.  Hu·∫•n luy·ªán m√¥ h√¨nh tr√™n t·∫≠p hu·∫•n luy·ªán.
5.  ƒê√°nh gi√° m√¥ h√¨nh tr√™n t·∫≠p ki·ªÉm tra.

**English:**

1.  Prepare the data: separate features and target.
2.  Split the data into training and test sets.
3.  Choose a machine learning model (e.g., Random Forest).
4.  Train the model on the training set.
5.  Evaluate the model on the test set.

**3. Code SQL v√† Python (SQL and Python Code)**

**3.1. Code SQL**

```sql
-- English: Select 100 rows from the activities table with specific conditions
-- Vietnamese: Ch·ªçn 100 d√≤ng t·ª´ b·∫£ng activities v·ªõi c√°c ƒëi·ªÅu ki·ªán c·ª• th·ªÉ
SELECT
    act.molregno,
    act.standard_type,
    act.standard_relation,
    act.standard_value,
    act.standard_units,
    cmp.chembl_id,
    cmp.smiles
FROM
    activities act
JOIN
    molecule_dictionary cmp ON act.molregno = cmp.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_relation = '='
    AND act.standard_value IS NOT NULL
    AND act.standard_units = 'nM'
    --AND act.standard_value ~ '^[0-9\.]+$' -- This line might cause an error
LIMIT 100;
```

**L∆∞u √Ω:** D√≤ng `AND act.standard_value ~ '^[0-9\.]+$'` c√≥ th·ªÉ g√¢y ra l·ªói v√¨ ki·ªÉu d·ªØ li·ªáu c·ªßa `standard_value` l√† numeric. B·∫°n c√≥ th·ªÉ b·ªè qua d√≤ng n√†y ho·∫∑c chuy·ªÉn ƒë·ªïi `standard_value` sang ki·ªÉu text ƒë·ªÉ so s√°nh.

**3.2. Code Python**

```python
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Define the base path for your project
base_path = "."  # Assuming the notebook is in the root directory

# Read the CSV file containing Chembl data
data_path = os.path.join(base_path, 'data', 'chembl_data.csv') # Assuming the CSV is stored in a 'data' folder
df = pd.read_csv(data_path)

# Function to calculate molecular weight using RDKit
def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None

# Apply the function to calculate molecular weight for each SMILES string
df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)

# Convert standard_value to numeric, handling errors
df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')

# Drop rows with missing values (NaN)
df = df.dropna()

# Define features (X) and target (y)
X = df[['molecular_weight']]
y = df['standard_value']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a Random Forest Regressor model
model = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")
```

**4. V√≠ D·ª• Code SQL v√† Python (SQL and Python Code Examples)**

D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u ƒë·ªÉ b·∫°n tham kh·∫£o:

**V√≠ d·ª• 1: Truy v·∫•n th√¥ng tin c∆° b·∫£n v·ªÅ c√°c h·ª£p ch·∫•t (Basic Compound Information Query)**

**SQL:**

```sql
-- English: Select chembl_id and smiles for the first 100 compounds
-- Vietnamese: Ch·ªçn chembl_id v√† smiles c·ªßa 100 h·ª£p ch·∫•t ƒë·∫ßu ti√™n
SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;
```

**Python:**

```python
# English: Read the first 100 rows from the molecule_dictionary table into a Pandas DataFrame
# Vietnamese: ƒê·ªçc 100 d√≤ng ƒë·∫ßu ti√™n t·ª´ b·∫£ng molecule_dictionary v√†o DataFrame Pandas
import pandas as pd
import psycopg2

# Database credentials
db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}

# Connect to the database
conn = psycopg2.connect(**db_params)

# SQL query to retrieve the first 100 rows from molecule_dictionary
sql_query = "SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;"

# Read the data into a Pandas DataFrame
df = pd.read_sql(sql_query, conn)

# Close the database connection
conn.close()

# Print the DataFrame
print(df.head())
```

**V√≠ d·ª• 2: T√≠nh LogP s·ª≠ d·ª•ng RDKit (Calculate LogP using RDKit)**

**Python:**

```python
# English: Calculate LogP for a list of SMILES strings
# Vietnamese: T√≠nh LogP cho m·ªôt danh s√°ch c√°c chu·ªói SMILES
from rdkit import Chem
from rdkit.Chem import Crippen

smiles_list = ['CC(=O)Oc1ccccc1C(=O)O', 'c1ccccc1', 'CCO']

logp_values = []
for smiles in smiles_list:
    mol = Chem.MolFromSmiles(smiles)
    if mol:
        logp = Crippen.MolLogP(mol)
        logp_values.append(logp)
    else:
        logp_values.append(None)

print(logp_values)
```

**V√≠ d·ª• 3: L·ªçc c√°c h·ª£p ch·∫•t c√≥ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ nh·∫•t ƒë·ªãnh (Filter Compounds by Molecular Weight)**

**SQL:**

```sql
-- English: This SQL query is not directly possible as molecular weight is not stored in the database.
-- You would need to calculate it in Python using RDKit after fetching SMILES.
-- Vietnamese: Truy v·∫•n SQL n√†y kh√¥ng th·ªÉ th·ª±c hi·ªán tr·ª±c ti·∫øp v√¨ tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ kh√¥ng ƒë∆∞·ª£c l∆∞u tr·ªØ trong c∆° s·ªü d·ªØ li·ªáu.
-- B·∫°n c·∫ßn t√≠nh to√°n n√≥ trong Python b·∫±ng RDKit sau khi l·∫•y SMILES.

-- Example: Select chembl_id and smiles for compounds, then calculate molecular weight in Python
-- V√≠ d·ª•: Ch·ªçn chembl_id v√† smiles cho c√°c h·ª£p ch·∫•t, sau ƒë√≥ t√≠nh tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ trong Python
SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;
```

**Python:**

```python
# English: Filter compounds by molecular weight after fetching data
# Vietnamese: L·ªçc c√°c h·ª£p ch·∫•t theo tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ sau khi l·∫•y d·ªØ li·ªáu
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
import psycopg2

# Database credentials
db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}

# Connect to the database
conn = psycopg2.connect(**db_params)

# SQL query to retrieve chembl_id and smiles
sql_query = "SELECT chembl_id, smiles FROM molecule_dictionary LIMIT 100;"

# Read the data into a Pandas DataFrame
df = pd.read_sql(sql_query, conn)

# Close the database connection
conn.close()

# Function to calculate molecular weight
def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None

# Apply the function to calculate molecular weight for each SMILES string
df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)

# Filter compounds with molecular weight between 200 and 400
filtered_df = df[(df['molecular_weight'] >= 200) & (df['molecular_weight'] <= 400)]

print(filtered_df)
```

**V√≠ d·ª• 4: Ph√¢n t√≠ch ho·∫°t t√≠nh sinh h·ªçc (Activity Analysis)**

**SQL:**

```sql
-- English: Select IC50 values for a specific target
-- Vietnamese: Ch·ªçn gi√° tr·ªã IC50 cho m·ªôt target c·ª• th·ªÉ
SELECT act.standard_value
FROM activities act
JOIN target_dictionary tgt ON act.tid = tgt.tid
WHERE tgt.chembl_id = 'CHEMBL205'  -- Replace with the desired target CHEMBL ID
AND act.standard_type = 'IC50'
AND act.standard_relation = '='
LIMIT 100;
```

**Python:**

```python
# English: Analyze IC50 values fetched from the database
# Vietnamese: Ph√¢n t√≠ch c√°c gi√° tr·ªã IC50 ƒë∆∞·ª£c l·∫•y t·ª´ c∆° s·ªü d·ªØ li·ªáu
import pandas as pd
import matplotlib.pyplot as plt
import psycopg2

# Database credentials
db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}

# Connect to the database
conn = psycopg2.connect(**db_params)

# SQL query to retrieve IC50 values for a specific target
sql_query = """
SELECT act.standard_value
FROM activities act
JOIN target_dictionary tgt ON act.tid = tgt.tid
WHERE tgt.chembl_id = 'CHEMBL205'  -- Replace with the desired target CHEMBL ID
AND act.standard_type = 'IC50'
AND act.standard_relation = '='
LIMIT 100;
"""

# Read the data into a Pandas DataFrame
df = pd.read_sql(sql_query, conn)

# Close the database connection
conn.close()

# Convert standard_value to numeric, handling errors
df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')

# Drop rows with missing values (NaN)
df = df.dropna()

# Plot a histogram of IC50 values
plt.hist(df['standard_value'], bins=20)
plt.xlabel('IC50 Value')
plt.ylabel('Frequency')
plt.title('Distribution of IC50 Values')
plt.show()
```

**V√≠ d·ª• 5: X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh (Activity Prediction Model)**

**Python:**

```python
# English: Build a simple activity prediction model using molecular weight
# Vietnamese: X√¢y d·ª±ng m√¥ h√¨nh d·ª± ƒëo√°n ho·∫°t t√≠nh ƒë∆°n gi·∫£n s·ª≠ d·ª•ng tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠
import pandas as pd
from rdkit import Chem
from rdkit.Chem import Descriptors
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import psycopg2

# Database credentials
db_params = {
    'host': '192.168.206.136',
    'user': 'rd',
    'password': 'rd',
    'database': 'chembl_35'
}

# Connect to the database
conn = psycopg2.connect(**db_params)

# SQL query to retrieve data for activity prediction
sql_query = """
SELECT act.standard_value, cmp.smiles
FROM activities act
JOIN molecule_dictionary cmp ON act.molregno = cmp.molregno
WHERE act.standard_type = 'IC50'
AND act.standard_relation = '='
AND act.standard_value IS NOT NULL
LIMIT 100;
"""

# Read the data into a Pandas DataFrame
df = pd.read_sql(sql_query, conn)

# Close the database connection
conn.close()


# Function to calculate molecular weight
def calculate_molecular_weight(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            return Descriptors.MolWt(mol)
        else:
            return None
    except:
        return None

# Apply the function to calculate molecular weight for each SMILES string
df['molecular_weight'] = df['smiles'].apply(calculate_molecular_weight)

# Convert standard_value to numeric, handling errors
df['standard_value'] = pd.to_numeric(df['standard_value'], errors='coerce')

# Drop rows with missing values (NaN)
df = df.dropna()

# Prepare data for modeling
X = df[['molecular_weight']]
y = df['standard_value']

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a linear regression model
model = LinearRegression()

# Train the model
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse}")
```

**L∆∞u √Ω quan tr·ªçng:**

*   **S·ª≠a l·ªói SQL:** Trong truy v·∫•n SQL, h√£y ƒë·∫£m b·∫£o x·ª≠ l√Ω ƒë√∫ng ki·ªÉu d·ªØ li·ªáu c·ªßa c·ªôt `standard_value`. N·∫øu c·∫ßn, b·∫°n c√≥ th·ªÉ b·ªè qua vi·ªác l·ªçc theo regular expression ho·∫∑c chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu tr∆∞·ªõc khi so s√°nh.
*   **Phi√™n b·∫£n Scikit-learn:** N·∫øu b·∫°n g·∫∑p l·ªói v·ªÅ tham s·ªë `squared=False` trong `mean_squared_error`, h√£y c·∫≠p nh·∫≠t scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t ho·∫∑c b·ªè tham s·ªë n√†y (phi√™n b·∫£n c≈© m·∫∑c ƒë·ªãnh `squared=True`).
*   **ƒê∆∞·ªùng d·∫´n:** S·ª≠ d·ª•ng `os.path.join(base_path, ...)` ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh di ƒë·ªông c·ªßa code khi di chuy·ªÉn gi·ªØa c√°c m√¥i tr∆∞·ªùng.

Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.
