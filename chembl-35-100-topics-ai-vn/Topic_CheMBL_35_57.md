# PharmApp Suite
## üß† AI for Drug Discovery and Development üß™
| Copyright 2025 | Nghi√™n C·ª©u Thu·ªëc | www.nghiencuuthuoc.com | Zalo: +84888999311 |

üß© Topic: D·ªØ li·ªáu t√≠n hi·ªáu c·∫£nh b√°o d∆∞·ª£c l√Ω
---
Tuy·ªát v·ªùi! V·ªõi vai tr√≤ l√† m·ªôt chuy√™n gia nghi√™n c·ª©u v√† ph√°t tri·ªÉn d∆∞·ª£c h·ªçc, t√¥i r·∫•t vui ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong d·ª± √°n ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL 35 s·ª≠ d·ª•ng RDKit. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch, h∆∞·ªõng d·∫´n v√† code m·∫´u, t·∫≠p trung v√†o vi·ªác gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ b·∫°n ƒë√£ n√™u v√† tu√¢n th·ªß theo quy tr√¨nh l√†m vi·ªác b·∫°n ƒë√£ thi·∫øt l·∫≠p.

**1. Ph√¢n t√≠ch m√¥ h√¨nh ph√¢n t√≠ch (Analysis of the Analysis Model)**

D·ª±a tr√™n th√¥ng tin b·∫°n cung c·∫•p, m√¥ h√¨nh ph√¢n t√≠ch c·ªßa b·∫°n c√≥ v·∫ª nh∆∞ t·∫≠p trung v√†o vi·ªác tr√≠ch xu·∫•t, x·ª≠ l√Ω v√† ph√¢n t√≠ch d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35 ƒë·ªÉ h·ªó tr·ª£ nghi√™n c·ª©u v√† ph√°t tri·ªÉn thu·ªëc. C·ª• th·ªÉ, b·∫°n ƒëang s·ª≠ d·ª•ng PostgreSQL (psql) ƒë·ªÉ truy v·∫•n d·ªØ li·ªáu, RDKit ƒë·ªÉ x·ª≠ l√Ω th√¥ng tin h√≥a h·ªçc, v√† Jupyter Notebook ƒë·ªÉ vi·∫øt v√† ch·∫°y code ph√¢n t√≠ch.

*   **SQL (Structured Query Language):** ƒê∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ truy v·∫•n v√† tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35. C√°c truy v·∫•n SQL s·∫Ω ƒë∆∞·ª£c vi·∫øt ƒë·ªÉ l·ªçc d·ªØ li·ªáu li√™n quan ƒë·∫øn c√°c ho·∫°t t√≠nh sinh h·ªçc, c·∫•u tr√∫c h√≥a h·ªçc, v√† c√°c th√¥ng tin kh√°c c·∫ßn thi·∫øt cho nghi√™n c·ª©u.
*   **RDKit:** M·ªôt th∆∞ vi·ªán m√£ ngu·ªìn m·ªü cho tin h·ªçc h√≥a h·ªçc v√† tin sinh h·ªçc. RDKit s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ x·ª≠ l√Ω c·∫•u tr√∫c h√≥a h·ªçc (v√≠ d·ª•: chuy·ªÉn ƒë·ªïi SMILES th√†nh fingerprint), t√≠nh to√°n c√°c thu·ªôc t√≠nh h√≥a l√Ω, v√† th·ª±c hi·ªán c√°c ph√¢n t√≠ch c·∫•u tr√∫c.
*   **Jupyter Notebook:** M·ªôt m√¥i tr∆∞·ªùng t∆∞∆°ng t√°c cho ph√©p b·∫°n vi·∫øt v√† ch·∫°y code Python, hi·ªÉn th·ªã k·∫øt qu·∫£, v√† ghi l·∫°i qu√° tr√¨nh ph√¢n t√≠ch. Jupyter Notebook r·∫•t ph√π h·ª£p cho vi·ªác kh√°m ph√° d·ªØ li·ªáu, ph√°t tri·ªÉn m√¥ h√¨nh, v√† tr√¨nh b√†y k·∫øt qu·∫£ nghi√™n c·ª©u.

**2. H∆∞·ªõng d·∫´n song ng·ªØ (Bilingual Guidance)**

**2.1. V·∫•n ƒë·ªÅ v√† gi·∫£i ph√°p (Problems and Solutions)**

*   **L·ªói SQL: `ERROR: operator does not exist: numeric ~ unknown LINE 12: AND act.standard_value ~ '^[0-9\.]+$'`**

    *   **Ti·∫øng Vi·ªát:** L·ªói n√†y x·∫£y ra do b·∫°n ƒëang c·ªë g·∫Øng s·ª≠ d·ª•ng to√°n t·ª≠ `~` (regex match) tr√™n m·ªôt c·ªôt ki·ªÉu s·ªë (`numeric`). PostgreSQL kh√¥ng h·ªó tr·ª£ to√°n t·ª≠ n√†y cho ki·ªÉu s·ªë.
    *   **Ti·∫øng Anh:** This error occurs because you are trying to use the `~` (regex match) operator on a numeric column (`numeric`). PostgreSQL does not support this operator for numeric types.
    *   **Gi·∫£i ph√°p:** Chuy·ªÉn ƒë·ªïi c·ªôt `standard_value` sang ki·ªÉu text tr∆∞·ªõc khi s·ª≠ d·ª•ng to√°n t·ª≠ `~`, ho·∫∑c s·ª≠ d·ª•ng c√°c h√†m s·ªë h·ªçc ƒë·ªÉ l·ªçc d·ªØ li·ªáu.
        *   **Ti·∫øng Vi·ªát:** Chuy·ªÉn ƒë·ªïi ki·ªÉu d·ªØ li·ªáu b·∫±ng `CAST(act.standard_value AS TEXT)`
        *   **Ti·∫øng Anh:** Cast the data type using `CAST(act.standard_value AS TEXT)`

*   **L·ªói Python: `phi√™n b·∫£n scikit-learn c≈© kh√¥ng h·ªó tr·ª£ tham s·ªë squared=False trong h√†m mean_squared_error`**

    *   **Ti·∫øng Vi·ªát:** Phi√™n b·∫£n scikit-learn b·∫°n ƒëang s·ª≠ d·ª•ng qu√° c≈© v√† kh√¥ng h·ªó tr·ª£ tham s·ªë `squared=False` trong h√†m `mean_squared_error`. Tham s·ªë n√†y ƒë∆∞·ª£c th√™m v√†o ƒë·ªÉ tr·∫£ v·ªÅ RMSE (Root Mean Squared Error) tr·ª±c ti·∫øp.
    *   **Ti·∫øng Anh:** The scikit-learn version you are using is too old and does not support the `squared=False` parameter in the `mean_squared_error` function. This parameter was added to directly return RMSE (Root Mean Squared Error).
    *   **Gi·∫£i ph√°p:**
        1.  N√¢ng c·∫•p scikit-learn l√™n phi√™n b·∫£n m·ªõi nh·∫•t: `pip install -U scikit-learn`
        2.  N·∫øu kh√¥ng th·ªÉ n√¢ng c·∫•p, t√≠nh RMSE th·ªß c√¥ng: `rmse = np.sqrt(mean_squared_error(y_true, y_pred))`
            *   **Ti·∫øng Vi·ªát:** S·ª≠ d·ª•ng `np.sqrt` t·ª´ th∆∞ vi·ªán NumPy ƒë·ªÉ t√≠nh cƒÉn b·∫≠c hai c·ªßa MSE.
            *   **Ti·∫øng Anh:** Use `np.sqrt` from the NumPy library to calculate the square root of MSE.

**2.2. C·∫•u tr√∫c th∆∞ m·ª•c (Folder Structure)**

B·∫°n ƒë√£ s·ª≠ d·ª•ng c·∫•u tr√∫c th∆∞ m·ª•c theo chu·∫©n AIMLOps Template. ƒêi·ªÅu n√†y r·∫•t t·ªët v√¨ n√≥ gi√∫p b·∫°n t·ªï ch·ª©c code, d·ªØ li·ªáu, v√† c√°c th√†nh ph·∫ßn kh√°c c·ªßa d·ª± √°n m·ªôt c√°ch c√≥ h·ªá th·ªëng.

**2.3. Quy tr√¨nh l√†m vi·ªác (Workflow)**

1.  **SQL tr√™n pgAdmin:** Vi·∫øt v√† ch·∫°y c√°c truy v·∫•n SQL tr√™n pgAdmin ƒë·ªÉ tr√≠ch xu·∫•t d·ªØ li·ªáu t·ª´ c∆° s·ªü d·ªØ li·ªáu ChEMBL 35. L∆∞u k·∫øt qu·∫£ v√†o c√°c file CSV trong th∆∞ m·ª•c `../data/`.
2.  **Jupyter Notebook:** S·ª≠ d·ª•ng Jupyter Notebook ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ c√°c file CSV, x·ª≠ l√Ω d·ªØ li·ªáu b·∫±ng RDKit, x√¢y d·ª±ng m√¥ h√¨nh, v√† ph√¢n t√≠ch k·∫øt qu·∫£.
3.  **T√™n file Notebook:** ƒê·∫∑t t√™n file Notebook theo ƒë·ªãnh d·∫°ng `"Topic_CheMBL_35_57_1_*"` v√† `"Topic_CheMBL_35_57_2_*"`.
4.  **ƒê∆∞·ªùng d·∫´n:** S·ª≠ d·ª•ng `os.path.join(base_path, ...)` ƒë·ªÉ k·∫øt n·ªëi c√°c ƒë∆∞·ªùng d·∫´n m·ªôt c√°ch an to√†n v√† linh ho·∫°t.

**3. Code m·∫´u (Code Examples)**

**3.1. SQL (English & Vietnamese Comments)**

```sql
-- English: This query extracts 100 compounds with IC50 values for a specific target.
-- Vietnamese: Truy v·∫•n n√†y tr√≠ch xu·∫•t 100 h·ª£p ch·∫•t v·ªõi gi√° tr·ªã IC50 cho m·ªôt m·ª•c ti√™u c·ª• th·ªÉ.
SELECT
    md.molregno, -- English: Molecule registry number, Vietnamese: S·ªë ƒëƒÉng k√Ω ph√¢n t·ª≠
    cs.canonical_smiles, -- English: Canonical SMILES string, Vietnamese: Chu·ªói SMILES chu·∫©n t·∫Øc
    act.standard_value, -- English: Standard value of the activity, Vietnamese: Gi√° tr·ªã ti√™u chu·∫©n c·ªßa ho·∫°t t√≠nh
    act.standard_units -- English: Standard units of the activity, Vietnamese: ƒê∆°n v·ªã ti√™u chu·∫©n c·ªßa ho·∫°t t√≠nh
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50' -- English: Filter for IC50 values, Vietnamese: L·ªçc theo gi√° tr·ªã IC50
    AND act.standard_relation = '=' -- English: Filter for exact IC50 values, Vietnamese: L·ªçc theo gi√° tr·ªã IC50 ch√≠nh x√°c
    AND act.standard_value IS NOT NULL -- English: Exclude null values, Vietnamese: Lo·∫°i b·ªè gi√° tr·ªã null
    AND CAST(act.standard_value AS TEXT) ~ '^[0-9\.]+$' -- English: Filter for numeric values, Vietnamese: L·ªçc theo gi√° tr·ªã s·ªë
LIMIT 100;
```

**3.2. Python (English & Vietnamese Comments)**

```python
# English: Import necessary libraries
# Vietnamese: Nh·∫≠p c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
import pandas as pd
import numpy as np
import os
from rdkit import Chem
from rdkit.Chem import AllChem
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# English: Define the base path for the project
# Vietnamese: ƒê·ªãnh nghƒ©a ƒë∆∞·ªùng d·∫´n g·ªëc cho d·ª± √°n
base_path = "path/to/your/project"  # Replace with your actual path

# English: Load the data from the CSV file
# Vietnamese: T·∫£i d·ªØ li·ªáu t·ª´ file CSV
data_path = os.path.join(base_path, "data", "your_data.csv")  # Replace with your actual file name
df = pd.read_csv(data_path)

# English: Function to convert SMILES to Morgan Fingerprints
# Vietnamese: H√†m chuy·ªÉn ƒë·ªïi SMILES th√†nh Morgan Fingerprints
def smiles_to_fingerprint(smiles, radius=2, nBits=2048):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=nBits)
        return np.array(fp)
    else:
        return None

# English: Apply the function to the SMILES column
# Vietnamese: √Åp d·ª•ng h√†m cho c·ªôt SMILES
df['fingerprint'] = df['canonical_smiles'].apply(smiles_to_fingerprint)

# English: Drop rows with missing fingerprints
# Vietnamese: Lo·∫°i b·ªè c√°c h√†ng c√≥ fingerprint b·ªã thi·∫øu
df = df.dropna(subset=['fingerprint'])

# English: Convert IC50 values to pIC50
# Vietnamese: Chuy·ªÉn ƒë·ªïi gi√° tr·ªã IC50 sang pIC50
df['pIC50'] = -np.log10(df['standard_value'] / 1e9)

# English: Prepare the data for machine learning
# Vietnamese: Chu·∫©n b·ªã d·ªØ li·ªáu cho m√°y h·ªçc
X = np.array(list(df['fingerprint']))
y = df['pIC50']

# English: Split the data into training and testing sets
# Vietnamese: Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† t·∫≠p ki·ªÉm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# English: Train a Random Forest Regressor model
# Vietnamese: Hu·∫•n luy·ªán m√¥ h√¨nh Random Forest Regressor
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# English: Make predictions on the test set
# Vietnamese: D·ª± ƒëo√°n tr√™n t·∫≠p ki·ªÉm tra
y_pred = model.predict(X_test)

# English: Evaluate the model
# Vietnamese: ƒê√°nh gi√° m√¥ h√¨nh
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)  # Calculate RMSE manually if necessary
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"Root Mean Squared Error: {rmse}")
print(f"R-squared: {r2}")
```

**4. V√≠ d·ª• code m·∫´u (Example Code Snippets)**

D∆∞·ªõi ƒë√¢y l√† 5 v√≠ d·ª• code SQL v√† Python m·∫´u, t·∫≠p trung v√†o c√°c t√°c v·ª• ph·ªï bi·∫øn trong ph√¢n t√≠ch d·ªØ li·ªáu ChEMBL.

**4.1. SQL: L·ªçc theo kho·∫£ng gi√° tr·ªã IC50 (Filtering by IC50 Range)**

```sql
-- English: Select compounds with IC50 values between 100 and 1000 nM
-- Vietnamese: Ch·ªçn c√°c h·ª£p ch·∫•t c√≥ gi√° tr·ªã IC50 n·∫±m trong kho·∫£ng t·ª´ 100 ƒë·∫øn 1000 nM
SELECT
    md.molregno,
    cs.canonical_smiles,
    act.standard_value
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
JOIN
    activities act ON md.molregno = act.molregno
WHERE
    act.standard_type = 'IC50'
    AND act.standard_value >= 100
    AND act.standard_value <= 1000
LIMIT 100;
```

**4.2. Python: T√≠nh to√°n c√°c thu·ªôc t√≠nh h√≥a l√Ω (Calculating Physicochemical Properties)**

```python
# English: Calculate LogP and Molecular Weight using RDKit
# Vietnamese: T√≠nh LogP v√† Tr·ªçng l∆∞·ª£ng ph√¢n t·ª≠ s·ª≠ d·ª•ng RDKit
from rdkit.Chem import Descriptors

def calculate_properties(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is not None:
        logp = Descriptors.MolLogP(mol)
        mw = Descriptors.MolWt(mol)
        return logp, mw
    else:
        return None, None

df[['logp', 'mw']] = df['canonical_smiles'].apply(lambda x: pd.Series(calculate_properties(x)))
```

**4.3. SQL: T√¨m ki·∫øm c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± (Finding Similar Compounds)**

(V√≠ d·ª• n√†y y√™u c·∫ßu ti·ªán √≠ch m·ªü r·ªông pg_trgm cho PostgreSQL ƒë·ªÉ so s√°nh chu·ªói)

```sql
-- English: Find compounds with similar SMILES strings
-- Vietnamese: T√¨m c√°c h·ª£p ch·∫•t c√≥ chu·ªói SMILES t∆∞∆°ng t·ª±
CREATE EXTENSION IF NOT EXISTS pg_trgm;

SELECT
    md.molregno,
    cs.canonical_smiles
FROM
    molecule_dictionary md
JOIN
    compound_structures cs ON md.molregno = cs.molregno
WHERE
    cs.canonical_smiles % 'CCO' -- English: Find compounds similar to ethanol, Vietnamese: T√¨m c√°c h·ª£p ch·∫•t t∆∞∆°ng t·ª± ethanol
LIMIT 100;
```

**4.4. Python: Tr·ª±c quan h√≥a d·ªØ li·ªáu (Data Visualization)**

```python
# English: Create a scatter plot of LogP vs. pIC50
# Vietnamese: T·∫°o bi·ªÉu ƒë·ªì ph√¢n t√°n c·ªßa LogP so v·ªõi pIC50
import matplotlib.pyplot as plt

plt.scatter(df['logp'], df['pIC50'])
plt.xlabel('LogP')
plt.ylabel('pIC50')
plt.title('LogP vs. pIC50')
plt.show()
```

**4.5. SQL: Th·ªëng k√™ s·ªë l∆∞·ª£ng ho·∫°t ch·∫•t theo lo·∫°i (Counting Activities by Type)**

```sql
-- English: Count the number of activities for each standard type
-- Vietnamese: ƒê·∫øm s·ªë l∆∞·ª£ng ho·∫°t ƒë·ªông cho m·ªói lo·∫°i ti√™u chu·∫©n
SELECT
    act.standard_type,
    COUNT(*)
FROM
    activities act
GROUP BY
    act.standard_type;
```

ƒê√¢y ch·ªâ l√† m·ªôt v√†i v√≠ d·ª• ƒë·ªÉ b·∫°n b·∫Øt ƒë·∫ßu. Ch√∫c b·∫°n th√†nh c√¥ng v·ªõi d·ª± √°n c·ªßa m√¨nh! N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ c√¢u h·ªèi n√†o kh√°c, ƒë·ª´ng ng·∫ßn ng·∫°i h·ªèi.
